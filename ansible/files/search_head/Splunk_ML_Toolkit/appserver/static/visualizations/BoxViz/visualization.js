define(["vizapi/SplunkVisualizationBase"],function(e){return function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./node_modules/@splunk/splunk-web-core/build_tools/web_loaders/splunk-public-path-injection-loader.js?/static/app/Splunk_ML_Toolkit/!./src/main/webapp/visualizations/BoxViz/visualization.es")}({"./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js":function(e,n,t){"use strict";var o=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,r=function(e){var n={};return function(t){return void 0===n[t]&&(n[t]=e(t)),n[t]}}(function(e){return o.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91});n.a=r},"./node_modules/@emotion/unitless/dist/unitless.browser.esm.js":function(e,n,t){"use strict";n.a={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1}},"./node_modules/@splunk/highcharts/highcharts-more.js":function(e,n){e.exports=function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=2)}([,,function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=t(3),i=(o=r)&&o.__esModule?o:{default:o};n.default=i.default,e.exports=n.default},function(e,n,t){"use strict";
/**
 * @license Highcharts JS v5.0.12 (2017-05-24)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
/**
 * @license Highcharts JS v5.0.12 (2017-05-24)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */var o;o=function(e){var n,t,o,r,i,s,a,l,c,d,h,u,p,f,m;!function(e){var n=e.CenteredSeriesMixin,t=e.each,o=e.extend,r=e.merge,i=e.splat;function s(e,n){this.init(e,n)}o(s.prototype,{coll:"pane",init:function(e,n){this.chart=n,this.background=[],n.pane.push(this),this.setOptions(e)},setOptions:function(e){this.options=e=r(this.defaultOptions,this.chart.angular?{background:{}}:void 0,e)},render:function(){var e,n,t=this.options,o=this.options.background,s=this.chart.renderer;if(this.group||(this.group=s.g("pane-group").attr({zIndex:t.zIndex||0}).add()),this.updateCenter(),o)for(o=i(o),e=Math.max(o.length,this.background.length||0),n=0;n<e;n++)o[n]&&this.axis?this.renderBackground(r(this.defaultBackgroundOptions,o[n]),n):this.background[n]&&(this.background[n]=this.background[n].destroy(),this.background.splice(n,1))},renderBackground:function(e,n){var t="animate";this.background[n]||(this.background[n]=this.chart.renderer.path().add(this.group),t="attr"),this.background[n][t]({d:this.axis.getPlotBandPath(e.from,e.to,e)}).attr({fill:e.backgroundColor,stroke:e.borderColor,"stroke-width":e.borderWidth,class:"highcharts-pane "+(e.className||"")})},defaultOptions:{center:["50%","50%"],size:"85%",startAngle:0},defaultBackgroundOptions:{shape:"circle",borderWidth:1,borderColor:"#cccccc",backgroundColor:{linearGradient:{x1:0,y1:0,x2:0,y2:1},stops:[[0,"#ffffff"],[1,"#e6e6e6"]]},from:-Number.MAX_VALUE,innerRadius:0,to:Number.MAX_VALUE,outerRadius:"105%"},updateCenter:function(e){this.center=(e||this.axis||{}).center=n.getCenter.call(this)},update:function(e,n){r(!0,this.options,e),this.setOptions(this.options),this.render(),t(this.chart.axes,function(e){e.pane===this&&(e.pane=null,e.update({},n))},this)}}),e.Pane=s}(e),r=(n=e).Axis,i=n.each,s=n.extend,a=n.map,l=n.merge,c=n.noop,d=n.pick,h=n.pInt,u=n.Tick,p=n.wrap,f=r.prototype,m=u.prototype,t={getOffset:c,redraw:function(){this.isDirty=!1},render:function(){this.isDirty=!1},setScale:c,setCategories:c,setTitle:c},o={defaultRadialGaugeOptions:{labels:{align:"center",x:0,y:null},minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,tickLength:10,tickPosition:"inside",tickWidth:2,title:{rotation:0},zIndex:2},defaultRadialXOptions:{gridLineWidth:1,labels:{align:null,distance:15,x:0,y:null},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},defaultRadialYOptions:{gridLineInterpolation:"circle",labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}},setOptions:function(e){var n=this.options=l(this.defaultOptions,this.defaultRadialOptions,e);n.plotBands||(n.plotBands=[])},getOffset:function(){f.getOffset.call(this),this.chart.axisOffset[this.side]=0},getLinePath:function(e,n){var t,o,r=this.center,i=this.chart,s=d(n,r[2]/2-this.offset);return this.isCircular||void 0!==n?o=this.chart.renderer.symbols.arc(this.left+r[0],this.top+r[1],s,s,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0}):(t=this.postTranslate(this.angleRad,s),o=["M",r[0]+i.plotLeft,r[1]+i.plotTop,"L",t.x,t.y]),o},setAxisTranslation:function(){f.setAxisTranslation.call(this),this.center&&(this.isCircular?this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.transA=this.center[2]/2/(this.max-this.min||1),this.isXAxis?this.minPixelPadding=this.transA*this.minPointOffset:this.minPixelPadding=0)},beforeSetTickPositions:function(){this.autoConnect=this.isCircular&&void 0===d(this.userMax,this.options.max)&&this.endAngleRad-this.startAngleRad==2*Math.PI,this.autoConnect&&(this.max+=(this.categories?1:this.pointRange)||this.closestPointRange||0)},setAxisSize:function(){f.setAxisSize.call(this),this.isRadial&&(this.pane.updateCenter(this),this.isCircular&&(this.sector=this.endAngleRad-this.startAngleRad),this.len=this.width=this.height=this.center[2]*d(this.sector,1)/2)},getPosition:function(e,n){return this.postTranslate(this.isCircular?this.translate(e):this.angleRad,d(this.isCircular?n:this.translate(e),this.center[2]/2)-this.offset)},postTranslate:function(e,n){var t=this.chart,o=this.center;return e=this.startAngleRad+e,{x:t.plotLeft+o[0]+Math.cos(e)*n,y:t.plotTop+o[1]+Math.sin(e)*n}},getPlotBandPath:function(e,n,t){var o,r,i,s,l=this.center,c=this.startAngleRad,u=l[2]/2,p=[d(t.outerRadius,"100%"),t.innerRadius,d(t.thickness,10)],f=Math.min(this.offset,0),m=/%$/,g=this.isCircular;return"polygon"===this.options.gridLineInterpolation?s=this.getPlotLinePath(e).concat(this.getPlotLinePath(n,!0)):(e=Math.max(e,this.min),n=Math.min(n,this.max),g||(p[0]=this.translate(e),p[1]=this.translate(n)),p=a(p,function(e){return m.test(e)&&(e=h(e,10)*u/100),e}),"circle"!==t.shape&&g?(o=c+this.translate(e),r=c+this.translate(n)):(o=-Math.PI/2,r=1.5*Math.PI,i=!0),p[0]-=f,p[2]-=f,s=this.chart.renderer.symbols.arc(this.left+l[0],this.top+l[1],p[0],p[0],{start:Math.min(o,r),end:Math.max(o,r),innerR:d(p[1],p[0]-p[2]),open:i})),s},getPlotLinePath:function(e,n){var t,o,r,s,a=this,l=a.center,c=a.chart,d=a.getPosition(e);return a.isCircular?s=["M",l[0]+c.plotLeft,l[1]+c.plotTop,"L",d.x,d.y]:"circle"===a.options.gridLineInterpolation?(e=a.translate(e))&&(s=a.getLinePath(0,e)):(i(c.xAxis,function(e){e.pane===a.pane&&(t=e)}),s=[],e=a.translate(e),r=t.tickPositions,t.autoConnect&&(r=r.concat([r[0]])),n&&(r=[].concat(r).reverse()),i(r,function(n,r){o=t.getPosition(n,e),s.push(r?"L":"M",o.x,o.y)})),s},getTitlePosition:function(){var e=this.center,n=this.chart,t=this.options.title;return{x:n.plotLeft+e[0]+(t.x||0),y:n.plotTop+e[1]-{high:.5,middle:.25,low:0}[t.align]*e[2]+(t.y||0)}}},p(f,"init",function(e,n,r){var i,a,c=n.angular,h=n.polar,u=r.isX,p=c&&u,f=n.options,m=r.pane||0,g=this.pane=n.pane[m],y=g.options;c?(s(this,p?t:o),(i=!u)&&(this.defaultRadialOptions=this.defaultRadialGaugeOptions)):h&&(s(this,o),i=u,this.defaultRadialOptions=u?this.defaultRadialXOptions:l(this.defaultYAxisOptions,this.defaultRadialYOptions)),c||h?(this.isRadial=!0,n.inverted=!1,f.chart.zoomType=null):this.isRadial=!1,i&&(g.axis=this),e.call(this,n,r),p||!c&&!h||(a=this.options,this.angleRad=(a.angle||0)*Math.PI/180,this.startAngleRad=(y.startAngle-90)*Math.PI/180,this.endAngleRad=(d(y.endAngle,y.startAngle+360)-90)*Math.PI/180,this.offset=a.offset||0,this.isCircular=i)}),p(f,"autoLabelAlign",function(e){if(!this.isRadial)return e.apply(this,[].slice.call(arguments,1))}),p(m,"getPosition",function(e,n,t,o,r){var i=this.axis;return i.getPosition?i.getPosition(t):e.call(this,n,t,o,r)}),p(m,"getLabelPosition",function(e,n,t,o,r,i,s,a,l){var c,h=this.axis,u=i.y,p=20,f=i.align,m=(h.translate(this.pos)+h.startAngleRad+Math.PI/2)/Math.PI*180%360;return h.isRadial?(c=h.getPosition(this.pos,h.center[2]/2+d(i.distance,-25)),"auto"===i.rotation?o.attr({rotation:m}):null===u&&(u=h.chart.renderer.fontMetrics(o.styles.fontSize).b-o.getBBox().height/2),null===f&&(h.isCircular?(this.label.getBBox().width>h.len*h.tickInterval/(h.max-h.min)&&(p=0),f=m>p&&m<180-p?"left":m>180+p&&m<360-p?"right":"center"):f="center",o.attr({align:f})),c.x+=i.x,c.y+=u):c=e.call(this,n,t,o,r,i,s,a,l),c}),p(m,"getMarkPath",function(e,n,t,o,r,i,s){var a,l=this.axis;return l.isRadial?["M",n,t,"L",(a=l.getPosition(this.pos,l.center[2]/2+o)).x,a.y]:e.call(this,n,t,o,r,i,s)}),function(e){var n=e.each,t=e.noop,o=e.pick,r=e.Series,i=e.seriesType,s=e.seriesTypes;i("arearange","area",{lineWidth:1,marker:null,threshold:null,tooltip:{pointFormat:'<span style="color:{series.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},trackByArea:!0,dataLabels:{align:null,verticalAlign:null,xLow:0,xHigh:0,yLow:0,yHigh:0},states:{hover:{halo:!1}}},{pointArrayMap:["low","high"],dataLabelCollections:["dataLabel","dataLabelUpper"],toYData:function(e){return[e.low,e.high]},pointValKey:"low",deferTranslatePolar:!0,highToXY:function(e){var n=this.chart,t=this.xAxis.postTranslate(e.rectPlotX,this.yAxis.len-e.plotHigh);e.plotHighX=t.x-n.plotLeft,e.plotHigh=t.y-n.plotTop},translate:function(){var e=this,t=e.yAxis,o=!!e.modifyValue;s.area.prototype.translate.apply(e),n(e.points,function(n){var r=n.low,i=n.high,s=n.plotY;null===i||null===r?n.isNull=!0:(n.plotLow=s,n.plotHigh=t.translate(o?e.modifyValue(i,n):i,0,1,0,1),o&&(n.yBottom=n.plotHigh))}),this.chart.polar&&n(this.points,function(n){e.highToXY(n)})},getGraphPath:function(e){var n,t,r,i,a,l,c,d=[],h=[],u=s.area.prototype.getGraphPath,p=this.options,f=this.chart.polar&&!1!==p.connectEnds,m=p.connectNulls,g=p.step;for(n=(e=e||this.points).length,n=e.length;n--;)(t=e[n]).isNull||f||m||e[n+1]&&!e[n+1].isNull||h.push({plotX:t.plotX,plotY:t.plotY,doCurve:!1}),r={polarPlotY:t.polarPlotY,rectPlotX:t.rectPlotX,yBottom:t.yBottom,plotX:o(t.plotHighX,t.plotX),plotY:t.plotHigh,isNull:t.isNull},h.push(r),d.push(r),t.isNull||f||m||e[n-1]&&!e[n-1].isNull||h.push({plotX:t.plotX,plotY:t.plotY,doCurve:!1});return a=u.call(this,e),g&&(!0===g&&(g="left"),p.step={left:"right",center:"center",right:"left"}[g]),l=u.call(this,d),c=u.call(this,h),p.step=g,i=[].concat(a,l),this.chart.polar||"M"!==c[0]||(c[0]="L"),this.graphPath=i,this.areaPath=this.areaPath.concat(a,c),i.isArea=!0,i.xMap=a.xMap,this.areaPath.xMap=a.xMap,i},drawDataLabels:function(){var e,n,t,o=this.data,i=o.length,s=[],a=r.prototype,l=this.options.dataLabels,c=l.align,d=l.verticalAlign,h=l.inside,u=this.chart.inverted;if(l.enabled||this._hasPointLabels){for(e=i;e--;)(n=o[e])&&(t=h?n.plotHigh<n.plotLow:n.plotHigh>n.plotLow,n.y=n.high,n._plotY=n.plotY,n.plotY=n.plotHigh,s[e]=n.dataLabel,n.dataLabel=n.dataLabelUpper,n.below=t,u?c||(l.align=t?"right":"left"):d||(l.verticalAlign=t?"top":"bottom"),l.x=l.xHigh,l.y=l.yHigh);for(a.drawDataLabels&&a.drawDataLabels.apply(this,arguments),e=i;e--;)(n=o[e])&&(t=h?n.plotHigh<n.plotLow:n.plotHigh>n.plotLow,n.dataLabelUpper=n.dataLabel,n.dataLabel=s[e],n.y=n.low,n.plotY=n._plotY,n.below=!t,u?c||(l.align=t?"left":"right"):d||(l.verticalAlign=t?"bottom":"top"),l.x=l.xLow,l.y=l.yLow);a.drawDataLabels&&a.drawDataLabels.apply(this,arguments)}l.align=c,l.verticalAlign=d},alignDataLabel:function(){s.column.prototype.alignDataLabel.apply(this,arguments)},setStackedPoints:t,getSymbol:t,drawPoints:t})}(e),function(e){(0,e.seriesType)("areasplinerange","arearange",null,{getPointSpline:e.seriesTypes.spline.prototype.getPointSpline})}(e),function(e){var n=e.defaultPlotOptions,t=e.each,o=e.merge,r=e.noop,i=e.pick,s=e.seriesType,a=e.seriesTypes.column.prototype;s("columnrange","arearange",o(n.column,n.arearange,{lineWidth:1,pointRange:null}),{translate:function(){var e,n,o=this,r=o.yAxis,s=o.xAxis,l=s.startAngleRad,c=o.chart,d=o.xAxis.isRadial;a.translate.apply(o),t(o.points,function(t){var a,h,u,p=t.shapeArgs,f=o.options.minPointLength;t.plotHigh=n=r.translate(t.high,0,1,0,1),t.plotLow=t.plotY,u=n,h=i(t.rectPlotY,t.plotY)-n,Math.abs(h)<f?(h+=a=f-h,u-=a/2):h<0&&(u-=h*=-1),d?(e=t.barX+l,t.shapeType="path",t.shapeArgs={d:o.polarArc(u+h,u,e,e+t.pointWidth)}):(p.height=h,p.y=u,t.tooltipPos=c.inverted?[r.len+r.pos-c.plotLeft-u-h/2,s.len+s.pos-c.plotTop-p.x-p.width/2,h]:[s.left-c.plotLeft+p.x+p.width/2,r.pos-c.plotTop+u+h/2,h])})},directTouch:!0,trackerGroups:["group","dataLabelsGroup"],drawGraph:r,crispCol:a.crispCol,drawPoints:a.drawPoints,drawTracker:a.drawTracker,getColumnMetrics:a.getColumnMetrics,animate:function(){return a.animate.apply(this,arguments)},polarArc:function(){return a.polarArc.apply(this,arguments)},pointAttribs:a.pointAttribs})}(e),function(e){var n=e.each,t=e.isNumber,o=e.merge,r=e.noop,i=e.pick,s=e.pInt,a=e.Series,l=e.seriesType,c=e.TrackerMixin;l("gauge","line",{dataLabels:{enabled:!0,defer:!1,y:15,borderRadius:3,crop:!1,verticalAlign:"top",zIndex:2,borderWidth:1,borderColor:"#cccccc"},dial:{},pivot:{},tooltip:{headerFormat:""},showInLegend:!1},{angular:!0,directTouch:!0,drawGraph:r,fixedBox:!0,forceDL:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],translate:function(){var e=this.yAxis,r=this.options,a=e.center;this.generatePoints(),n(this.points,function(n){var l=o(r.dial,n.dial),c=s(i(l.radius,80))*a[2]/200,d=s(i(l.baseLength,70))*c/100,h=s(i(l.rearLength,10))*c/100,u=l.baseWidth||3,p=l.topWidth||1,f=r.overshoot,m=e.startAngleRad+e.translate(n.y,null,null,null,!0);t(f)?(f=f/180*Math.PI,m=Math.max(e.startAngleRad-f,Math.min(e.endAngleRad+f,m))):!1===r.wrap&&(m=Math.max(e.startAngleRad,Math.min(e.endAngleRad,m))),m=180*m/Math.PI,n.shapeType="path",n.shapeArgs={d:l.path||["M",-h,-u/2,"L",d,-u/2,c,-p/2,c,p/2,d,u/2,-h,u/2,"z"],translateX:a[0],translateY:a[1],rotation:m},n.plotX=a[0],n.plotY=a[1]})},drawPoints:function(){var e=this,t=e.yAxis.center,r=e.pivot,s=e.options,a=s.pivot,l=e.chart.renderer;n(e.points,function(n){var t=n.graphic,r=n.shapeArgs,i=r.d,a=o(s.dial,n.dial);t?(t.animate(r),r.d=i):(n.graphic=l[n.shapeType](r).attr({rotation:r.rotation,zIndex:1}).addClass("highcharts-dial").add(e.group),n.graphic.attr({stroke:a.borderColor||"none","stroke-width":a.borderWidth||0,fill:a.backgroundColor||"#000000"}))}),r?r.animate({translateX:t[0],translateY:t[1]}):(e.pivot=l.circle(0,0,i(a.radius,5)).attr({zIndex:2}).addClass("highcharts-pivot").translate(t[0],t[1]).add(e.group),e.pivot.attr({"stroke-width":a.borderWidth||0,stroke:a.borderColor||"#cccccc",fill:a.backgroundColor||"#000000"}))},animate:function(e){var t=this;e||(n(t.points,function(e){var n=e.graphic;n&&(n.attr({rotation:180*t.yAxis.startAngleRad/Math.PI}),n.animate({rotation:e.shapeArgs.rotation},t.options.animation))}),t.animate=null)},render:function(){this.group=this.plotGroup("group","series",this.visible?"visible":"hidden",this.options.zIndex,this.chart.seriesGroup),a.prototype.render.call(this),this.group.clip(this.chart.clipRect)},setData:function(e,n){a.prototype.setData.call(this,e,!1),this.processData(),this.generatePoints(),i(n,!0)&&this.chart.redraw()},drawTracker:c&&c.drawTrackerPoint},{setState:function(e){this.state=e}})}(e),function(e){var n=e.each,t=e.noop,o=e.pick,r=e.seriesType,i=e.seriesTypes;r("boxplot","column",{threshold:null,tooltip:{pointFormat:'<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'},whiskerLength:"50%",fillColor:"#ffffff",lineWidth:1,medianWidth:2,states:{hover:{brightness:-.3}},whiskerWidth:2},{pointArrayMap:["low","q1","median","q3","high"],toYData:function(e){return[e.low,e.q1,e.median,e.q3,e.high]},pointValKey:"high",pointAttribs:function(e){var n=this.options,t=e&&e.color||this.color;return{fill:e.fillColor||n.fillColor||t,stroke:n.lineColor||t,"stroke-width":n.lineWidth||0}},drawDataLabels:t,translate:function(){var e=this.yAxis,t=this.pointArrayMap;i.column.prototype.translate.apply(this),n(this.points,function(o){n(t,function(n){null!==o[n]&&(o[n+"Plot"]=e.translate(o[n],0,1,0,1))})})},drawPoints:function(){var e,t,r,i,s,a,l,c,d,h,u,p=this,f=p.points,m=p.options,g=p.chart.renderer,y=0,b=!1!==p.doQuartiles,x=p.options.whiskerLength;n(f,function(n){var f,v=n.graphic,j=v?"animate":"attr",w=n.shapeArgs,k={},_={},S={},C=n.color||p.color;void 0!==n.plotY&&(l=w.width,c=Math.floor(w.x),d=c+l,h=Math.round(l/2),e=Math.floor(b?n.q1Plot:n.lowPlot),t=Math.floor(b?n.q3Plot:n.lowPlot),r=Math.floor(n.highPlot),i=Math.floor(n.lowPlot),v||(n.graphic=v=g.g("point").add(p.group),n.stem=g.path().addClass("highcharts-boxplot-stem").add(v),x&&(n.whiskers=g.path().addClass("highcharts-boxplot-whisker").add(v)),b&&(n.box=g.path(void 0).addClass("highcharts-boxplot-box").add(v)),n.medianShape=g.path(void 0).addClass("highcharts-boxplot-median").add(v)),k.stroke=n.stemColor||m.stemColor||C,k["stroke-width"]=o(n.stemWidth,m.stemWidth,m.lineWidth),k.dashstyle=n.stemDashStyle||m.stemDashStyle,n.stem.attr(k),x&&(_.stroke=n.whiskerColor||m.whiskerColor||C,_["stroke-width"]=o(n.whiskerWidth,m.whiskerWidth,m.lineWidth),n.whiskers.attr(_)),b&&(f=p.pointAttribs(n),n.box.attr(f)),S.stroke=n.medianColor||m.medianColor||C,S["stroke-width"]=o(n.medianWidth,m.medianWidth,m.lineWidth),n.medianShape.attr(S),a=n.stem.strokeWidth()%2/2,y=c+h+a,n.stem[j]({d:["M",y,t,"L",y,r,"M",y,e,"L",y,i]}),b&&(a=n.box.strokeWidth()%2/2,e=Math.floor(e)+a,t=Math.floor(t)+a,c+=a,d+=a,n.box[j]({d:["M",c,t,"L",c,e,"L",d,e,"L",d,t,"L",c,t,"z"]})),x&&(a=n.whiskers.strokeWidth()%2/2,r+=a,i+=a,u=/%$/.test(x)?h*parseFloat(x)/100:x/2,n.whiskers[j]({d:["M",y-u,r,"L",y+u,r,"M",y-u,i,"L",y+u,i]})),s=Math.round(n.medianPlot),a=n.medianShape.strokeWidth()%2/2,s+=a,n.medianShape[j]({d:["M",c,s,"L",d,s]}))})},setStackedPoints:t})}(e),function(e){var n=e.each,t=e.noop,o=e.seriesType,r=e.seriesTypes;o("errorbar","boxplot",{color:"#000000",grouping:!1,linkedTo:":previous",tooltip:{pointFormat:'<span style="color:{point.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},whiskerWidth:null},{type:"errorbar",pointArrayMap:["low","high"],toYData:function(e){return[e.low,e.high]},pointValKey:"high",doQuartiles:!1,drawDataLabels:r.arearange?function(){var e=this.pointValKey;r.arearange.prototype.drawDataLabels.call(this),n(this.data,function(n){n.y=n[e]})}:t,getColumnMetrics:function(){return this.linkedParent&&this.linkedParent.columnMetrics||r.column.prototype.getColumnMetrics.call(this)}})}(e),function(e){var n=e.correctFloat,t=e.isNumber,o=e.pick,r=e.Point,i=e.Series,s=e.seriesType,a=e.seriesTypes;s("waterfall","column",{dataLabels:{inside:!0},lineWidth:1,lineColor:"#333333",dashStyle:"dot",borderColor:"#333333",states:{hover:{lineWidthPlus:0}}},{pointValKey:"y",translate:function(){var e,t,r,i,s,l,c,d,h,u,p,f,m,g=this.options,y=this.yAxis,b=o(g.minPointLength,5),x=b/2,v=g.threshold,j=g.stacking;for(a.column.prototype.translate.apply(this),h=u=v,t=0,e=(r=this.points).length;t<e;t++)i=r[t],d=this.processedYData[t],s=i.shapeArgs,l=j&&y.stacks[(this.negStacks&&d<v?"-":"")+this.stackKey],f=this.getStackIndicator(f,i.x,this.index),p=l?l[i.x].points[f.key]:[0,d],i.isSum?i.y=n(d):i.isIntermediateSum&&(i.y=n(d-u)),c=Math.max(h,h+i.y)+p[0],s.y=y.translate(c,0,1,0,1),i.isSum?(s.y=y.translate(p[1],0,1,0,1),s.height=Math.min(y.translate(p[0],0,1,0,1),y.len)-s.y):i.isIntermediateSum?(s.y=y.translate(p[1],0,1,0,1),s.height=Math.min(y.translate(u,0,1,0,1),y.len)-s.y,u=p[1]):(s.height=d>0?y.translate(h,0,1,0,1)-s.y:y.translate(h,0,1,0,1)-y.translate(h-d,0,1,0,1),h+=l&&l[i.x]?l[i.x].total:d),s.height<0&&(s.y+=s.height,s.height*=-1),i.plotY=s.y=Math.round(s.y)-this.borderWidth%2/2,s.height=Math.max(Math.round(s.height),.001),i.yBottom=s.y+s.height,s.height<=b&&!i.isNull?(s.height=b,s.y-=x,i.plotY=s.y,i.y<0?i.minPointLengthOffset=-x:i.minPointLengthOffset=x):i.minPointLengthOffset=0,m=i.plotY+(i.negative?s.height:0),this.chart.inverted?i.tooltipPos[0]=y.len-m:i.tooltipPos[1]=m},processData:function(e){var t,o,r,s,a,l,c,d=this.options,h=this.yData,u=this.options.data,p=h.length;for(r=o=s=a=d.threshold||0,c=0;c<p;c++)l=h[c],t=u&&u[c]?u[c]:{},"sum"===l||t.isSum?h[c]=n(r):"intermediateSum"===l||t.isIntermediateSum?h[c]=n(o):(r+=l,o+=l),s=Math.min(r,s),a=Math.max(r,a);i.prototype.processData.call(this,e),this.options.stacking||(this.dataMin=s,this.dataMax=a)},toYData:function(e){return e.isSum?0===e.x?null:"sum":e.isIntermediateSum?0===e.x?null:"intermediateSum":e.y},pointAttribs:function(e,n){var t,o=this.options.upColor;return o&&!e.options.color&&(e.color=e.y>0?o:null),delete(t=a.column.prototype.pointAttribs.call(this,e,n)).dashstyle,t},getGraphPath:function(){return["M",0,0]},getCrispPath:function(){var e,n,t,o,r=this.data,i=r.length,s=this.graph.strokeWidth()+this.borderWidth,a=Math.round(s)%2/2,l=this.yAxis.reversed,c=[];for(t=1;t<i;t++)n=r[t].shapeArgs,o=["M",(e=r[t-1].shapeArgs).x+e.width,e.y+r[t-1].minPointLengthOffset+a,"L",n.x,e.y+r[t-1].minPointLengthOffset+a],(r[t-1].y<0&&!l||r[t-1].y>0&&l)&&(o[2]+=e.height,o[5]+=e.height),c=c.concat(o);return c},drawGraph:function(){i.prototype.drawGraph.call(this),this.graph.attr({d:this.getCrispPath()})},setStackedPoints:function(){var e,n,t=this.options;for(i.prototype.setStackedPoints.apply(this,arguments),e=this.stackedYData?this.stackedYData.length:0,n=1;n<e;n++)t.data[n].isSum||t.data[n].isIntermediateSum||(this.stackedYData[n]+=this.stackedYData[n-1])},getExtremes:function(){if(this.options.stacking)return i.prototype.getExtremes.apply(this,arguments)}},{getClassName:function(){var e=r.prototype.getClassName.call(this);return this.isSum?e+=" highcharts-sum":this.isIntermediateSum&&(e+=" highcharts-intermediate-sum"),e},isValid:function(){return t(this.y,!0)||this.isSum||this.isIntermediateSum}})}(e),function(e){var n=e.LegendSymbolMixin,t=e.noop,o=e.Series,r=e.seriesType,i=e.seriesTypes;r("polygon","scatter",{marker:{enabled:!1,states:{hover:{enabled:!1}}},stickyTracking:!1,tooltip:{followPointer:!0,pointFormat:""},trackByArea:!0},{type:"polygon",getGraphPath:function(){for(var e=o.prototype.getGraphPath.call(this),n=e.length+1;n--;)(n===e.length||"M"===e[n])&&n>0&&e.splice(n,0,"z");return this.areaPath=e,e},drawGraph:function(){this.options.fillColor=this.color,i.area.prototype.drawGraph.call(this)},drawLegendSymbol:n.drawRectangle,drawTracker:o.prototype.drawTracker,setStackedPoints:t})}(e),function(e){var n=e.arrayMax,t=e.arrayMin,o=e.Axis,r=e.color,i=e.each,s=e.isNumber,a=e.noop,l=e.pick,c=e.pInt,d=e.Point,h=e.Series,u=e.seriesType,p=e.seriesTypes;u("bubble","scatter",{dataLabels:{formatter:function(){return this.point.z},inside:!0,verticalAlign:"middle"},marker:{lineColor:null,lineWidth:1,radius:null,states:{hover:{radiusPlus:0}},symbol:"circle"},minSize:8,maxSize:"20%",softThreshold:!1,states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0,zoneAxis:"z"},{pointArrayMap:["y","z"],parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],specialGroup:"group",bubblePadding:!0,zoneAxis:"z",directTouch:!0,pointAttribs:function(e,n){var t=this.options.marker,o=l(t.fillOpacity,.5),i=h.prototype.pointAttribs.call(this,e,n);return 1!==o&&(i.fill=r(i.fill).setOpacity(o).get("rgba")),i},getRadii:function(e,n,t,o){var r,i,s,a,l,c=this.zData,d=[],h=this.options,u="width"!==h.sizeBy,p=h.zThreshold,f=n-e;for(i=0,r=c.length;i<r;i++)a=c[i],h.sizeByAbsoluteValue&&null!==a&&(a=Math.abs(a-p),n=Math.max(n-p,Math.abs(e-p)),e=0),null===a?l=null:a<e?l=t/2-1:(s=f>0?(a-e)/f:.5,u&&s>=0&&(s=Math.sqrt(s)),l=Math.ceil(t+s*(o-t))/2),d.push(l);this.radii=d},animate:function(e){var n=this.options.animation;e||(i(this.points,function(e){var t,o=e.graphic;o&&o.width&&(t={x:o.x,y:o.y,width:o.width,height:o.height},o.attr({x:e.plotX,y:e.plotY,width:1,height:1}),o.animate(t,n))}),this.animate=null)},translate:function(){var n,t,o,r=this.data,i=this.radii;for(p.scatter.prototype.translate.call(this),n=r.length;n--;)t=r[n],o=i?i[n]:0,s(o)&&o>=this.minPxSize/2?(t.marker=e.extend(t.marker,{radius:o,width:2*o,height:2*o}),t.dlBox={x:t.plotX-o,y:t.plotY-o,width:2*o,height:2*o}):t.shapeArgs=t.plotY=t.dlBox=void 0},alignDataLabel:p.column.prototype.alignDataLabel,buildKDTree:a,applyZones:a},{haloPath:function(e){return d.prototype.haloPath.call(this,0===e?0:(this.marker&&this.marker.radius||0)+e)},ttBelow:!1}),o.prototype.beforePadding=function(){var e=this,o=this.len,r=this.chart,a=0,d=o,h=this.isXAxis,u=h?"xData":"yData",p=this.min,f={},m=Math.min(r.plotWidth,r.plotHeight),g=Number.MAX_VALUE,y=-Number.MAX_VALUE,b=this.max-p,x=o/b,v=[];i(this.series,function(o){var s,a=o.options;!o.bubblePadding||!o.visible&&r.options.chart.ignoreHiddenSeries||(e.allowZoomOutside=!0,v.push(o),h&&(i(["minSize","maxSize"],function(e){var n=a[e],t=/%$/.test(n);n=c(n),f[e]=t?m*n/100:n}),o.minPxSize=f.minSize,o.maxPxSize=Math.max(f.maxSize,f.minSize),(s=o.zData).length&&(g=l(a.zMin,Math.min(g,Math.max(t(s),!1===a.displayNegative?a.zThreshold:-Number.MAX_VALUE))),y=l(a.zMax,Math.max(y,n(s))))))}),i(v,function(n){var t,o=n[u],r=o.length;if(h&&n.getRadii(g,y,n.minPxSize,n.maxPxSize),b>0)for(;r--;)s(o[r])&&e.dataMin<=o[r]&&o[r]<=e.dataMax&&(t=n.radii[r],a=Math.min((o[r]-p)*x-t,a),d=Math.max((o[r]-p)*x+t,d))}),v.length&&b>0&&!this.isLog&&(x*=(o+a-(d-=o))/o,i([["min","userMin",a],["max","userMax",d]],function(n){void 0===l(e.options[n[0]],e[n[1]])&&(e[n[0]]+=n[2]/x)}))}}(e),function(e){var n,t=e.each,o=e.pick,r=e.Pointer,i=e.Series,s=e.seriesTypes,a=e.wrap,l=i.prototype,c=r.prototype;function d(e,n){var t,o=this.chart,r=this.options.animation,i=this.group,s=this.markerGroup,a=this.xAxis.center,l=o.plotLeft,c=o.plotTop;o.polar?o.renderer.isSVG&&(!0===r&&(r={}),n?(t={translateX:a[0]+l,translateY:a[1]+c,scaleX:.001,scaleY:.001},i.attr(t),s&&s.attr(t)):(t={translateX:l,translateY:c,scaleX:1,scaleY:1},i.animate(t,r),s&&s.animate(t,r),this.animate=null)):e.call(this,n)}l.searchPointByAngle=function(e){var n=this.chart,t=this.xAxis.pane.center,o=e.chartX-t[0]-n.plotLeft,r=e.chartY-t[1]-n.plotTop;return this.searchKDTree({clientX:180+Math.atan2(o,r)*(-180/Math.PI)})},l.getConnectors=function(e,n,t,o){var r,i,s,a,l,c,d,h,u,p,f,m,g,y,b,x,v,j,w,k,_,S=o?1:0;return i=(r=n>=0&&n<=e.length-1?n:n<0?e.length-1+n:0)-1<0?e.length-(1+S):r-1,s=r+1>e.length-1?S:r+1,a=e[i],l=e[s],c=a.plotX,d=a.plotY,h=l.plotX,u=l.plotY,g=(1.5*(p=e[r].plotX)+c)/2.5,y=(1.5*(f=e[r].plotY)+d)/2.5,b=(1.5*p+h)/2.5,x=(1.5*f+u)/2.5,v=Math.sqrt(Math.pow(g-p,2)+Math.pow(y-f,2)),j=Math.sqrt(Math.pow(b-p,2)+Math.pow(x-f,2)),w=Math.atan2(y-f,g-p),k=Math.atan2(x-f,b-p),_=Math.PI/2+(w+k)/2,Math.abs(w-_)>Math.PI/2&&(_-=Math.PI),g=p+Math.cos(_)*v,y=f+Math.sin(_)*v,m={rightContX:b=p+Math.cos(Math.PI+_)*j,rightContY:x=f+Math.sin(Math.PI+_)*j,leftContX:g,leftContY:y,plotX:p,plotY:f},t&&(m.prevPointCont=this.getConnectors(e,i,!1,o)),m},a(l,"buildKDTree",function(e){this.chart.polar&&(this.kdByAngle?this.searchPoint=this.searchPointByAngle:this.options.findNearestPointBy="xy"),e.apply(this)}),l.toXY=function(e){var n,t,o=this.chart,r=e.plotX,i=e.plotY;e.rectPlotX=r,e.rectPlotY=i,n=this.xAxis.postTranslate(e.plotX,this.yAxis.len-i),e.plotX=e.polarPlotX=n.x-o.plotLeft,e.plotY=e.polarPlotY=n.y-o.plotTop,this.kdByAngle?((t=(r/Math.PI*180+this.xAxis.pane.options.startAngle)%360)<0&&(t+=360),e.clientX=t):e.clientX=e.plotX},s.spline&&(a(s.spline.prototype,"getPointSpline",function(e,n,t,o){var r;return this.chart.polar?o?["C",(r=this.getConnectors(n,o,!0,this.connectEnds)).prevPointCont.rightContX,r.prevPointCont.rightContY,r.leftContX,r.leftContY,r.plotX,r.plotY]:["M",t.plotX,t.plotY]:e.call(this,n,t,o)}),s.areasplinerange&&(s.areasplinerange.prototype.getPointSpline=s.spline.prototype.getPointSpline)),a(l,"translate",function(e){var n,t,o=this.chart;if(e.call(this),o.polar&&(this.kdByAngle=o.tooltip&&o.tooltip.shared,!this.preventPostTranslate))for(t=(n=this.points).length;t--;)this.toXY(n[t])}),a(l,"getGraphPath",function(e,n){var o,r,i,s=this;if(this.chart.polar){for(n=n||this.points,o=0;o<n.length;o++)if(!n[o].isNull){r=o;break}!1!==this.options.connectEnds&&void 0!==r&&(this.connectEnds=!0,n.splice(n.length,0,n[r]),i=!0),t(n,function(e){void 0===e.polarPlotY&&s.toXY(e)})}var a=e.apply(this,[].slice.call(arguments,1));return i&&n.pop(),a}),a(l,"animate",d),s.column&&((n=s.column.prototype).polarArc=function(e,n,t,r){var i=this.xAxis.center,s=this.yAxis.len;return this.chart.renderer.symbols.arc(i[0],i[1],s-n,null,{start:t,end:r,innerR:s-o(e,s)})},a(n,"animate",d),a(n,"translate",function(e){var n,t,o,r,i=this.xAxis,s=i.startAngleRad;if(this.preventPostTranslate=!0,e.call(this),i.isRadial)for(r=(t=this.points).length;r--;)n=(o=t[r]).barX+s,o.shapeType="path",o.shapeArgs={d:this.polarArc(o.yBottom,o.plotY,n,n+o.pointWidth)},this.toXY(o),o.tooltipPos=[o.plotX,o.plotY],o.ttBelow=o.plotY>i.center[1]}),a(n,"alignDataLabel",function(e,n,t,o,r,i){if(this.chart.polar){var s,a,c=n.rectPlotX/Math.PI*180;null===o.align&&(s=c>20&&c<160?"left":c>200&&c<340?"right":"center",o.align=s),null===o.verticalAlign&&(a=c<45||c>315?"bottom":c>135&&c<225?"top":"middle",o.verticalAlign=a),l.alignDataLabel.call(this,n,t,o,r,i)}else e.call(this,n,t,o,r,i)})),a(c,"getCoordinates",function(e,n){var o=this.chart,r={xAxis:[],yAxis:[]};return o.polar?t(o.axes,function(e){var t=e.isXAxis,i=e.center,s=n.chartX-i[0]-o.plotLeft,a=n.chartY-i[1]-o.plotTop;r[t?"xAxis":"yAxis"].push({axis:e,value:e.translate(t?Math.PI-Math.atan2(s,a):Math.sqrt(Math.pow(s,2)+Math.pow(a,2)),!0)})}):r=e.call(this,n),r}),a(e.Chart.prototype,"getAxes",function(n){this.pane||(this.pane=[]),t(e.splat(this.options.pane),function(n){new e.Pane(n,this)},this),n.call(this)}),a(e.Chart.prototype,"drawChartBox",function(e){e.call(this),t(this.pane,function(e){e.render()})}),a(e.Chart.prototype,"get",function(n,t){return e.find(this.pane,function(e){return e.options.id===t})||n.call(this,t)})}(e)},"object"==typeof e&&e.exports?e.exports=o:o(Highcharts)}])},"./node_modules/@splunk/highcharts/highcharts.js":function(e,n){e.exports=function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=t(1),i=(o=r)&&o.__esModule?o:{default:o};var s=function(){return new Function("\n        return (function() {\n            var module = {\n                exports: true\n            };\n            "+i.default+";\n            return module.exports;\n        })();\n    ")()},a=s();a.noConflict=function(){return s()},n.default=a,e.exports=n.default},function(e,n){e.exports="/**\n * @license Highcharts JS v5.0.12 (2017-05-24)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = root.document ?\n            factory(root) :\n            factory;\n    } else {\n        root.Highcharts = factory(root);\n    }\n}(typeof window !== 'undefined' ? window : this, function(win) {\n    var Highcharts = (function() {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /* global window */\n        var win = window,\n            doc = win.document;\n\n        var SVG_NS = 'http://www.w3.org/2000/svg',\n            userAgent = (win.navigator && win.navigator.userAgent) || '',\n            svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n            isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,\n            vml = !svg,\n            isFirefox = /Firefox/.test(userAgent),\n            hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38\n\n        var Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {\n            product: 'Highcharts',\n            version: '5.0.12',\n            deg2rad: Math.PI * 2 / 360,\n            doc: doc,\n            hasBidiBug: hasBidiBug,\n            hasTouch: doc && doc.documentElement.ontouchstart !== undefined,\n            isMS: isMS,\n            isWebKit: /AppleWebKit/.test(userAgent),\n            isFirefox: isFirefox,\n            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n            SVG_NS: SVG_NS,\n            chartCount: 0,\n            seriesTypes: {},\n            symbolSizes: {},\n            svg: svg,\n            vml: vml,\n            win: win,\n            marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n            noop: function() {\n                return undefined;\n            },\n            /**\n             * An array containing the current chart objects in the page. A chart's\n             * position in the array is preserved throughout the page's lifetime. When\n             * a chart is destroyed, the array item becomes `undefined`.\n             * @type {Array.<Highcharts.Chart>}\n             * @memberOf Highcharts\n             */\n            charts: []\n        };\n        return Highcharts;\n    }());\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /* eslint max-len: [\"warn\", 80, 4] */\n\n        /**\n         * The Highcharts object is the placeholder for all other members, and various\n         * utility functions. The most important member of the namespace would be the\n         * chart constructor.\n         *\n         * @example\n         * var chart = Highcharts.chart('container', { ... });\n         * \n         * @namespace Highcharts\n         */\n\n        var timers = [];\n\n        var charts = H.charts,\n            doc = H.doc,\n            win = H.win;\n\n        /**\n         * Provide error messages for debugging, with links to online explanation. This\n         * function can be overridden to provide custom error handling.\n         *\n         * @function #error\n         * @memberOf Highcharts\n         * @param {Number|String} code - The error code. See [errors.xml]{@link \n         *     https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}\n         *     for available codes. If it is a string, the error message is printed\n         *     directly in the console.\n         * @param {Boolean} [stop=false] - Whether to throw an error or just log a \n         *     warning in the console.\n         *\n         * @sample highcharts/chart/highcharts-error/ Custom error handler\n         */\n        H.error = function(code, stop) {\n            var msg = H.isNumber(code) ?\n                'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :\n                code;\n            if (stop) {\n                throw new Error(msg);\n            }\n            // else ...\n            if (win.console) {\n                console.log(msg); // eslint-disable-line no-console\n            }\n        };\n\n        /**\n         * An animator object used internally. One instance applies to one property\n         * (attribute or style prop) on one element. Animation is always initiated\n         * through {@link SVGElement#animate}.\n         *\n         * @constructor Fx\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement|SVGElement} elem - The element to animate.\n         * @param {AnimationOptions} options - Animation options.\n         * @param {string} prop - The single attribute or CSS property to animate.\n         * @private\n         *\n         * @example\n         * var rect = renderer.rect(0, 0, 10, 10).add();\n         * rect.animate({ width: 100 });\n         */\n        H.Fx = function(elem, options, prop) {\n            this.options = options;\n            this.elem = elem;\n            this.prop = prop;\n        };\n        H.Fx.prototype = {\n\n            /**\n             * Set the current step of a path definition on SVGElement.\n             *\n             * @function #dSetter\n             * @memberOf Highcharts.Fx\n             */\n            dSetter: function() {\n                var start = this.paths[0],\n                    end = this.paths[1],\n                    ret = [],\n                    now = this.now,\n                    i = start.length,\n                    startVal;\n\n                // Land on the final path without adjustment points appended in the ends\n                if (now === 1) {\n                    ret = this.toD;\n\n                } else if (i === end.length && now < 1) {\n                    while (i--) {\n                        startVal = parseFloat(start[i]);\n                        ret[i] =\n                            isNaN(startVal) ? // a letter instruction like M or L\n                            start[i] :\n                            now * (parseFloat(end[i] - startVal)) + startVal;\n\n                    }\n                    // If animation is finished or length not matching, land on right value\n                } else {\n                    ret = end;\n                }\n                this.elem.attr('d', ret, null, true);\n            },\n\n            /**\n             * Update the element with the current animation step.\n             *\n             * @function #update\n             * @memberOf Highcharts.Fx\n             */\n            update: function() {\n                var elem = this.elem,\n                    prop = this.prop, // if destroyed, it is null\n                    now = this.now,\n                    step = this.options.step;\n\n                // Animation setter defined from outside\n                if (this[prop + 'Setter']) {\n                    this[prop + 'Setter']();\n\n                    // Other animations on SVGElement\n                } else if (elem.attr) {\n                    if (elem.element) {\n                        elem.attr(prop, now, null, true);\n                    }\n\n                    // HTML styles, raw HTML content like container size\n                } else {\n                    elem.style[prop] = now + this.unit;\n                }\n\n                if (step) {\n                    step.call(elem, now, this);\n                }\n\n            },\n\n            /**\n             * Run an animation.\n             *\n             * @function #run\n             * @memberOf Highcharts.Fx\n             * @param {Number} from - The current value, value to start from.\n             * @param {Number} to - The end value, value to land on.\n             * @param {String} [unit] - The property unit, for example `px`.\n             * @returns {void}\n             */\n            run: function(from, to, unit) {\n                var self = this,\n                    timer = function(gotoEnd) {\n                        return timer.stopped ? false : self.step(gotoEnd);\n                    },\n                    i;\n\n                this.startTime = +new Date();\n                this.start = from;\n                this.end = to;\n                this.unit = unit;\n                this.now = this.start;\n                this.pos = 0;\n\n                timer.elem = this.elem;\n                timer.prop = this.prop;\n\n                if (timer() && timers.push(timer) === 1) {\n                    timer.timerId = setInterval(function() {\n\n                        for (i = 0; i < timers.length; i++) {\n                            if (!timers[i]()) {\n                                timers.splice(i--, 1);\n                            }\n                        }\n\n                        if (!timers.length) {\n                            clearInterval(timer.timerId);\n                        }\n                    }, 13);\n                }\n            },\n\n            /**\n             * Run a single step in the animation.\n             *\n             * @function #step\n             * @memberOf Highcharts.Fx\n             * @param   {Boolean} [gotoEnd] - Whether to go to the endpoint of the\n             *     animation after abort.\n             * @returns {Boolean} Returns `true` if animation continues.\n             */\n            step: function(gotoEnd) {\n                var t = +new Date(),\n                    ret,\n                    done,\n                    options = this.options,\n                    elem = this.elem,\n                    complete = options.complete,\n                    duration = options.duration,\n                    curAnim = options.curAnim;\n\n                if (elem.attr && !elem.element) { // #2616, element is destroyed\n                    ret = false;\n\n                } else if (gotoEnd || t >= duration + this.startTime) {\n                    this.now = this.end;\n                    this.pos = 1;\n                    this.update();\n\n                    curAnim[this.prop] = true;\n\n                    done = true;\n\n                    H.objectEach(curAnim, function(val) {\n                        if (val !== true) {\n                            done = false;\n                        }\n                    });\n\n                    if (done && complete) {\n                        complete.call(elem);\n                    }\n                    ret = false;\n\n                } else {\n                    this.pos = options.easing((t - this.startTime) / duration);\n                    this.now = this.start + ((this.end - this.start) * this.pos);\n                    this.update();\n                    ret = true;\n                }\n                return ret;\n            },\n\n            /**\n             * Prepare start and end values so that the path can be animated one to one.\n             *\n             * @function #initPath\n             * @memberOf Highcharts.Fx\n             * @param {SVGElement} elem - The SVGElement item.\n             * @param {String} fromD - Starting path definition.\n             * @param {Array} toD - Ending path definition.\n             * @returns {Array} An array containing start and end paths in array form\n             * so that they can be animated in parallel.\n             */\n            initPath: function(elem, fromD, toD) {\n                fromD = fromD || '';\n                var shift,\n                    startX = elem.startX,\n                    endX = elem.endX,\n                    bezier = fromD.indexOf('C') > -1,\n                    numParams = bezier ? 7 : 3,\n                    fullLength,\n                    slice,\n                    i,\n                    start = fromD.split(' '),\n                    end = toD.slice(), // copy\n                    isArea = elem.isArea,\n                    positionFactor = isArea ? 2 : 1,\n                    reverse;\n\n                /**\n                 * In splines make moveTo and lineTo points have six parameters like\n                 * bezier curves, to allow animation one-to-one.\n                 */\n                function sixify(arr) {\n                    var isOperator,\n                        nextIsOperator;\n                    i = arr.length;\n                    while (i--) {\n\n                        // Fill in dummy coordinates only if the next operator comes\n                        // three places behind (#5788)\n                        isOperator = arr[i] === 'M' || arr[i] === 'L';\n                        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);\n                        if (isOperator && nextIsOperator) {\n                            arr.splice(\n                                i + 1, 0,\n                                arr[i + 1], arr[i + 2],\n                                arr[i + 1], arr[i + 2]\n                            );\n                        }\n                    }\n                }\n\n                /**\n                 * Insert an array at the given position of another array\n                 */\n                function insertSlice(arr, subArr, index) {\n                    [].splice.apply(\n                        arr, [index, 0].concat(subArr)\n                    );\n                }\n\n                /**\n                 * If shifting points, prepend a dummy point to the end path. \n                 */\n                function prepend(arr, other) {\n                    while (arr.length < fullLength) {\n\n                        // Move to, line to or curve to?\n                        arr[0] = other[fullLength - arr.length];\n\n                        // Prepend a copy of the first point\n                        insertSlice(arr, arr.slice(0, numParams), 0);\n\n                        // For areas, the bottom path goes back again to the left, so we\n                        // need to append a copy of the last point.\n                        if (isArea) {\n                            insertSlice(\n                                arr,\n                                arr.slice(arr.length - numParams), arr.length\n                            );\n                            i--;\n                        }\n                    }\n                    arr[0] = 'M';\n                }\n\n                /**\n                 * Copy and append last point until the length matches the end length\n                 */\n                function append(arr, other) {\n                    var i = (fullLength - arr.length) / numParams;\n                    while (i > 0 && i--) {\n\n                        // Pull out the slice that is going to be appended or inserted.\n                        // In a line graph, the positionFactor is 1, and the last point\n                        // is sliced out. In an area graph, the positionFactor is 2,\n                        // causing the middle two points to be sliced out, since an area\n                        // path starts at left, follows the upper path then turns and\n                        // follows the bottom back. \n                        slice = arr.slice().splice(\n                            (arr.length / positionFactor) - numParams,\n                            numParams * positionFactor\n                        );\n\n                        // Move to, line to or curve to?\n                        slice[0] = other[fullLength - numParams - (i * numParams)];\n\n                        // Disable first control point\n                        if (bezier) {\n                            slice[numParams - 6] = slice[numParams - 2];\n                            slice[numParams - 5] = slice[numParams - 1];\n                        }\n\n                        // Now insert the slice, either in the middle (for areas) or at\n                        // the end (for lines)\n                        insertSlice(arr, slice, arr.length / positionFactor);\n\n                        if (isArea) {\n                            i--;\n                        }\n                    }\n                }\n\n                if (bezier) {\n                    sixify(start);\n                    sixify(end);\n                }\n\n                // For sideways animation, find out how much we need to shift to get the\n                // start path Xs to match the end path Xs.\n                if (startX && endX) {\n                    for (i = 0; i < startX.length; i++) {\n                        // Moving left, new points coming in on right\n                        if (startX[i] === endX[0]) {\n                            shift = i;\n                            break;\n                            // Moving right\n                        } else if (startX[0] ===\n                            endX[endX.length - startX.length + i]) {\n                            shift = i;\n                            reverse = true;\n                            break;\n                        }\n                    }\n                    if (shift === undefined) {\n                        start = [];\n                    }\n                }\n\n                if (start.length && H.isNumber(shift)) {\n\n                    // The common target length for the start and end array, where both \n                    // arrays are padded in opposite ends\n                    fullLength = end.length + shift * positionFactor * numParams;\n\n                    if (!reverse) {\n                        prepend(end, start);\n                        append(start, end);\n                    } else {\n                        prepend(start, end);\n                        append(end, start);\n                    }\n                }\n\n                return [start, end];\n            }\n        }; // End of Fx prototype\n\n        /**\n         * Handle animation of the color attributes directly.\n         */\n        H.Fx.prototype.fillSetter =\n            H.Fx.prototype.strokeSetter = function() {\n                this.elem.attr(\n                    this.prop,\n                    H.color(this.start).tweenTo(H.color(this.end), this.pos),\n                    null,\n                    true\n                );\n            };\n\n\n        /**\n         * Utility function to extend an object with the members of another.\n         *\n         * @function #extend\n         * @memberOf Highcharts\n         * @param {Object} a - The object to be extended.\n         * @param {Object} b - The object to add to the first one.\n         * @returns {Object} Object a, the original object.\n         */\n        H.extend = function(a, b) {\n            var n;\n            if (!a) {\n                a = {};\n            }\n            for (n in b) {\n                a[n] = b[n];\n            }\n            return a;\n        };\n\n        /**\n         * Utility function to deep merge two or more objects and return a third object.\n         * If the first argument is true, the contents of the second object is copied\n         * into the first object. The merge function can also be used with a single \n         * object argument to create a deep copy of an object.\n         *\n         * @function #merge\n         * @memberOf Highcharts\n         * @param {Boolean} [extend] - Whether to extend the left-side object (a) or\n                  return a whole new object.\n         * @param {Object} a - The first object to extend. When only this is given, the\n                  function returns a deep copy.\n         * @param {...Object} [n] - An object to merge into the previous one.\n         * @returns {Object} - The merged object. If the first argument is true, the \n         * return is the same as the second argument.\n         */\n        H.merge = function() {\n            var i,\n                args = arguments,\n                len,\n                ret = {},\n                doCopy = function(copy, original) {\n                    // An object is replacing a primitive\n                    if (typeof copy !== 'object') {\n                        copy = {};\n                    }\n\n                    H.objectEach(original, function(value, key) {\n\n                        // Copy the contents of objects, but not arrays or DOM nodes\n                        if (\n                            H.isObject(value, true) &&\n                            !H.isClass(value) &&\n                            !H.isDOMElement(value)\n                        ) {\n                            copy[key] = doCopy(copy[key] || {}, value);\n\n                            // Primitives and arrays are copied over directly\n                        } else {\n                            copy[key] = original[key];\n                        }\n                    });\n                    return copy;\n                };\n\n            // If first argument is true, copy into the existing object. Used in\n            // setOptions.\n            if (args[0] === true) {\n                ret = args[1];\n                args = Array.prototype.slice.call(args, 2);\n            }\n\n            // For each argument, extend the return\n            len = args.length;\n            for (i = 0; i < len; i++) {\n                ret = doCopy(ret, args[i]);\n            }\n\n            return ret;\n        };\n\n        /**\n         * Shortcut for parseInt\n         * @ignore\n         * @param {Object} s\n         * @param {Number} mag Magnitude\n         */\n        H.pInt = function(s, mag) {\n            return parseInt(s, mag || 10);\n        };\n\n        /**\n         * Utility function to check for string type.\n         *\n         * @function #isString\n         * @memberOf Highcharts\n         * @param {Object} s - The item to check.\n         * @returns {Boolean} - True if the argument is a string.\n         */\n        H.isString = function(s) {\n            return typeof s === 'string';\n        };\n\n        /**\n         * Utility function to check if an item is an array.\n         *\n         * @function #isArray\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is an array.\n         */\n        H.isArray = function(obj) {\n            var str = Object.prototype.toString.call(obj);\n            return str === '[object Array]' || str === '[object Array Iterator]';\n        };\n\n        /**\n         * Utility function to check if an item is of type object.\n         *\n         * @function #isObject\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @param {Boolean} [strict=false] - Also checks that the object is not an\n         *    array.\n         * @returns {Boolean} - True if the argument is an object.\n         */\n        H.isObject = function(obj, strict) {\n            return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));\n        };\n\n        /**\n         * Utility function to check if an Object is a HTML Element.\n         *\n         * @function #isDOMElement\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is a HTML Element.\n         */\n        H.isDOMElement = function(obj) {\n            return H.isObject(obj) && typeof obj.nodeType === 'number';\n        };\n\n        /**\n         * Utility function to check if an Object is an class.\n         *\n         * @function #isClass\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is an class.\n         */\n        H.isClass = function(obj) {\n            var c = obj && obj.constructor;\n            return !!(\n                H.isObject(obj, true) &&\n                !H.isDOMElement(obj) &&\n                (c && c.name && c.name !== 'Object')\n            );\n        };\n\n        /**\n         * Utility function to check if an item is of type number.\n         *\n         * @function #isNumber\n         * @memberOf Highcharts\n         * @param {Object} n - The item to check.\n         * @returns {Boolean} - True if the item is a number and is not NaN.\n         */\n        H.isNumber = function(n) {\n            return typeof n === 'number' && !isNaN(n);\n        };\n\n        /**\n         * Remove the last occurence of an item from an array.\n         *\n         * @function #erase\n         * @memberOf Highcharts\n         * @param {Array} arr - The array.\n         * @param {*} item - The item to remove.\n         */\n        H.erase = function(arr, item) {\n            var i = arr.length;\n            while (i--) {\n                if (arr[i] === item) {\n                    arr.splice(i, 1);\n                    break;\n                }\n            }\n        };\n\n        /**\n         * Check if an object is null or undefined.\n         *\n         * @function #defined\n         * @memberOf Highcharts\n         * @param {Object} obj - The object to check.\n         * @returns {Boolean} - False if the object is null or undefined, otherwise\n         *        true.\n         */\n        H.defined = function(obj) {\n            return obj !== undefined && obj !== null;\n        };\n\n        /**\n         * Set or get an attribute or an object of attributes. To use as a setter, pass\n         * a key and a value, or let the second argument be a collection of keys and\n         * values. To use as a getter, pass only a string as the second argument.\n         *\n         * @function #attr\n         * @memberOf Highcharts\n         * @param {Object} elem - The DOM element to receive the attribute(s).\n         * @param {String|Object} [prop] - The property or an object of key-value pairs.\n         * @param {String} [value] - The value if a single property is set.\n         * @returns {*} When used as a getter, return the value.\n         */\n        H.attr = function(elem, prop, value) {\n            var ret;\n\n            // if the prop is a string\n            if (H.isString(prop)) {\n                // set the value\n                if (H.defined(value)) {\n                    elem.setAttribute(prop, value);\n\n                    // get the value\n                } else if (elem && elem.getAttribute) {\n                    ret = elem.getAttribute(prop);\n                }\n\n                // else if prop is defined, it is a hash of key/value pairs\n            } else if (H.defined(prop) && H.isObject(prop)) {\n                H.objectEach(prop, function(val, key) {\n                    elem.setAttribute(key, val);\n                });\n            }\n            return ret;\n        };\n\n        /**\n         * Check if an element is an array, and if not, make it into an array.\n         *\n         * @function #splat\n         * @memberOf Highcharts\n         * @param obj {*} - The object to splat.\n         * @returns {Array} The produced or original array.\n         */\n        H.splat = function(obj) {\n            return H.isArray(obj) ? obj : [obj];\n        };\n\n        /**\n         * Set a timeout if the delay is given, otherwise perform the function\n         * synchronously.\n         *\n         * @function #syncTimeout\n         * @memberOf Highcharts\n         * @param   {Function} fn - The function callback.\n         * @param   {Number}   delay - Delay in milliseconds.\n         * @param   {Object}   [context] - The context.\n         * @returns {Number} An identifier for the timeout that can later be cleared\n         * with clearTimeout.\n         */\n        H.syncTimeout = function(fn, delay, context) {\n            if (delay) {\n                return setTimeout(fn, delay, context);\n            }\n            fn.call(0, context);\n        };\n\n\n        /**\n         * Return the first value that is not null or undefined.\n         *\n         * @function #pick\n         * @memberOf Highcharts\n         * @param {...*} items - Variable number of arguments to inspect.\n         * @returns {*} The value of the first argument that is not null or undefined.\n         */\n        H.pick = function() {\n            var args = arguments,\n                i,\n                arg,\n                length = args.length;\n            for (i = 0; i < length; i++) {\n                arg = args[i];\n                if (arg !== undefined && arg !== null) {\n                    return arg;\n                }\n            }\n        };\n\n        /**\n         * @typedef {Object} CSSObject - A style object with camel case property names.\n         * The properties can be whatever styles are supported on the given SVG or HTML\n         * element.\n         * @example\n         * {\n         *    fontFamily: 'monospace',\n         *    fontSize: '1.2em'\n         * }\n         */\n        /**\n         * Set CSS on a given element.\n         *\n         * @function #css\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - A HTML DOM element.\n         * @param {CSSObject} styles - Style object with camel case property names.\n         * @returns {void}\n         */\n        H.css = function(el, styles) {\n            if (H.isMS && !H.svg) { // #2686\n                if (styles && styles.opacity !== undefined) {\n                    styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n                }\n            }\n            H.extend(el.style, styles);\n        };\n\n        /**\n         * A HTML DOM element.\n         * @typedef {Object} HTMLDOMElement\n         */\n\n        /**\n         * Utility function to create an HTML element with attributes and styles.\n         *\n         * @function #createElement\n         * @memberOf Highcharts\n         * @param {String} tag - The HTML tag.\n         * @param {Object} [attribs] - Attributes as an object of key-value pairs.\n         * @param {CSSObject} [styles] - Styles as an object of key-value pairs.\n         * @param {Object} [parent] - The parent HTML object.\n         * @param {Boolean} [nopad=false] - If true, remove all padding, border and\n         *    margin.\n         * @returns {HTMLDOMElement} The created DOM element.\n         */\n        H.createElement = function(tag, attribs, styles, parent, nopad) {\n            var el = doc.createElement(tag),\n                css = H.css;\n            if (attribs) {\n                H.extend(el, attribs);\n            }\n            if (nopad) {\n                css(el, {\n                    padding: 0,\n                    border: 'none',\n                    margin: 0\n                });\n            }\n            if (styles) {\n                css(el, styles);\n            }\n            if (parent) {\n                parent.appendChild(el);\n            }\n            return el;\n        };\n\n        /**\n         * Extend a prototyped class by new members.\n         *\n         * @function #extendClass\n         * @memberOf Highcharts\n         * @param {Object} parent - The parent prototype to inherit.\n         * @param {Object} members - A collection of prototype members to add or\n         *        override compared to the parent prototype.\n         * @returns {Object} A new prototype.\n         */\n        H.extendClass = function(parent, members) {\n            var object = function() {};\n            object.prototype = new parent(); // eslint-disable-line new-cap\n            H.extend(object.prototype, members);\n            return object;\n        };\n\n        /**\n         * Left-pad a string to a given length by adding a character repetetively.\n         *\n         * @function #pad\n         * @memberOf Highcharts\n         * @param {Number} number - The input string or number.\n         * @param {Number} length - The desired string length.\n         * @param {String} [padder=0] - The character to pad with.\n         * @returns {String} The padded string.\n         */\n        H.pad = function(number, length, padder) {\n            return new Array((length || 2) + 1 -\n                String(number).length).join(padder || 0) + number;\n        };\n\n        /**\n         * @typedef {Number|String} RelativeSize - If a number is given, it defines the\n         *    pixel length. If a percentage string is given, like for example `'50%'`,\n         *    the setting defines a length relative to a base size, for example the size\n         *    of a container.\n         */\n        /**\n         * Return a length based on either the integer value, or a percentage of a base.\n         *\n         * @function #relativeLength\n         * @memberOf Highcharts\n         * @param {RelativeSize} value - A percentage string or a number.\n         * @param {Number} base - The full length that represents 100%.\n         * @returns {Number} The computed length.\n         */\n        H.relativeLength = function(value, base) {\n            return (/%$/).test(value) ?\n                base * parseFloat(value) / 100 :\n                parseFloat(value);\n        };\n\n        /**\n         * Wrap a method with extended functionality, preserving the original function.\n         *\n         * @function #wrap\n         * @memberOf Highcharts\n         * @param {Object} obj - The context object that the method belongs to. In real\n         *        cases, this is often a prototype.\n         * @param {String} method - The name of the method to extend.\n         * @param {Function} func - A wrapper function callback. This function is called\n         *        with the same arguments as the original function, except that the\n         *        original function is unshifted and passed as the first argument.\n         * @returns {void}\n         */\n        H.wrap = function(obj, method, func) {\n            var proceed = obj[method];\n            obj[method] = function() {\n                var args = Array.prototype.slice.call(arguments),\n                    outerArgs = arguments,\n                    ctx = this,\n                    ret;\n                ctx.proceed = function() {\n                    proceed.apply(ctx, arguments.length ? arguments : outerArgs);\n                };\n                args.unshift(proceed);\n                ret = func.apply(this, args);\n                ctx.proceed = null;\n                return ret;\n            };\n        };\n\n        /**\n         * Get the time zone offset based on the current timezone information as set in\n         * the global options.\n         *\n         * @function #getTZOffset\n         * @memberOf Highcharts\n         * @param  {Number} timestamp - The JavaScript timestamp to inspect.\n         * @return {Number} - The timezone offset in minutes compared to UTC.\n         */\n        H.getTZOffset = function(timestamp) {\n            var d = H.Date;\n            return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) ||\n                d.hcTimezoneOffset || 0) * 60000;\n        };\n\n        /**\n         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a\n         * human readable date string. The format is a subset of the formats for PHP's\n         * [strftime]{@link\n         * http://www.php.net/manual/en/function.strftime.php} function. Additional\n         * formats can be given in the {@link Highcharts.dateFormats} hook.\n         *\n         * @function #dateFormat\n         * @memberOf Highcharts\n         * @param {String} format - The desired format where various time\n         *        representations are prefixed with %.\n         * @param {Number} timestamp - The JavaScript timestamp.\n         * @param {Boolean} [capitalize=false] - Upper case first letter in the return.\n         * @returns {String} The formatted date.\n         */\n        H.dateFormat = function(format, timestamp, capitalize) {\n            if (!H.defined(timestamp) || isNaN(timestamp)) {\n                return H.defaultOptions.lang.invalidDate || '';\n            }\n            format = H.pick(format, '%Y-%m-%d %H:%M:%S');\n\n            var D = H.Date,\n                date = new D(timestamp - H.getTZOffset(timestamp)),\n                // get the basic time values\n                hours = date[D.hcGetHours](),\n                day = date[D.hcGetDay](),\n                dayOfMonth = date[D.hcGetDate](),\n                month = date[D.hcGetMonth](),\n                fullYear = date[D.hcGetFullYear](),\n                lang = H.defaultOptions.lang,\n                langWeekdays = lang.weekdays,\n                shortWeekdays = lang.shortWeekdays,\n                pad = H.pad,\n\n                // List all format keys. Custom formats can be added from the outside. \n                replacements = H.extend({\n\n                        //-- Day\n                        // Short weekday, like 'Mon'\n                        'a': shortWeekdays ?\n                            shortWeekdays[day] : langWeekdays[day].substr(0, 3),\n                        // Long weekday, like 'Monday'\n                        'A': langWeekdays[day],\n                        // Two digit day of the month, 01 to 31\n                        'd': pad(dayOfMonth),\n                        // Day of the month, 1 through 31\n                        'e': pad(dayOfMonth, 2, ' '),\n                        'w': day,\n\n                        // Week (none implemented)\n                        //'W': weekNumber(),\n\n                        //-- Month\n                        // Short month, like 'Jan'\n                        'b': lang.shortMonths[month],\n                        // Long month, like 'January'\n                        'B': lang.months[month],\n                        // Two digit month number, 01 through 12\n                        'm': pad(month + 1),\n\n                        //-- Year\n                        // Two digits year, like 09 for 2009\n                        'y': fullYear.toString().substr(2, 2),\n                        // Four digits year, like 2009\n                        'Y': fullYear,\n\n                        //-- Time\n                        // Two digits hours in 24h format, 00 through 23\n                        'H': pad(hours),\n                        // Hours in 24h format, 0 through 23\n                        'k': hours,\n                        // Two digits hours in 12h format, 00 through 11\n                        'I': pad((hours % 12) || 12),\n                        // Hours in 12h format, 1 through 12\n                        'l': (hours % 12) || 12,\n                        // Two digits minutes, 00 through 59\n                        'M': pad(date[D.hcGetMinutes]()),\n                        // Upper case AM or PM\n                        'p': hours < 12 ? 'AM' : 'PM',\n                        // Lower case AM or PM\n                        'P': hours < 12 ? 'am' : 'pm',\n                        // Two digits seconds, 00 through  59\n                        'S': pad(date.getSeconds()),\n                        // Milliseconds (naming from Ruby)\n                        'L': pad(Math.round(timestamp % 1000), 3)\n                    },\n\n                    /**\n                     * A hook for defining additional date format specifiers. New\n                     * specifiers are defined as key-value pairs by using the specifier\n                     * as key, and a function which takes the timestamp as value. This\n                     * function returns the formatted portion of the date.\n                     *\n                     * @type {Object}\n                     * @name dateFormats\n                     * @memberOf Highcharts\n                     * @sample highcharts/global/dateformats/ Adding support for week\n                     * number\n                     */\n                    H.dateFormats\n                );\n\n\n            // Do the replaces\n            H.objectEach(replacements, function(val, key) {\n                // Regex would do it in one line, but this is faster\n                while (format.indexOf('%' + key) !== -1) {\n                    format = format.replace(\n                        '%' + key,\n                        typeof val === 'function' ? val(timestamp) : val\n                    );\n                }\n\n            });\n\n            // Optionally capitalize the string and return\n            return capitalize ?\n                format.substr(0, 1).toUpperCase() + format.substr(1) :\n                format;\n        };\n\n        /**\n         * Format a single variable. Similar to sprintf, without the % prefix.\n         *\n         * @example\n         * formatSingle('.2f', 5); // => '5.00'.\n         *\n         * @function #formatSingle\n         * @memberOf Highcharts\n         * @param {String} format The format string.\n         * @param {*} val The value.\n         * @returns {String} The formatted representation of the value.\n         */\n        H.formatSingle = function(format, val) {\n            var floatRegex = /f$/,\n                decRegex = /\\.([0-9])/,\n                lang = H.defaultOptions.lang,\n                decimals;\n\n            if (floatRegex.test(format)) { // float\n                decimals = format.match(decRegex);\n                decimals = decimals ? decimals[1] : -1;\n                if (val !== null) {\n                    val = H.numberFormat(\n                        val,\n                        decimals,\n                        lang.decimalPoint,\n                        format.indexOf(',') > -1 ? lang.thousandsSep : ''\n                    );\n                }\n            } else {\n                val = H.dateFormat(format, val);\n            }\n            return val;\n        };\n\n        /**\n         * Format a string according to a subset of the rules of Python's String.format\n         * method.\n         *\n         * @function #format\n         * @memberOf Highcharts\n         * @param {String} str The string to format.\n         * @param {Object} ctx The context, a collection of key-value pairs where each\n         *        key is replaced by its value.\n         * @returns {String} The formatted string.\n         *\n         * @example\n         * var s = Highcharts.format(\n         *     'The {color} fox was {len:.2f} feet long',\n         *     { color: 'red', len: Math.PI }\n         * );\n         * // => The red fox was 3.14 feet long\n         */\n        H.format = function(str, ctx) {\n            var splitter = '{',\n                isInside = false,\n                segment,\n                valueAndFormat,\n                path,\n                i,\n                len,\n                ret = [],\n                val,\n                index;\n\n            while (str) {\n                index = str.indexOf(splitter);\n                if (index === -1) {\n                    break;\n                }\n\n                segment = str.slice(0, index);\n                if (isInside) { // we're on the closing bracket looking back\n\n                    valueAndFormat = segment.split(':');\n                    path = valueAndFormat.shift().split('.'); // get first and leave\n                    len = path.length;\n                    val = ctx;\n\n                    // Assign deeper paths\n                    for (i = 0; i < len; i++) {\n                        val = val[path[i]];\n                    }\n\n                    // Format the replacement\n                    if (valueAndFormat.length) {\n                        val = H.formatSingle(valueAndFormat.join(':'), val);\n                    }\n\n                    // Push the result and advance the cursor\n                    ret.push(val);\n\n                } else {\n                    ret.push(segment);\n\n                }\n                str = str.slice(index + 1); // the rest\n                isInside = !isInside; // toggle\n                splitter = isInside ? '}' : '{'; // now look for next matching bracket\n            }\n            ret.push(str);\n            return ret.join('');\n        };\n\n        /**\n         * Get the magnitude of a number.\n         *\n         * @function #getMagnitude\n         * @memberOf Highcharts\n         * @param {Number} number The number.\n         * @returns {Number} The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2\n         *        etc.\n         */\n        H.getMagnitude = function(num) {\n            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n        };\n\n        /**\n         * Take an interval and normalize it to multiples of round numbers.\n         *\n         * @todo  Move this function to the Axis prototype. It is here only for\n         *        historical reasons.\n         * @function #normalizeTickInterval\n         * @memberOf Highcharts\n         * @param {Number} interval - The raw, un-rounded interval.\n         * @param {Array} [multiples] - Allowed multiples.\n         * @param {Number} [magnitude] - The magnitude of the number.\n         * @param {Boolean} [allowDecimals] - Whether to allow decimals.\n         * @param {Boolean} [hasTickAmount] - If it has tickAmount, avoid landing\n         *        on tick intervals lower than original.\n         * @returns {Number} The normalized interval.\n         */\n        H.normalizeTickInterval = function(interval, multiples, magnitude,\n            allowDecimals, hasTickAmount) {\n            var normalized,\n                i,\n                retInterval = interval;\n\n            // round to a tenfold of 1, 2, 2.5 or 5\n            magnitude = H.pick(magnitude, 1);\n            normalized = interval / magnitude;\n\n            // multiples for a linear scale\n            if (!multiples) {\n                multiples = hasTickAmount ?\n                    // Finer grained ticks when the tick amount is hard set, including\n                    // when alignTicks is true on multiple axes (#4580).\n                    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :\n\n                    // Else, let ticks fall on rounder numbers\n                    [1, 2, 2.5, 5, 10];\n\n\n                // the allowDecimals option\n                if (allowDecimals === false) {\n                    if (magnitude === 1) {\n                        multiples = H.grep(multiples, function(num) {\n                            return num % 1 === 0;\n                        });\n                    } else if (magnitude <= 0.1) {\n                        multiples = [1 / magnitude];\n                    }\n                }\n            }\n\n            // normalize the interval to the nearest multiple\n            for (i = 0; i < multiples.length; i++) {\n                retInterval = multiples[i];\n                // only allow tick amounts smaller than natural\n                if ((hasTickAmount && retInterval * magnitude >= interval) ||\n                    (!hasTickAmount && (normalized <= (multiples[i] +\n                        (multiples[i + 1] || multiples[i])) / 2))) {\n                    break;\n                }\n            }\n\n            // Multiply back to the correct magnitude. Correct floats to appropriate \n            // precision (#6085).\n            retInterval = H.correctFloat(\n                retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10)\n            );\n\n            return retInterval;\n        };\n\n\n        /**\n         * Sort an object array and keep the order of equal items. The ECMAScript\n         * standard does not specify the behaviour when items are equal.\n         *\n         * @function #stableSort\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to sort.\n         * @param {Function} sortFunction - The function to sort it with, like with \n         *        regular Array.prototype.sort.\n         * @returns {void}\n         */\n        H.stableSort = function(arr, sortFunction) {\n            var length = arr.length,\n                sortValue,\n                i;\n\n            // Add index to each item\n            for (i = 0; i < length; i++) {\n                arr[i].safeI = i; // stable sort index\n            }\n\n            arr.sort(function(a, b) {\n                sortValue = sortFunction(a, b);\n                return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n            });\n\n            // Remove index from items\n            for (i = 0; i < length; i++) {\n                delete arr[i].safeI; // stable sort index\n            }\n        };\n\n        /**\n         * Non-recursive method to find the lowest member of an array. `Math.min` raises\n         * a maximum call stack size exceeded error in Chrome when trying to apply more\n         * than 150.000 points. This method is slightly slower, but safe.\n         *\n         * @function #arrayMin\n         * @memberOf  Highcharts\n         * @param {Array} data An array of numbers.\n         * @returns {Number} The lowest number.\n         */\n        H.arrayMin = function(data) {\n            var i = data.length,\n                min = data[0];\n\n            while (i--) {\n                if (data[i] < min) {\n                    min = data[i];\n                }\n            }\n            return min;\n        };\n\n        /**\n         * Non-recursive method to find the lowest member of an array. `Math.max` raises\n         * a maximum call stack size exceeded error in Chrome when trying to apply more\n         * than 150.000 points. This method is slightly slower, but safe.\n         *\n         * @function #arrayMax\n         * @memberOf  Highcharts\n         * @param {Array} data - An array of numbers.\n         * @returns {Number} The highest number.\n         */\n        H.arrayMax = function(data) {\n            var i = data.length,\n                max = data[0];\n\n            while (i--) {\n                if (data[i] > max) {\n                    max = data[i];\n                }\n            }\n            return max;\n        };\n\n        /**\n         * Utility method that destroys any SVGElement instances that are properties on\n         * the given object. It loops all properties and invokes destroy if there is a\n         * destroy method. The property is then delete.\n         *\n         * @function #destroyObjectProperties\n         * @memberOf Highcharts\n         * @param {Object} obj - The object to destroy properties on.\n         * @param {Object} [except] - Exception, do not destroy this property, only\n         *    delete it.\n         * @returns {void}\n         */\n        H.destroyObjectProperties = function(obj, except) {\n            H.objectEach(obj, function(val, n) {\n                // If the object is non-null and destroy is defined\n                if (val && val !== except && val.destroy) {\n                    // Invoke the destroy\n                    val.destroy();\n                }\n\n                // Delete the property from the object.\n                delete obj[n];\n            });\n        };\n\n\n        /**\n         * Discard a HTML element by moving it to the bin and delete.\n         *\n         * @function #discardElement\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} element - The HTML node to discard.\n         * @returns {void}\n         */\n        H.discardElement = function(element) {\n            var garbageBin = H.garbageBin;\n            // create a garbage bin element, not part of the DOM\n            if (!garbageBin) {\n                garbageBin = H.createElement('div');\n            }\n\n            // move the node and empty bin\n            if (element) {\n                garbageBin.appendChild(element);\n            }\n            garbageBin.innerHTML = '';\n        };\n\n        /**\n         * Fix JS round off float errors.\n         *\n         * @function #correctFloat\n         * @memberOf Highcharts\n         * @param {Number} num - A float number to fix.\n         * @param {Number} [prec=14] - The precision.\n         * @returns {Number} The corrected float number.\n         */\n        H.correctFloat = function(num, prec) {\n            return parseFloat(\n                num.toPrecision(prec || 14)\n            );\n        };\n\n        /**\n         * Set the global animation to either a given value, or fall back to the given\n         * chart's animation option.\n         *\n         * @function #setAnimation\n         * @memberOf Highcharts\n         * @param {Boolean|Animation} animation - The animation object.\n         * @param {Object} chart - The chart instance.\n         * @returns {void}\n         * @todo This function always relates to a chart, and sets a property on the\n         *        renderer, so it should be moved to the SVGRenderer.\n         */\n        H.setAnimation = function(animation, chart) {\n            chart.renderer.globalAnimation = H.pick(\n                animation,\n                chart.options.chart.animation,\n                true\n            );\n        };\n\n        /**\n         * Get the animation in object form, where a disabled animation is always\n         * returned as `{ duration: 0 }`.\n         *\n         * @function #animObject\n         * @memberOf Highcharts\n         * @param {Boolean|AnimationOptions} animation - An animation setting. Can be an\n         *        object with duration, complete and easing properties, or a boolean to\n         *        enable or disable.\n         * @returns {AnimationOptions} An object with at least a duration property.\n         */\n        H.animObject = function(animation) {\n            return H.isObject(animation) ?\n                H.merge(animation) : {\n                    duration: animation ? 500 : 0\n                };\n        };\n\n        /**\n         * The time unit lookup\n         */\n        H.timeUnits = {\n            millisecond: 1,\n            second: 1000,\n            minute: 60000,\n            hour: 3600000,\n            day: 24 * 3600000,\n            week: 7 * 24 * 3600000,\n            month: 28 * 24 * 3600000,\n            year: 364 * 24 * 3600000\n        };\n\n        /**\n         * Format a number and return a string based on input settings.\n         *\n         * @function #numberFormat\n         * @memberOf Highcharts\n         * @param {Number} number - The input number to format.\n         * @param {Number} decimals - The amount of decimals. A value of -1 preserves\n         *        the amount in the input number.\n         * @param {String} [decimalPoint] - The decimal point, defaults to the one given\n         *        in the lang options, or a dot.\n         * @param {String} [thousandsSep] - The thousands separator, defaults to the one\n         *        given in the lang options, or a space character.\n         * @returns {String} The formatted number.\n         *\n         * @sample members/highcharts-numberformat/ Custom number format\n         */\n        H.numberFormat = function(number, decimals, decimalPoint, thousandsSep) {\n            number = +number || 0;\n            decimals = +decimals;\n\n            var lang = H.defaultOptions.lang,\n                origDec = (number.toString().split('.')[1] || '').length,\n                strinteger,\n                thousands,\n                ret,\n                roundedNumber;\n\n            if (decimals === -1) {\n                // Preserve decimals. Not huge numbers (#3793).\n                decimals = Math.min(origDec, 20);\n            } else if (!H.isNumber(decimals)) {\n                decimals = 2;\n            }\n\n            // Add another decimal to avoid rounding errors of float numbers. (#4573)\n            // Then use toFixed to handle rounding.\n            roundedNumber = (\n                Math.abs(number) + Math.pow(10, -Math.max(decimals, origDec) - 1)\n            ).toFixed(decimals);\n\n            // A string containing the positive integer component of the number\n            strinteger = String(H.pInt(roundedNumber));\n\n            // Leftover after grouping into thousands. Can be 0, 1 or 3.\n            thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n            // Language\n            decimalPoint = H.pick(decimalPoint, lang.decimalPoint);\n            thousandsSep = H.pick(thousandsSep, lang.thousandsSep);\n\n            // Start building the return\n            ret = number < 0 ? '-' : '';\n\n            // Add the leftover after grouping into thousands. For example, in the\n            // number 42 000 000, this line adds 42.\n            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n            // Add the remaining thousands groups, joined by the thousands separator\n            ret += strinteger\n                .substr(thousands)\n                .replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n            // Add the decimal point and the decimal component\n            if (decimals) {\n                // Get the decimal component\n                ret += decimalPoint + roundedNumber.slice(-decimals);\n            }\n\n            return ret;\n        };\n\n        /**\n         * Easing definition\n         * @ignore\n         * @param   {Number} pos Current position, ranging from 0 to 1.\n         */\n        Math.easeInOutSine = function(pos) {\n            return -0.5 * (Math.cos(Math.PI * pos) - 1);\n        };\n\n        /**\n         * Get the computed CSS value for given element and property, only for numerical\n         * properties. For width and height, the dimension of the inner box (excluding\n         * padding) is returned. Used for fitting the chart within the container.\n         *\n         * @function #getStyle\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - A HTML element.\n         * @param {String} prop - The property name.\n         * @param {Boolean} [toInt=true] - Parse to integer.\n         * @returns {Number} - The numeric value.\n         */\n        H.getStyle = function(el, prop, toInt) {\n\n            var style;\n\n            // For width and height, return the actual inner pixel size (#4913)\n            if (prop === 'width') {\n                return Math.min(el.offsetWidth, el.scrollWidth) -\n                    H.getStyle(el, 'padding-left') -\n                    H.getStyle(el, 'padding-right');\n            } else if (prop === 'height') {\n                return Math.min(el.offsetHeight, el.scrollHeight) -\n                    H.getStyle(el, 'padding-top') -\n                    H.getStyle(el, 'padding-bottom');\n            }\n\n            // Otherwise, get the computed style\n            style = win.getComputedStyle(el, undefined);\n            if (style) {\n                style = style.getPropertyValue(prop);\n                if (H.pick(toInt, true)) {\n                    style = H.pInt(style);\n                }\n            }\n            return style;\n        };\n\n        /**\n         * Search for an item in an array.\n         *\n         * @function #inArray\n         * @memberOf Highcharts\n         * @param {*} item - The item to search for.\n         * @param {arr} arr - The array or node collection to search in.\n         * @returns {Number} - The index within the array, or -1 if not found.\n         */\n        H.inArray = function(item, arr) {\n            return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);\n        };\n\n        /**\n         * Filter an array by a callback.\n         *\n         * @function #grep\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to filter.\n         * @param {Function} callback - The callback function. The function receives the\n         *        item as the first argument. Return `true` if the item is to be\n         *        preserved.\n         * @returns {Array} - A new, filtered array.\n         */\n        H.grep = function(arr, callback) {\n            return [].filter.call(arr, callback);\n        };\n\n        /**\n         * Return the value of the first element in the array that satisfies the \n         * provided testing function.\n         *\n         * @function #find\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to test.\n         * @param {Function} callback - The callback function. The function receives the\n         *        item as the first argument. Return `true` if this item satisfies the\n         *        condition.\n         * @returns {Mixed} - The value of the element.\n         */\n        H.find = function(arr, callback) {\n            return [].find.call(arr, callback);\n        };\n\n        /**\n         * Map an array by a callback.\n         *\n         * @function #map\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to map.\n         * @param {Function} fn - The callback function. Return the new value for the \n         *        new array.\n         * @returns {Array} - A new array item with modified items.\n         */\n        H.map = function(arr, fn) {\n            var results = [],\n                i = 0,\n                len = arr.length;\n\n            for (; i < len; i++) {\n                results[i] = fn.call(arr[i], arr[i], i, arr);\n            }\n\n            return results;\n        };\n\n        /**\n         * Get the element's offset position, corrected for `overflow: auto`.\n         *\n         * @function #offset\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - The HTML element.\n         * @returns {Object} An object containing `left` and `top` properties for the\n         * position in the page.\n         */\n        H.offset = function(el) {\n            var docElem = doc.documentElement,\n                box = el.getBoundingClientRect();\n\n            return {\n                top: box.top + (win.pageYOffset || docElem.scrollTop) -\n                    (docElem.clientTop || 0),\n                left: box.left + (win.pageXOffset || docElem.scrollLeft) -\n                    (docElem.clientLeft || 0)\n            };\n        };\n\n        /**\n         * Stop running animation.\n         *\n         * @todo A possible extension to this would be to stop a single property, when\n         * we want to continue animating others. Then assign the prop to the timer\n         * in the Fx.run method, and check for the prop here. This would be an\n         * improvement in all cases where we stop the animation from .attr. Instead of\n         * stopping everything, we can just stop the actual attributes we're setting.\n         *\n         * @function #stop\n         * @memberOf Highcharts\n         * @param {SVGElement} el - The SVGElement to stop animation on.\n         * @param {string} [prop] - The property to stop animating. If given, the stop\n         *    method will stop a single property from animating, while others continue.\n         * @returns {void}\n         */\n        H.stop = function(el, prop) {\n\n            var i = timers.length;\n\n            // Remove timers related to this element (#4519)\n            while (i--) {\n                if (timers[i].elem === el && (!prop || prop === timers[i].prop)) {\n                    timers[i].stopped = true; // #4667\n                }\n            }\n        };\n\n        /**\n         * Iterate over an array.\n         *\n         * @function #each\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to iterate over.\n         * @param {Function} fn - The iterator callback. It passes three arguments:\n         * * item - The array item.\n         * * index - The item's index in the array.\n         * * arr - The array that each is being applied to.\n         * @param {Object} [ctx] The context.\n         */\n        H.each = function(arr, fn, ctx) { // modern browsers\n            return Array.prototype.forEach.call(arr, fn, ctx);\n        };\n\n        /**\n         * Iterate over object key pairs in an object.\n         *\n         * @function #objectEach\n         * @memberOf Highcharts\n         * @param  {Object}   obj - The object to iterate over.\n         * @param  {Function} fn  - The iterator callback. It passes three arguments:\n         * * value - The property value.\n         * * key - The property key.\n         * * obj - The object that objectEach is being applied to.\n         * @param  {Object}   ctx The context\n         */\n        H.objectEach = function(obj, fn, ctx) {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    fn.call(ctx, obj[key], key, obj);\n                }\n            }\n        };\n\n        /**\n         * Add an event listener.\n         *\n         * @function #addEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The element or object to add a listener to. It can be a\n         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n         * @param {String} type - The event type.\n         * @param {Function} fn - The function callback to execute when the event is \n         *        fired.\n         * @returns {Function} A callback function to remove the added event.\n         */\n        H.addEvent = function(el, type, fn) {\n\n            var events = el.hcEvents = el.hcEvents || {};\n\n            function wrappedFn(e) {\n                e.target = e.srcElement || win; // #2820\n                fn.call(el, e);\n            }\n\n            // Handle DOM events in modern browsers\n            if (el.addEventListener) {\n                el.addEventListener(type, fn, false);\n\n                // Handle old IE implementation\n            } else if (el.attachEvent) {\n\n                if (!el.hcEventsIE) {\n                    el.hcEventsIE = {};\n                }\n\n                // Link wrapped fn with original fn, so we can get this in removeEvent\n                el.hcEventsIE[fn.toString()] = wrappedFn;\n\n                el.attachEvent('on' + type, wrappedFn);\n            }\n\n            if (!events[type]) {\n                events[type] = [];\n            }\n\n            events[type].push(fn);\n\n            // Return a function that can be called to remove this event.\n            return function() {\n                H.removeEvent(el, type, fn);\n            };\n        };\n\n        /**\n         * Remove an event that was added with {@link Highcharts#addEvent}.\n         *\n         * @function #removeEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The element to remove events on.\n         * @param {String} [type] - The type of events to remove. If undefined, all\n         *        events are removed from the element.\n         * @param {Function} [fn] - The specific callback to remove. If undefined, all\n         *        events that match the element and optionally the type are removed.\n         * @returns {void}\n         */\n        H.removeEvent = function(el, type, fn) {\n\n            var events,\n                hcEvents = el.hcEvents,\n                index;\n\n            function removeOneEvent(type, fn) {\n                if (el.removeEventListener) {\n                    el.removeEventListener(type, fn, false);\n                } else if (el.attachEvent) {\n                    fn = el.hcEventsIE[fn.toString()];\n                    el.detachEvent('on' + type, fn);\n                }\n            }\n\n            function removeAllEvents() {\n                var types,\n                    len;\n\n                if (!el.nodeName) {\n                    return; // break on non-DOM events\n                }\n\n                if (type) {\n                    types = {};\n                    types[type] = true;\n                } else {\n                    types = hcEvents;\n                }\n\n                H.objectEach(types, function(val, n) {\n                    if (hcEvents[n]) {\n                        len = hcEvents[n].length;\n                        while (len--) {\n                            removeOneEvent(n, hcEvents[n][len]);\n                        }\n                    }\n                });\n            }\n\n            if (hcEvents) {\n                if (type) {\n                    events = hcEvents[type] || [];\n                    if (fn) {\n                        index = H.inArray(fn, events);\n                        if (index > -1) {\n                            events.splice(index, 1);\n                            hcEvents[type] = events;\n                        }\n                        removeOneEvent(type, fn);\n\n                    } else {\n                        removeAllEvents();\n                        hcEvents[type] = [];\n                    }\n                } else {\n                    removeAllEvents();\n                    el.hcEvents = {};\n                }\n            }\n        };\n\n        /**\n         * Fire an event that was registered with {@link Highcharts#addEvent}.\n         *\n         * @function #fireEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The object to fire the event on. It can be a\n         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n         * @param {String} type - The type of event.\n         * @param {Object} [eventArguments] - Custom event arguments that are passed on\n         *        as an argument to the event handler.\n         * @param {Function} [defaultFunction] - The default function to execute if the \n         *        other listeners haven't returned false.\n         * @returns {void}\n         */\n        H.fireEvent = function(el, type, eventArguments, defaultFunction) {\n            var e,\n                hcEvents = el.hcEvents,\n                events,\n                len,\n                i,\n                fn;\n\n            eventArguments = eventArguments || {};\n\n            if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n                e = doc.createEvent('Events');\n                e.initEvent(type, true, true);\n                //e.target = el;\n\n                H.extend(e, eventArguments);\n\n                if (el.dispatchEvent) {\n                    el.dispatchEvent(e);\n                } else {\n                    el.fireEvent(type, e);\n                }\n\n            } else if (hcEvents) {\n\n                events = hcEvents[type] || [];\n                len = events.length;\n\n                if (!eventArguments.target) { // We're running a custom event\n\n                    H.extend(eventArguments, {\n                        // Attach a simple preventDefault function to skip default\n                        // handler if called. The built-in defaultPrevented property is\n                        // not overwritable (#5112)\n                        preventDefault: function() {\n                            eventArguments.defaultPrevented = true;\n                        },\n                        // Setting target to native events fails with clicking the\n                        // zoom-out button in Chrome.\n                        target: el,\n                        // If the type is not set, we're running a custom event (#2297).\n                        // If it is set, we're running a browser event, and setting it\n                        // will cause en error in IE8 (#2465).\t\t\n                        type: type\n                    });\n                }\n\n\n                for (i = 0; i < len; i++) {\n                    fn = events[i];\n\n                    // If the event handler return false, prevent the default handler\n                    // from executing\n                    if (fn && fn.call(el, eventArguments) === false) {\n                        eventArguments.preventDefault();\n                    }\n                }\n            }\n\n            // Run the default if not prevented\n            if (defaultFunction && !eventArguments.defaultPrevented) {\n                defaultFunction(eventArguments);\n            }\n        };\n\n        /**\n         * An animation configuration. Animation configurations can also be defined as\n         * booleans, where `false` turns off animation and `true` defaults to a duration\n         * of 500ms.\n         * @typedef {Object} AnimationOptions\n         * @property {Number} duration - The animation duration in milliseconds.\n         * @property {String} [easing] - The name of an easing function as defined on\n         *     the `Math` object.\n         * @property {Function} [complete] - A callback function to exectute when the\n         *     animation finishes.\n         * @property {Function} [step] - A callback function to execute on each step of\n         *     each attribute or CSS property that's being animated. The first argument\n         *     contains information about the animation and progress.\n         */\n\n\n        /**\n         * The global animate method, which uses Fx to create individual animators.\n         *\n         * @function #animate\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement|SVGElement} el - The element to animate.\n         * @param {Object} params - An object containing key-value pairs of the\n         *        properties to animate. Supports numeric as pixel-based CSS properties\n         *        for HTML objects and attributes for SVGElements.\n         * @param {AnimationOptions} [opt] - Animation options.\n         */\n        H.animate = function(el, params, opt) {\n            var start,\n                unit = '',\n                end,\n                fx,\n                args;\n\n            if (!H.isObject(opt)) { // Number or undefined/null\n                args = arguments;\n                opt = {\n                    duration: args[2],\n                    easing: args[3],\n                    complete: args[4]\n                };\n            }\n            if (!H.isNumber(opt.duration)) {\n                opt.duration = 400;\n            }\n            opt.easing = typeof opt.easing === 'function' ?\n                opt.easing :\n                (Math[opt.easing] || Math.easeInOutSine);\n            opt.curAnim = H.merge(params);\n\n            H.objectEach(params, function(val, prop) {\n                // Stop current running animation of this property\n                H.stop(el, prop);\n\n                fx = new H.Fx(el, opt, prop);\n                end = null;\n\n                if (prop === 'd') {\n                    fx.paths = fx.initPath(\n                        el,\n                        el.d,\n                        params.d\n                    );\n                    fx.toD = params.d;\n                    start = 0;\n                    end = 1;\n                } else if (el.attr) {\n                    start = el.attr(prop);\n                } else {\n                    start = parseFloat(H.getStyle(el, prop)) || 0;\n                    if (prop !== 'opacity') {\n                        unit = 'px';\n                    }\n                }\n\n                if (!end) {\n                    end = val;\n                }\n                if (end && end.match && end.match('px')) {\n                    end = end.replace(/px/g, ''); // #4351\n                }\n                fx.run(start, end, unit);\n            });\n        };\n\n        /**\n         * Factory to create new series prototypes.\n         *\n         * @function #seriesType\n         * @memberOf Highcharts\n         *\n         * @param {String} type - The series type name.\n         * @param {String} parent - The parent series type name. Use `line` to inherit\n         *        from the basic {@link Series} object.\n         * @param {Object} options - The additional default options that is merged with\n         *        the parent's options.\n         * @param {Object} props - The properties (functions and primitives) to set on\n         *        the new prototype.\n         * @param {Object} [pointProps] - Members for a series-specific extension of the\n         *        {@link Point} prototype if needed.\n         * @returns {*} - The newly created prototype as extended from {@link Series}\n         * or its derivatives.\n         */\n        // docs: add to API + extending Highcharts\n        H.seriesType = function(type, parent, options, props, pointProps) {\n            var defaultOptions = H.getOptions(),\n                seriesTypes = H.seriesTypes;\n\n            if (seriesTypes[type]) {\n                return H.error(27); // Series type already defined\n            }\n\n            // Merge the options\n            defaultOptions.plotOptions[type] = H.merge(\n                defaultOptions.plotOptions[parent],\n                options\n            );\n\n            // Create the class\n            seriesTypes[type] = H.extendClass(seriesTypes[parent] ||\n                function() {}, props);\n            seriesTypes[type].prototype.type = type;\n\n            // Create the point class if needed\n            if (pointProps) {\n                seriesTypes[type].prototype.pointClass =\n                    H.extendClass(H.Point, pointProps);\n            }\n\n            return seriesTypes[type];\n        };\n\n        /**\n         * Get a unique key for using in internal element id's and pointers. The key\n         * is composed of a random hash specific to this Highcharts instance, and a \n         * counter.\n         * @function #uniqueKey\n         * @memberOf Highcharts\n         * @return {string} The key.\n         * @example\n         * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'\n         */\n        H.uniqueKey = (function() {\n\n            var uniqueKeyHash = Math.random().toString(36).substring(2, 9),\n                idCounter = 0;\n\n            return function() {\n                return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;\n            };\n        }());\n\n        /**\n         * Register Highcharts as a plugin in jQuery\n         */\n        if (win.jQuery) {\n            win.jQuery.fn.highcharts = function() {\n                var args = [].slice.call(arguments);\n\n                if (this[0]) { // this[0] is the renderTo div\n\n                    // Create the chart\n                    if (args[0]) {\n                        new H[ // eslint-disable-line no-new\n                            // Constructor defaults to Chart\n                            H.isString(args[0]) ? args.shift() : 'Chart'\n                        ](this[0], args[0], args[1]);\n                        return this;\n                    }\n\n                    // When called without parameters or with the return argument,\n                    // return an existing chart\n                    return charts[H.attr(this[0], 'data-highcharts-chart')];\n                }\n            };\n        }\n\n\n        /**\n         * Compatibility section to add support for legacy IE. This can be removed if\n         * old IE support is not needed.\n         */\n        if (doc && !doc.defaultView) {\n            H.getStyle = function(el, prop) {\n                var val,\n                    alias = {\n                        width: 'clientWidth',\n                        height: 'clientHeight'\n                    }[prop];\n\n                if (el.style[prop]) {\n                    return H.pInt(el.style[prop]);\n                }\n                if (prop === 'opacity') {\n                    prop = 'filter';\n                }\n\n                // Getting the rendered width and height\n                if (alias) {\n                    el.style.zoom = 1;\n                    return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);\n                }\n\n                val = el.currentStyle[prop.replace(/\\-(\\w)/g, function(a, b) {\n                    return b.toUpperCase();\n                })];\n                if (prop === 'filter') {\n                    val = val.replace(\n                        /alpha\\(opacity=([0-9]+)\\)/,\n                        function(a, b) {\n                            return b / 100;\n                        }\n                    );\n                }\n\n                return val === '' ? 1 : H.pInt(val);\n            };\n        }\n\n        if (!Array.prototype.forEach) {\n            H.each = function(arr, fn, ctx) { // legacy\n                var i = 0,\n                    len = arr.length;\n                for (; i < len; i++) {\n                    if (fn.call(ctx, arr[i], i, arr) === false) {\n                        return i;\n                    }\n                }\n            };\n        }\n\n        if (!Array.prototype.indexOf) {\n            H.inArray = function(item, arr) {\n                var len,\n                    i = 0;\n\n                if (arr) {\n                    len = arr.length;\n\n                    for (; i < len; i++) {\n                        if (arr[i] === item) {\n                            return i;\n                        }\n                    }\n                }\n\n                return -1;\n            };\n        }\n\n        if (!Array.prototype.filter) {\n            H.grep = function(elements, fn) {\n                var ret = [],\n                    i = 0,\n                    length = elements.length;\n\n                for (; i < length; i++) {\n                    if (fn(elements[i], i)) {\n                        ret.push(elements[i]);\n                    }\n                }\n\n                return ret;\n            };\n        }\n\n        if (!Array.prototype.find) {\n            H.find = function(arr, fn) {\n                var i,\n                    length = arr.length;\n\n                for (i = 0; i < length; i++) {\n                    if (fn(arr[i], i)) {\n                        return arr[i];\n                    }\n                }\n            };\n        }\n\n        //--- End compatibility section ---\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var each = H.each,\n            isNumber = H.isNumber,\n            map = H.map,\n            merge = H.merge,\n            pInt = H.pInt;\n\n        /**\n         * @typedef {string} ColorString\n         * A valid color to be parsed and handled by Highcharts. Highcharts internally \n         * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and\n         * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the\n         * browsers and displayed correctly, but Highcharts is not able to process them\n         * and apply concepts like opacity and brightening.\n         */\n        /**\n         * Handle color operations. The object methods are chainable.\n         * @param {String} input The input color in either rbga or hex format\n         */\n        H.Color = function(input) {\n            // Backwards compatibility, allow instanciation without new\n            if (!(this instanceof H.Color)) {\n                return new H.Color(input);\n            }\n            // Initialize\n            this.init(input);\n        };\n        H.Color.prototype = {\n\n            // Collection of parsers. This can be extended from the outside by pushing parsers\n            // to Highcharts.Color.prototype.parsers.\n            parsers: [{\n                // RGBA color\n                regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n                parse: function(result) {\n                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n                }\n            }, {\n                // RGB color\n                regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n                parse: function(result) {\n                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n                }\n            }],\n\n            // Collection of named colors. Can be extended from the outside by adding\n            // colors to Highcharts.Color.prototype.names.\n            names: {\n                none: 'rgba(255,255,255,0)',\n                white: '#ffffff',\n                black: '#000000'\n            },\n\n            /**\n             * Parse the input color to rgba array\n             * @param {String} input\n             */\n            init: function(input) {\n                var result,\n                    rgba,\n                    i,\n                    parser,\n                    len;\n\n                this.input = input = this.names[\n                    input && input.toLowerCase ?\n                    input.toLowerCase() :\n                    ''\n                ] || input;\n\n                // Gradients\n                if (input && input.stops) {\n                    this.stops = map(input.stops, function(stop) {\n                        return new H.Color(stop[1]);\n                    });\n\n                    // Solid colors\n                } else {\n\n                    // Check if it's possible to do bitmasking instead of regex\n                    if (input && input[0] === '#') {\n\n                        len = input.length;\n                        input = parseInt(input.substr(1), 16);\n\n                        // Handle long-form, e.g. #AABBCC\n                        if (len === 7) {\n\n                            rgba = [\n                                (input & 0xFF0000) >> 16,\n                                (input & 0xFF00) >> 8,\n                                (input & 0xFF),\n                                1\n                            ];\n\n                            // Handle short-form, e.g. #ABC\n                            // In short form, the value is assumed to be the same \n                            // for both nibbles for each component. e.g. #ABC = #AABBCC\n                        } else if (len === 4) {\n\n                            rgba = [\n                                ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,\n                                ((input & 0xF0) >> 4) | (input & 0xF0),\n                                ((input & 0xF) << 4) | (input & 0xF),\n                                1\n                            ];\n                        }\n                    }\n\n                    // Otherwise, check regex parsers\n                    if (!rgba) {\n                        i = this.parsers.length;\n                        while (i-- && !rgba) {\n                            parser = this.parsers[i];\n                            result = parser.regex.exec(input);\n                            if (result) {\n                                rgba = parser.parse(result);\n                            }\n                        }\n                    }\n                }\n                this.rgba = rgba || [];\n            },\n\n            /**\n             * Return the color a specified format\n             * @param {String} format\n             */\n            get: function(format) {\n                var input = this.input,\n                    rgba = this.rgba,\n                    ret;\n\n                if (this.stops) {\n                    ret = merge(input);\n                    ret.stops = [].concat(ret.stops);\n                    each(this.stops, function(stop, i) {\n                        ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n                    });\n\n                    // it's NaN if gradient colors on a column chart\n                } else if (rgba && isNumber(rgba[0])) {\n                    if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n                    } else if (format === 'a') {\n                        ret = rgba[3];\n                    } else {\n                        ret = 'rgba(' + rgba.join(',') + ')';\n                    }\n                } else {\n                    ret = input;\n                }\n                return ret;\n            },\n\n            /**\n             * Brighten the color\n             * @param {Number} alpha\n             */\n            brighten: function(alpha) {\n                var i,\n                    rgba = this.rgba;\n\n                if (this.stops) {\n                    each(this.stops, function(stop) {\n                        stop.brighten(alpha);\n                    });\n\n                } else if (isNumber(alpha) && alpha !== 0) {\n                    for (i = 0; i < 3; i++) {\n                        rgba[i] += pInt(alpha * 255);\n\n                        if (rgba[i] < 0) {\n                            rgba[i] = 0;\n                        }\n                        if (rgba[i] > 255) {\n                            rgba[i] = 255;\n                        }\n                    }\n                }\n                return this;\n            },\n\n            /**\n             * Set the color's opacity to a given alpha value\n             * @param {Number} alpha\n             */\n            setOpacity: function(alpha) {\n                this.rgba[3] = alpha;\n                return this;\n            },\n\n            /*\n             * Return an intermediate color between two colors.\n             *\n             * @param  {Highcharts.Color} to\n             *         The color object to tween to.\n             * @param  {Number} pos\n             *         The intermediate position, where 0 is the from color (current\n             *         color item), and 1 is the `to` color.\n             *\n             * @return {String}\n             *         The intermediate color in rgba notation.\n             */\n            tweenTo: function(to, pos) {\n                // Check for has alpha, because rgba colors perform worse due to lack of\n                // support in WebKit.\n                var from = this,\n                    hasAlpha,\n                    ret;\n\n                // Unsupported color, return to-color (#3920)\n                if (!to.rgba.length) {\n                    ret = to.input || 'none';\n\n                    // Interpolate\n                } else {\n                    from = from.rgba;\n                    to = to.rgba;\n                    hasAlpha = (to[3] !== 1 || from[3] !== 1);\n                    ret = (hasAlpha ? 'rgba(' : 'rgb(') +\n                        Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +\n                        Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +\n                        Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +\n                        (hasAlpha ?\n                            (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) :\n                            '') + ')';\n                }\n                return ret;\n            }\n        };\n        H.color = function(input) {\n            return new H.Color(input);\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var SVGElement,\n            SVGRenderer,\n\n            addEvent = H.addEvent,\n            animate = H.animate,\n            attr = H.attr,\n            charts = H.charts,\n            color = H.color,\n            css = H.css,\n            createElement = H.createElement,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            destroyObjectProperties = H.destroyObjectProperties,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            erase = H.erase,\n            grep = H.grep,\n            hasTouch = H.hasTouch,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isFirefox = H.isFirefox,\n            isMS = H.isMS,\n            isObject = H.isObject,\n            isString = H.isString,\n            isWebKit = H.isWebKit,\n            merge = H.merge,\n            noop = H.noop,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            stop = H.stop,\n            svg = H.svg,\n            SVG_NS = H.SVG_NS,\n            symbolSizes = H.symbolSizes,\n            win = H.win;\n\n        /**\n         * @typedef {Object} SVGDOMElement - An SVG DOM element.\n         */\n        /**\n         * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n         * rendering layer of Highcharts. Combined with the {@link\n         * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n         * in the charts or even in HTML pages without instanciating a chart. The\n         * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n         * created with the `useHTML` parameter.\n         *\n         * The SVGElement instances are created through factory functions on the \n         * {@link Highcharts.SVGRenderer} object, like\n         * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n         * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n         * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n         * Highcharts.SVGRenderer#g} and more.\n         *\n         * @class Highcharts.SVGElement\n         */\n        SVGElement = H.SVGElement = function() {\n            return this;\n        };\n        extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {\n\n            // Default base for animation\n            opacity: 1,\n            SVG_NS: SVG_NS,\n\n            /**\n             * For labels, these CSS properties are applied to the `text` node directly.\n             * @type {Array.<string>}\n             */\n            textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',\n                'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',\n                'textDecoration', 'textOverflow', 'textOutline'\n            ],\n\n            /**\n             * Initialize the SVG renderer. This function only exists to make the\n             * initiation process overridable. It should not be called directly.\n             *\n             * @param  {HighchartsSVGRenderer} renderer\n             *         The SVGRenderer instance to initialize to.\n             * @param  {String} nodeName\n             *         The SVG node name.\n             * @returns {void}\n             */\n            init: function(renderer, nodeName) {\n\n                /** \n                 * The DOM node. Each SVGRenderer instance wraps a main DOM node, but \n                 * may also represent more nodes.\n                 * @type {SVGDOMNode|HTMLDOMNode}\n                 */\n                this.element = nodeName === 'span' ?\n                    createElement(nodeName) :\n                    doc.createElementNS(this.SVG_NS, nodeName);\n\n                /**\n                 * The renderer that the SVGElement belongs to.\n                 * @type {Highcharts.SVGRenderer}\n                 */\n                this.renderer = renderer;\n            },\n\n            /**\n             * Animate to given attributes or CSS properties.\n             * \n             * @param {SVGAttributes} params SVG attributes or CSS to animate.\n             * @param {AnimationOptions} [options] Animation options.\n             * @param {Function} [complete] Function to perform at the end of animation.\n             *\n             * @sample highcharts/members/element-on/\n             *         Setting some attributes by animation\n             * \n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            animate: function(params, options, complete) {\n                var animOptions = H.animObject(\n                    pick(options, this.renderer.globalAnimation, true)\n                );\n                if (animOptions.duration !== 0) {\n                    if (complete) { // allows using a callback with the global animation without overwriting it\n                        animOptions.complete = complete;\n                    }\n                    animate(this, params, animOptions);\n                } else {\n                    this.attr(params, null, complete);\n                    if (animOptions.step) {\n                        animOptions.step.call(this);\n                    }\n                }\n                return this;\n            },\n\n            /**\n             * @typedef {Object} GradientOptions\n             * @property {Object} linearGradient Holds an object that defines the start\n             *    position and the end position relative to the shape.\n             * @property {Number} linearGradient.x1 Start horizontal position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.x2 End horizontal position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.y1 Start vertical position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.y2 End vertical position of the\n             *    gradient. Ranges 0-1.\n             * @property {Object} radialGradient Holds an object that defines the center\n             *    position and the radius.\n             * @property {Number} radialGradient.cx Center horizontal position relative\n             *    to the shape. Ranges 0-1.\n             * @property {Number} radialGradient.cy Center vertical position relative\n             *    to the shape. Ranges 0-1.\n             * @property {Number} radialGradient.r Radius relative to the shape. Ranges\n             *    0-1.\n             * @property {Array.<Array>} stops The first item in each tuple is the\n             *    position in the gradient, where 0 is the start of the gradient and 1\n             *    is the end of the gradient. Multiple stops can be applied. The second\n             *    item is the color for each stop. This color can also be given in the\n             *    rgba format.\n             *\n             * @example\n             * // Linear gradient used as a color option\n             * color: {\n             *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n             *         stops: [\n             *             [0, '#003399'], // start\n             *             [0.5, '#ffffff'], // middle\n             *             [1, '#3366AA'] // end\n             *         ]\n             *     }\n             * }\n             */\n            /**\n             * Build and apply an SVG gradient out of a common JavaScript configuration\n             * object. This function is called from the attribute setters.\n             *\n             * @private\n             * @param {GradientOptions} color The gradient options structure.\n             * @param {string} prop The property to apply, can either be `fill` or\n             * `stroke`. \n             * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.\n             */\n            colorGradient: function(color, prop, elem) {\n                var renderer = this.renderer,\n                    colorObject,\n                    gradName,\n                    gradAttr,\n                    radAttr,\n                    gradients,\n                    gradientObject,\n                    stops,\n                    stopColor,\n                    stopOpacity,\n                    radialReference,\n                    id,\n                    key = [],\n                    value;\n\n                // Apply linear or radial gradients\n                if (color.radialGradient) {\n                    gradName = 'radialGradient';\n                } else if (color.linearGradient) {\n                    gradName = 'linearGradient';\n                }\n\n                if (gradName) {\n                    gradAttr = color[gradName];\n                    gradients = renderer.gradients;\n                    stops = color.stops;\n                    radialReference = elem.radialReference;\n\n                    // Keep < 2.2 kompatibility\n                    if (isArray(gradAttr)) {\n                        color[gradName] = gradAttr = {\n                            x1: gradAttr[0],\n                            y1: gradAttr[1],\n                            x2: gradAttr[2],\n                            y2: gradAttr[3],\n                            gradientUnits: 'userSpaceOnUse'\n                        };\n                    }\n\n                    // Correct the radial gradient for the radial reference system\n                    if (\n                        gradName === 'radialGradient' &&\n                        radialReference &&\n                        !defined(gradAttr.gradientUnits)\n                    ) {\n                        radAttr = gradAttr; // Save the radial attributes for updating\n                        gradAttr = merge(\n                            gradAttr,\n                            renderer.getRadialAttr(radialReference, radAttr), {\n                                gradientUnits: 'userSpaceOnUse'\n                            }\n                        );\n                    }\n\n                    // Build the unique key to detect whether we need to create a new element (#1282)\n                    objectEach(gradAttr, function(val, n) {\n                        if (n !== 'id') {\n                            key.push(n, val);\n                        }\n                    });\n                    objectEach(stops, function(val) {\n                        key.push(val);\n                    });\n                    key = key.join(',');\n\n                    // Check if a gradient object with the same config object is created within this renderer\n                    if (gradients[key]) {\n                        id = gradients[key].attr('id');\n\n                    } else {\n\n                        // Set the id and create the element\n                        gradAttr.id = id = H.uniqueKey();\n                        gradients[key] = gradientObject = renderer.createElement(gradName)\n                            .attr(gradAttr)\n                            .add(renderer.defs);\n\n                        gradientObject.radAttr = radAttr;\n\n                        // The gradient needs to keep a list of stops to be able to destroy them\n                        gradientObject.stops = [];\n                        each(stops, function(stop) {\n                            var stopObject;\n                            if (stop[1].indexOf('rgba') === 0) {\n                                colorObject = H.color(stop[1]);\n                                stopColor = colorObject.get('rgb');\n                                stopOpacity = colorObject.get('a');\n                            } else {\n                                stopColor = stop[1];\n                                stopOpacity = 1;\n                            }\n                            stopObject = renderer.createElement('stop').attr({\n                                offset: stop[0],\n                                'stop-color': stopColor,\n                                'stop-opacity': stopOpacity\n                            }).add(gradientObject);\n\n                            // Add the stop element to the gradient\n                            gradientObject.stops.push(stopObject);\n                        });\n                    }\n\n                    // Set the reference to the gradient object\n                    value = 'url(' + renderer.url + '#' + id + ')';\n                    elem.setAttribute(prop, value);\n                    elem.gradient = key;\n\n                    // Allow the color to be concatenated into tooltips formatters etc. (#2995)\n                    color.toString = function() {\n                        return value;\n                    };\n                }\n            },\n\n            /**\n             * Apply a text outline through a custom CSS property, by copying the text\n             * element and apply stroke to the copy. Used internally. Contrast checks\n             * at http://jsfiddle.net/highcharts/43soe9m1/2/ .\n             *\n             * @private\n             * @param {String} textOutline A custom CSS `text-outline` setting, defined\n             *    by `width color`. \n             * @example\n             * // Specific color\n             * text.css({\n             *    textOutline: '1px black'\n             * });\n             * // Automatic contrast\n             * text.css({\n             *    color: '#000000', // black text\n             *    textOutline: '1px contrast' // => white outline\n             * });\n             */\n            applyTextOutline: function(textOutline) {\n                var elem = this.element,\n                    tspans,\n                    tspan,\n                    hasContrast = textOutline.indexOf('contrast') !== -1,\n                    styles = {},\n                    color,\n                    strokeWidth,\n                    firstRealChild,\n                    i;\n\n                // When the text shadow is set to contrast, use dark stroke for light\n                // text and vice versa.\n                if (hasContrast) {\n                    styles.textOutline = textOutline = textOutline.replace(\n                        /contrast/g,\n                        this.renderer.getContrast(elem.style.fill)\n                    );\n                }\n\n                // Extract the stroke width and color\n                textOutline = textOutline.split(' ');\n                color = textOutline[textOutline.length - 1];\n                strokeWidth = textOutline[0];\n\n                if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n\n                    this.fakeTS = true; // Fake text shadow\n\n                    tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\n                    // In order to get the right y position of the clone,\n                    // copy over the y setter\n                    this.ySetter = this.xSetter;\n\n                    // Since the stroke is applied on center of the actual outline, we\n                    // need to double it to get the correct stroke-width outside the \n                    // glyphs.\n                    strokeWidth = strokeWidth.replace(\n                        /(^[\\d\\.]+)(.*?)$/g,\n                        function(match, digit, unit) {\n                            return (2 * digit) + unit;\n                        }\n                    );\n\n                    // Remove shadows from previous runs. Iterate from the end to\n                    // support removing items inside the cycle (#6472).\n                    i = tspans.length;\n                    while (i--) {\n                        tspan = tspans[i];\n                        if (tspan.getAttribute('class') === 'highcharts-text-outline') {\n                            // Remove then erase\n                            erase(tspans, elem.removeChild(tspan));\n                        }\n                    }\n\n                    // For each of the tspans, create a stroked copy behind it.\n                    firstRealChild = elem.firstChild;\n                    each(tspans, function(tspan, y) {\n                        var clone;\n\n                        // Let the first line start at the correct X position\n                        if (y === 0) {\n                            tspan.setAttribute('x', elem.getAttribute('x'));\n                            y = elem.getAttribute('y');\n                            tspan.setAttribute('y', y || 0);\n                            if (y === null) {\n                                elem.setAttribute('y', 0);\n                            }\n                        }\n\n                        // Create the clone and apply outline properties\n                        clone = tspan.cloneNode(1);\n                        attr(clone, {\n                            'class': 'highcharts-text-outline',\n                            'fill': color,\n                            'stroke': color,\n                            'stroke-width': strokeWidth,\n                            'stroke-linejoin': 'round'\n                        });\n                        elem.insertBefore(clone, firstRealChild);\n                    });\n                }\n            },\n\n            /**\n             *\n             * @typedef {Object} SVGAttributes An object of key-value pairs for SVG\n             *   attributes. Attributes in Highcharts elements for the most parts\n             *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,\n             *   `rotation`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n             *   attributes containing a hyphen are _not_ camel-cased, they should be\n             *   quoted to preserve the hyphen.\n             * @example\n             * {\n             *     'stroke': '#ff0000', // basic\n             *     'stroke-width': 2, // hyphenated\n             *     'rotation': 45 // custom\n             *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n             * }\n             */\n            /**\n             * Apply native and custom attributes to the SVG elements.\n             * \n             * In order to set the rotation center for rotation, set x and y to 0 and\n             * use `translateX` and `translateY` attributes to position the element\n             * instead.\n             *\n             * Attributes frequently used in Highcharts are `fill`, `stroke`,\n             * `stroke-width`.\n             *\n             * @param {SVGAttributes|String} hash - The native and custom SVG\n             *    attributes. \n             * @param {string} [val] - If the type of the first argument is `string`, \n             *    the second can be a value, which will serve as a single attribute\n             *    setter. If the first argument is a string and the second is undefined,\n             *    the function serves as a getter and the current value of the property\n             *    is returned.\n             * @param {Function} [complete] - A callback function to execute after setting\n             *    the attributes. This makes the function compliant and interchangeable\n             *    with the {@link SVGElement#animate} function.\n             * @param {boolean} [continueAnimation=true] Used internally when `.attr` is\n             *    called as part of an animation step. Otherwise, calling `.attr` for an\n             *    attribute will stop animation for that attribute.\n             *    \n             * @returns {SVGElement|string|number} If used as a setter, it returns the \n             *    current {@link SVGElement} so the calls can be chained. If used as a \n             *    getter, the current value of the attribute is returned.\n             *\n             * @sample highcharts/members/renderer-rect/\n             *         Setting some attributes\n             * \n             * @example\n             * // Set multiple attributes\n             * element.attr({\n             *     stroke: 'red',\n             *     fill: 'blue',\n             *     x: 10,\n             *     y: 10\n             * });\n             *\n             * // Set a single attribute\n             * element.attr('stroke', 'red');\n             *\n             * // Get an attribute\n             * element.attr('stroke'); // => 'red'\n             * \n             */\n            attr: function(hash, val, complete, continueAnimation) {\n                var key,\n                    element = this.element,\n                    hasSetSymbolSize,\n                    ret = this,\n                    skipAttr,\n                    setter;\n\n                // single key-value pair\n                if (typeof hash === 'string' && val !== undefined) {\n                    key = hash;\n                    hash = {};\n                    hash[key] = val;\n                }\n\n                // used as a getter: first argument is a string, second is undefined\n                if (typeof hash === 'string') {\n                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\n                    // setter\n                } else {\n\n                    objectEach(hash, function(val, key) {\n                        skipAttr = false;\n\n                        // Unless .attr is from the animator update, stop current\n                        // running animation of this property\n                        if (!continueAnimation) {\n                            stop(this, key);\n                        }\n\n                        // Special handling of symbol attributes\n                        if (\n                            this.symbolName &&\n                            /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/\n                            .test(key)\n                        ) {\n                            if (!hasSetSymbolSize) {\n                                this.symbolAttr(hash);\n                                hasSetSymbolSize = true;\n                            }\n                            skipAttr = true;\n                        }\n\n                        if (this.rotation && (key === 'x' || key === 'y')) {\n                            this.doTransform = true;\n                        }\n\n                        if (!skipAttr) {\n                            setter = this[key + 'Setter'] || this._defaultSetter;\n                            setter.call(this, val, key, element);\n\n\n                            // Let the shadow follow the main element\n                            if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n                                this.updateShadows(key, val, setter);\n                            }\n\n                        }\n                    }, this);\n\n                    this.afterSetters();\n                }\n\n                // In accordance with animate, run a complete callback\n                if (complete) {\n                    complete();\n                }\n\n                return ret;\n            },\n\n            /**\n             * This method is executed in the end of {attr}, after setting all attributes in the hash.\n             * In can be used to efficiently consolidate multiple attributes in one SVG property -- e.g.,\n             * translate, rotate and scale are merged in one \"transform\" attribute in the SVG node.\n             */\n            afterSetters: function() {\n                // Update transform. Do this outside the loop to prevent redundant updating for batch setting\n                // of attributes.\n                if (this.doTransform) {\n                    this.updateTransform();\n                    this.doTransform = false;\n                }\n            },\n\n\n            /**\n             * Update the shadow elements with new attributes.\n             *\n             * @private\n             * @param {String} key - The attribute name.\n             * @param {String|Number} value - The value of the attribute.\n             * @param {Function} setter - The setter function, inherited from the\n             *   parent wrapper\n             * @returns {void}\n             */\n            updateShadows: function(key, value, setter) {\n                var shadows = this.shadows,\n                    i = shadows.length;\n\n                while (i--) {\n                    setter.call(\n                        shadows[i],\n                        key === 'height' ?\n                        Math.max(value - (shadows[i].cutHeight || 0), 0) :\n                        key === 'd' ? this.d : value,\n                        key,\n                        shadows[i]\n                    );\n                }\n            },\n\n\n            /**\n             * Add a class name to an element.\n             *\n             * @param {string} className - The new class name to add.\n             * @param {boolean} [replace=false] - When true, the existing class name(s)\n             *    will be overwritten with the new one. When false, the new one is\n             *    added.\n             * @returns {Highcharts.SVGElement} Return the SVG element for chainability.\n             */\n            addClass: function(className, replace) {\n                var currentClassName = this.attr('class') || '';\n\n                if (currentClassName.indexOf(className) === -1) {\n                    if (!replace) {\n                        className =\n                            (currentClassName + (currentClassName ? ' ' : '') +\n                                className).replace('  ', ' ');\n                    }\n                    this.attr('class', className);\n                }\n                return this;\n            },\n\n            /**\n             * Check if an element has the given class name.\n             * @param  {string}  className - The class name to check for.\n             * @return {Boolean}\n             */\n            hasClass: function(className) {\n                return attr(this.element, 'class').indexOf(className) !== -1;\n            },\n\n            /**\n             * Remove a class name from the element.\n             * @param  {string} className The class name to remove.\n             * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n             */\n            removeClass: function(className) {\n                attr(this.element, 'class', (attr(this.element, 'class') || '').replace(className, ''));\n                return this;\n            },\n\n            /**\n             * If one of the symbol size affecting parameters are changed,\n             * check all the others only once for each call to an element's\n             * .attr() method\n             * @param {Object} hash - The attributes to set.\n             * @private\n             */\n            symbolAttr: function(hash) {\n                var wrapper = this;\n\n                each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function(key) {\n                    wrapper[key] = pick(hash[key], wrapper[key]);\n                });\n\n                wrapper.attr({\n                    d: wrapper.renderer.symbols[wrapper.symbolName](\n                        wrapper.x,\n                        wrapper.y,\n                        wrapper.width,\n                        wrapper.height,\n                        wrapper\n                    )\n                });\n            },\n\n            /**\n             * Apply a clipping rectangle to this element.\n             * \n             * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the\n             *    current clip is removed.\n             * @returns {Highcharts.SVGElement} Returns the SVG element to allow chaining.\n             */\n            clip: function(clipRect) {\n                return this.attr(\n                    'clip-path',\n                    clipRect ?\n                    'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n                    'none'\n                );\n            },\n\n            /**\n             * Calculate the coordinates needed for drawing a rectangle crisply and\n             * return the calculated attributes.\n             * \n             * @param {Object} rect - A rectangle.\n             * @param {number} rect.x - The x position.\n             * @param {number} rect.y - The y position.\n             * @param {number} rect.width - The width.\n             * @param {number} rect.height - The height.\n             * @param {number} [strokeWidth] - The stroke width to consider when\n             *    computing crisp positioning. It can also be set directly on the rect\n             *    parameter.\n             *\n             * @returns {{x: Number, y: Number, width: Number, height: Number}} The\n             *    modified rectangle arguments.\n             */\n            crisp: function(rect, strokeWidth) {\n\n                var wrapper = this,\n                    attribs = {},\n                    normalizer;\n\n                strokeWidth = strokeWidth || rect.strokeWidth || 0;\n                normalizer = Math.round(strokeWidth) % 2 / 2; // Math.round because strokeWidth can sometimes have roundoff errors\n\n                // normalize for crisp edges\n                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n                rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n                rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n                if (defined(rect.strokeWidth)) {\n                    rect.strokeWidth = strokeWidth;\n                }\n\n                objectEach(rect, function(val, key) {\n                    if (wrapper[key] !== val) { // only set attribute if changed\n                        wrapper[key] = attribs[key] = val;\n                    }\n                });\n\n                return attribs;\n            },\n\n            /**\n             * Set styles for the element. In addition to CSS styles supported by \n             * native SVG and HTML elements, there are also some custom made for \n             * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n             * elements.\n             * @param {CSSObject} styles The new CSS styles.\n             * @returns {Highcharts.SVGElement} Return the SVG element for chaining.\n             *\n             * @sample highcharts/members/renderer-text-on-chart/\n             *         Styled text\n             */\n            css: function(styles) {\n                var oldStyles = this.styles,\n                    newStyles = {},\n                    elem = this.element,\n                    textWidth,\n                    serializedCss = '',\n                    hyphenate,\n                    hasNew = !oldStyles,\n                    // These CSS properties are interpreted internally by the SVG\n                    // renderer, but are not supported by SVG and should not be added to\n                    // the DOM. In styled mode, no CSS should find its way to the DOM\n                    // whatsoever (#6173, #6474).\n                    svgPseudoProps = ['textOutline', 'textOverflow', 'width'];\n\n                // convert legacy\n                if (styles && styles.color) {\n                    styles.fill = styles.color;\n                }\n\n                // Filter out existing styles to increase performance (#2640)\n                if (oldStyles) {\n                    objectEach(styles, function(style, n) {\n                        if (style !== oldStyles[n]) {\n                            newStyles[n] = style;\n                            hasNew = true;\n                        }\n                    });\n                }\n                if (hasNew) {\n\n                    // Merge the new styles with the old ones\n                    if (oldStyles) {\n                        styles = extend(\n                            oldStyles,\n                            newStyles\n                        );\n                    }\n\n                    // Get the text width from style\n                    textWidth = this.textWidth = (\n                        styles &&\n                        styles.width &&\n                        styles.width !== 'auto' &&\n                        elem.nodeName.toLowerCase() === 'text' &&\n                        pInt(styles.width)\n                    );\n\n                    // store object\n                    this.styles = styles;\n\n                    if (textWidth && (!svg && this.renderer.forExport)) {\n                        delete styles.width;\n                    }\n\n                    // serialize and set style attribute\n                    if (isMS && !svg) {\n                        css(this.element, styles);\n                    } else {\n                        hyphenate = function(a, b) {\n                            return '-' + b.toLowerCase();\n                        };\n                        objectEach(styles, function(style, n) {\n                            if (inArray(n, svgPseudoProps) === -1) {\n                                serializedCss +=\n                                    n.replace(/([A-Z])/g, hyphenate) + ':' +\n                                    style + ';';\n                            }\n                        });\n                        if (serializedCss) {\n                            attr(elem, 'style', serializedCss); // #1881\n                        }\n                    }\n\n\n                    if (this.added) {\n\n                        // Rebuild text after added. Cache mechanisms in the buildText\n                        // will prevent building if there are no significant changes.\n                        if (this.element.nodeName === 'text') {\n                            this.renderer.buildText(this);\n                        }\n\n                        // Apply text outline after added\n                        if (styles && styles.textOutline) {\n                            this.applyTextOutline(styles.textOutline);\n                        }\n                    }\n                }\n\n                return this;\n            },\n\n\n            /**\n             * Get the current stroke width. In classic mode, the setter registers it \n             * directly on the element.\n             * @returns {number} The stroke width in pixels.\n             * @ignore\n             */\n            strokeWidth: function() {\n                return this['stroke-width'] || 0;\n            },\n\n\n            /**\n             * Add an event listener. This is a simple setter that replaces all other\n             * events of the same type, opposed to the {@link Highcharts#addEvent}\n             * function.\n             * @param {string} eventType - The event type. If the type is `click`, \n             *    Highcharts will internally translate it to a `touchstart` event on \n             *    touch devices, to prevent the browser from waiting for a click event\n             *    from firing.\n             * @param {Function} handler - The handler callback.\n             * @returns {Highcharts.SVGElement} The SVGElement for chaining.\n             *\n             * @sample highcharts/members/element-on/\n             *         A clickable rectangle\n             */\n            on: function(eventType, handler) {\n                var svgElement = this,\n                    element = svgElement.element;\n\n                // touch\n                if (hasTouch && eventType === 'click') {\n                    element.ontouchstart = function(e) {\n                        svgElement.touchEventFired = Date.now(); // #2269\n                        e.preventDefault();\n                        handler.call(element, e);\n                    };\n                    element.onclick = function(e) {\n                        if (win.navigator.userAgent.indexOf('Android') === -1 ||\n                            Date.now() - (svgElement.touchEventFired || 0) > 1100) {\n                            handler.call(element, e);\n                        }\n                    };\n                } else {\n                    // simplest possible event model for internal use\n                    element['on' + eventType] = handler;\n                }\n                return this;\n            },\n\n            /**\n             * Set the coordinates needed to draw a consistent radial gradient across\n             * a shape regardless of positioning inside the chart. Used on pie slices\n             * to make all the slices have the same radial reference point.\n             *\n             * @param {Array} coordinates The center reference. The format is\n             *    `[centerX, centerY, diameter]` in pixels.\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            setRadialReference: function(coordinates) {\n                var existingGradient = this.renderer.gradients[this.element.gradient];\n\n                this.element.radialReference = coordinates;\n\n                // On redrawing objects with an existing gradient, the gradient needs\n                // to be repositioned (#3801)\n                if (existingGradient && existingGradient.radAttr) {\n                    existingGradient.animate(\n                        this.renderer.getRadialAttr(\n                            coordinates,\n                            existingGradient.radAttr\n                        )\n                    );\n                }\n\n                return this;\n            },\n\n            /**\n             * Move an object and its children by x and y values.\n             * \n             * @param {number} x - The x value.\n             * @param {number} y - The y value.\n             */\n            translate: function(x, y) {\n                return this.attr({\n                    translateX: x,\n                    translateY: y\n                });\n            },\n\n            /**\n             * Invert a group, rotate and flip. This is used internally on inverted \n             * charts, where the points and graphs are drawn as if not inverted, then\n             * the series group elements are inverted.\n             *\n             * @param {boolean} inverted - Whether to invert or not. An inverted shape\n             *    can be un-inverted by setting it to false.\n             * @returns {Highcharts.SVGElement} Return the SVGElement for chaining.\n             */\n            invert: function(inverted) {\n                var wrapper = this;\n                wrapper.inverted = inverted;\n                wrapper.updateTransform();\n                return wrapper;\n            },\n\n            /**\n             * Update the transform attribute based on internal properties. Deals with\n             * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n             * attributes and updates the SVG `transform` attribute.\n             * @private\n             * @returns {void}\n             */\n            updateTransform: function() {\n                var wrapper = this,\n                    translateX = wrapper.translateX || 0,\n                    translateY = wrapper.translateY || 0,\n                    scaleX = wrapper.scaleX,\n                    scaleY = wrapper.scaleY,\n                    inverted = wrapper.inverted,\n                    rotation = wrapper.rotation,\n                    element = wrapper.element,\n                    transform;\n\n                // flipping affects translate as adjustment for flipping around the group's axis\n                if (inverted) {\n                    translateX += wrapper.width;\n                    translateY += wrapper.height;\n                }\n\n                // Apply translate. Nearly all transformed elements have translation, so instead\n                // of checking for translate = 0, do it always (#1767, #1846).\n                transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n                // apply rotation\n                if (inverted) {\n                    transform.push('rotate(90) scale(-1,1)');\n                } else if (rotation) { // text rotation\n                    transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n                    // Delete bBox memo when the rotation changes\n                    //delete wrapper.bBox;\n                }\n\n                // apply scale\n                if (defined(scaleX) || defined(scaleY)) {\n                    transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n                }\n\n                if (transform.length) {\n                    element.setAttribute('transform', transform.join(' '));\n                }\n            },\n\n            /**\n             * Bring the element to the front. Alternatively, a new zIndex can be set.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @sample highcharts/members/element-tofront/\n             *         Click an element to bring it to front\n             */\n            toFront: function() {\n                var element = this.element;\n                element.parentNode.appendChild(element);\n                return this;\n            },\n\n\n            /**\n             * Align the element relative to the chart or another box.\n             * \n             * @param {Object} [alignOptions] The alignment options. The function can be\n             *   called without this parameter in order to re-align an element after the\n             *   box has been updated.\n             * @param {string} [alignOptions.align=left] Horizontal alignment. Can be\n             *   one of `left`, `center` and `right`.\n             * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can\n             *   be one of `top`, `middle` and `bottom`.\n             * @param {number} [alignOptions.x=0] Horizontal pixel offset from\n             *   alignment.\n             * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.\n             * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute\n             *   with translateX and translateY custom attributes to align this elements\n             *   rather than `x` and `y` attributes.\n             * @param {String|Object} box The box to align to, needs a width and height.\n             *   When the box is a string, it refers to an object in the Renderer. For\n             *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`\n             *   which holds `width`, `height`, `x` and `y` properties.\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            align: function(alignOptions, alignByTranslate, box) {\n                var align,\n                    vAlign,\n                    x,\n                    y,\n                    attribs = {},\n                    alignTo,\n                    renderer = this.renderer,\n                    alignedObjects = renderer.alignedObjects,\n                    alignFactor,\n                    vAlignFactor;\n\n                // First call on instanciate\n                if (alignOptions) {\n                    this.alignOptions = alignOptions;\n                    this.alignByTranslate = alignByTranslate;\n                    if (!box || isString(box)) { // boxes other than renderer handle this internally\n                        this.alignTo = alignTo = box || 'renderer';\n                        erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                        alignedObjects.push(this);\n                        box = null; // reassign it below\n                    }\n\n                    // When called on resize, no arguments are supplied\n                } else {\n                    alignOptions = this.alignOptions;\n                    alignByTranslate = this.alignByTranslate;\n                    alignTo = this.alignTo;\n                }\n\n                box = pick(box, renderer[alignTo], renderer);\n\n                // Assign variables\n                align = alignOptions.align;\n                vAlign = alignOptions.verticalAlign;\n                x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n                y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n                // Align\n                if (align === 'right') {\n                    alignFactor = 1;\n                } else if (align === 'center') {\n                    alignFactor = 2;\n                }\n                if (alignFactor) {\n                    x += (box.width - (alignOptions.width || 0)) / alignFactor;\n                }\n                attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n                // Vertical align\n                if (vAlign === 'bottom') {\n                    vAlignFactor = 1;\n                } else if (vAlign === 'middle') {\n                    vAlignFactor = 2;\n                }\n                if (vAlignFactor) {\n                    y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n                }\n                attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n                // Animate only if already placed\n                this[this.placed ? 'animate' : 'attr'](attribs);\n                this.placed = true;\n                this.alignAttr = attribs;\n\n                return this;\n            },\n\n            /**\n             * Get the bounding box (width, height, x and y) for the element. Generally\n             * used to get rendered text size. Since this is called a lot in charts,\n             * the results are cached based on text properties, in order to save DOM\n             * traffic. The returned bounding box includes the rotation, so for example\n             * a single text line of rotation 90 will report a greater height, and a\n             * width corresponding to the line-height.\n             *\n             * @param {boolean} [reload] Skip the cache and get the updated DOM bouding\n             *   box.\n             * @param {number} [rot] Override the element's rotation. This is internally\n             *   used on axis labels with a value of 0 to find out what the bounding box\n             *   would be have been if it were not rotated.\n             * @returns {Object} The bounding box with `x`, `y`, `width` and `height`\n             * properties.\n             *\n             * @sample highcharts/members/renderer-on-chart/\n             *         Draw a rectangle based on a text's bounding box\n             */\n            getBBox: function(reload, rot) {\n                var wrapper = this,\n                    bBox, // = wrapper.bBox,\n                    renderer = wrapper.renderer,\n                    width,\n                    height,\n                    rotation,\n                    rad,\n                    element = wrapper.element,\n                    styles = wrapper.styles,\n                    fontSize,\n                    textStr = wrapper.textStr,\n                    toggleTextShadowShim,\n                    cache = renderer.cache,\n                    cacheKeys = renderer.cacheKeys,\n                    cacheKey;\n\n                rotation = pick(rot, wrapper.rotation);\n                rad = rotation * deg2rad;\n\n\n                fontSize = styles && styles.fontSize;\n\n\n                if (textStr !== undefined) {\n\n                    cacheKey = textStr.toString();\n\n                    // Since numbers are monospaced, and numerical labels appear a lot\n                    // in a chart, we assume that a label of n characters has the same\n                    // bounding box as others of the same length. Unless there is inner\n                    // HTML in the label. In that case, leave the numbers as is (#5899).\n                    if (cacheKey.indexOf('<') === -1) {\n                        cacheKey = cacheKey.replace(/[0-9]/g, '0');\n                    }\n\n                    // Properties that affect bounding box\n                    cacheKey += [\n                            '',\n                            rotation || 0,\n                            fontSize,\n                            styles && styles.width,\n                            styles && styles.textOverflow // #5968\n                        ]\n                        .join(',');\n\n                }\n\n                if (cacheKey && !reload) {\n                    bBox = cache[cacheKey];\n                }\n\n                // No cache found\n                if (!bBox) {\n\n                    // SVG elements\n                    if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n                        try { // Fails in Firefox if the container has display: none.\n\n                            // When the text shadow shim is used, we need to hide the fake shadows\n                            // to get the correct bounding box (#3872)\n                            toggleTextShadowShim = this.fakeTS && function(display) {\n                                each(element.querySelectorAll('.highcharts-text-outline'), function(tspan) {\n                                    tspan.style.display = display;\n                                });\n                            };\n\n                            // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                            if (toggleTextShadowShim) {\n                                toggleTextShadowShim('none');\n                            }\n\n                            bBox = element.getBBox ?\n                                // SVG: use extend because IE9 is not allowed to change width and height in case\n                                // of rotation (below)\n                                extend({}, element.getBBox()) : {\n\n                                    // Legacy IE in export mode\n                                    width: element.offsetWidth,\n                                    height: element.offsetHeight\n                                };\n\n                            // #3842\n                            if (toggleTextShadowShim) {\n                                toggleTextShadowShim('');\n                            }\n                        } catch (e) {}\n\n                        // If the bBox is not set, the try-catch block above failed. The other condition\n                        // is for Opera that returns a width of -Infinity on hidden elements.\n                        if (!bBox || bBox.width < 0) {\n                            bBox = {\n                                width: 0,\n                                height: 0\n                            };\n                        }\n\n\n                        // VML Renderer or useHTML within SVG\n                    } else {\n\n                        bBox = wrapper.htmlGetBBox();\n\n                    }\n\n                    // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n                    // need to compensated for rotation\n                    if (renderer.isSVG) {\n                        width = bBox.width;\n                        height = bBox.height;\n\n                        // Workaround for wrong bounding box in IE, Edge and Chrome on\n                        // Windows. With Highcharts' default font, IE and Edge report\n                        // a box height of 16.899 and Chrome rounds it to 17. If this \n                        // stands uncorrected, it results in more padding added below\n                        // the text than above when adding a label border or background.\n                        // Also vertical positioning is affected.\n                        // http://jsfiddle.net/highcharts/em37nvuj/\n                        // (#1101, #1505, #1669, #2568, #6213).\n                        if (\n                            styles &&\n                            styles.fontSize === '11px' &&\n                            Math.round(height) === 17\n                        ) {\n                            bBox.height = height = 14;\n                        }\n\n                        // Adjust for rotated text\n                        if (rotation) {\n                            bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n                            bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n                        }\n                    }\n\n                    // Cache it. When loading a chart in a hidden iframe in Firefox and IE/Edge, the\n                    // bounding box height is 0, so don't cache it (#5620).\n                    if (cacheKey && bBox.height > 0) {\n\n                        // Rotate (#4681)\n                        while (cacheKeys.length > 250) {\n                            delete cache[cacheKeys.shift()];\n                        }\n\n                        if (!cache[cacheKey]) {\n                            cacheKeys.push(cacheKey);\n                        }\n                        cache[cacheKey] = bBox;\n                    }\n                }\n                return bBox;\n            },\n\n            /**\n             * Show the element after it has been hidden. \n             *\n             * @param {boolean} [inherit=false] Set the visibility attribute to\n             * `inherit` rather than `visible`. The difference is that an element with\n             * `visibility=\"visible\"` will be visible even if the parent is hidden.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            show: function(inherit) {\n                return this.attr({\n                    visibility: inherit ? 'inherit' : 'visible'\n                });\n            },\n\n            /**\n             * Hide the element, equivalent to setting the `visibility` attribute to\n             * `hidden`.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            hide: function() {\n                return this.attr({\n                    visibility: 'hidden'\n                });\n            },\n\n            /**\n             * Fade out an element by animating its opacity down to 0, and hide it on\n             * complete. Used internally for the tooltip.\n             * \n             * @param {number} [duration=150] The fade duration in milliseconds.\n             */\n            fadeOut: function(duration) {\n                var elemWrapper = this;\n                elemWrapper.animate({\n                    opacity: 0\n                }, {\n                    duration: duration || 150,\n                    complete: function() {\n                        elemWrapper.attr({\n                            y: -9999\n                        }); // #3088, assuming we're only using this for tooltips\n                    }\n                });\n            },\n\n            /**\n             * Add the element to the DOM. All elements must be added this way.\n             * \n             * @param {Highcharts.SVGElement|SVGDOMElement} [parent] The parent item to add it to.\n             *   If undefined, the element is added to the {@link\n             *   Highcharts.SVGRenderer.box}.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @sample highcharts/members/renderer-g - Elements added to a group\n             */\n            add: function(parent) {\n\n                var renderer = this.renderer,\n                    element = this.element,\n                    inserted;\n\n                if (parent) {\n                    this.parentGroup = parent;\n                }\n\n                // mark as inverted\n                this.parentInverted = parent && parent.inverted;\n\n                // build formatted text\n                if (this.textStr !== undefined) {\n                    renderer.buildText(this);\n                }\n\n                // Mark as added\n                this.added = true;\n\n                // If we're adding to renderer root, or other elements in the group\n                // have a z index, we need to handle it\n                if (!parent || parent.handleZ || this.zIndex) {\n                    inserted = this.zIndexSetter();\n                }\n\n                // If zIndex is not handled, append at the end\n                if (!inserted) {\n                    (parent ? parent.element : renderer.box).appendChild(element);\n                }\n\n                // fire an event for internal hooks\n                if (this.onAdd) {\n                    this.onAdd();\n                }\n\n                return this;\n            },\n\n            /**\n             * Removes an element from the DOM.\n             *\n             * @private\n             * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.\n             */\n            safeRemoveChild: function(element) {\n                var parentNode = element.parentNode;\n                if (parentNode) {\n                    parentNode.removeChild(element);\n                }\n            },\n\n            /**\n             * Destroy the element and element wrapper and clear up the DOM and event\n             * hooks.\n             *\n             * @returns {void}\n             */\n            destroy: function() {\n                var wrapper = this,\n                    element = wrapper.element || {},\n                    parentToClean =\n                    wrapper.renderer.isSVG &&\n                    element.nodeName === 'SPAN' &&\n                    wrapper.parentGroup,\n                    grandParent,\n                    ownerSVGElement = element.ownerSVGElement,\n                    i;\n\n                // remove events\n                element.onclick = element.onmouseout = element.onmouseover =\n                    element.onmousemove = element.point = null;\n                stop(wrapper); // stop running animations\n\n                if (wrapper.clipPath && ownerSVGElement) {\n                    // Look for existing references to this clipPath and remove them\n                    // before destroying the element (#6196).\n                    each(\n                        ownerSVGElement.querySelectorAll('[clip-path]'),\n                        function(el) {\n                            // Include the closing paranthesis in the test to rule out\n                            // id's from 10 and above (#6550)\n                            if (el.getAttribute('clip-path')\n                                .indexOf(wrapper.clipPath.element.id + ')') > -1) {\n                                el.removeAttribute('clip-path');\n                            }\n                        }\n                    );\n                    wrapper.clipPath = wrapper.clipPath.destroy();\n                }\n\n                // Destroy stops in case this is a gradient object\n                if (wrapper.stops) {\n                    for (i = 0; i < wrapper.stops.length; i++) {\n                        wrapper.stops[i] = wrapper.stops[i].destroy();\n                    }\n                    wrapper.stops = null;\n                }\n\n                // remove element\n                wrapper.safeRemoveChild(element);\n\n\n                wrapper.destroyShadows();\n\n\n                // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n                while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n                    grandParent = parentToClean.parentGroup;\n                    wrapper.safeRemoveChild(parentToClean.div);\n                    delete parentToClean.div;\n                    parentToClean = grandParent;\n                }\n\n                // remove from alignObjects\n                if (wrapper.alignTo) {\n                    erase(wrapper.renderer.alignedObjects, wrapper);\n                }\n\n                objectEach(wrapper, function(val, key) {\n                    delete wrapper[key];\n                });\n\n                return null;\n            },\n\n\n            /**\n             * @typedef {Object} ShadowOptions\n             * @property {string} [color=#000000] The shadow color.\n             * @property {number} [offsetX=1] The horizontal offset from the element.\n             * @property {number} [offsetY=1] The vertical offset from the element.\n             * @property {number} [opacity=0.15] The shadow opacity.\n             * @property {number} [width=3] The shadow width or distance from the\n             *    element.\n             */\n            /**\n             * Add a shadow to the element. Must be called after the element is added to\n             * the DOM. In styled mode, this method is not used, instead use `defs` and\n             * filters.\n             * \n             * @param {boolean|ShadowOptions} shadowOptions The shadow options. If\n             *    `true`, the default options are applied. If `false`, the current\n             *    shadow will be removed.\n             * @param {Highcharts.SVGElement} [group] The SVG group element where the shadows will \n             *    be applied. The default is to add it to the same parent as the current\n             *    element. Internally, this is ised for pie slices, where all the\n             *    shadows are added to an element behind all the slices.\n             * @param {boolean} [cutOff] Used internally for column shadows.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @example\n             * renderer.rect(10, 100, 100, 100)\n             *     .attr({ fill: 'red' })\n             *     .shadow(true);\n             */\n            shadow: function(shadowOptions, group, cutOff) {\n                var shadows = [],\n                    i,\n                    shadow,\n                    element = this.element,\n                    strokeWidth,\n                    shadowWidth,\n                    shadowElementOpacity,\n\n                    // compensate for inverted plot area\n                    transform;\n\n                if (!shadowOptions) {\n                    this.destroyShadows();\n\n                } else if (!this.shadows) {\n                    shadowWidth = pick(shadowOptions.width, 3);\n                    shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                    transform = this.parentInverted ?\n                        '(-1,-1)' :\n                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n                    for (i = 1; i <= shadowWidth; i++) {\n                        shadow = element.cloneNode(0);\n                        strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                        attr(shadow, {\n                            'isShadow': 'true',\n                            'stroke': shadowOptions.color || '#000000',\n                            'stroke-opacity': shadowElementOpacity * i,\n                            'stroke-width': strokeWidth,\n                            'transform': 'translate' + transform,\n                            'fill': 'none'\n                        });\n                        if (cutOff) {\n                            attr(shadow, 'height', Math.max(attr(shadow, 'height') - strokeWidth, 0));\n                            shadow.cutHeight = strokeWidth;\n                        }\n\n                        if (group) {\n                            group.element.appendChild(shadow);\n                        } else {\n                            element.parentNode.insertBefore(shadow, element);\n                        }\n\n                        shadows.push(shadow);\n                    }\n\n                    this.shadows = shadows;\n                }\n                return this;\n\n            },\n\n            /**\n             * Destroy shadows on the element.\n             * @private\n             */\n            destroyShadows: function() {\n                each(this.shadows || [], function(shadow) {\n                    this.safeRemoveChild(shadow);\n                }, this);\n                this.shadows = undefined;\n            },\n\n\n\n            xGetter: function(key) {\n                if (this.element.nodeName === 'circle') {\n                    if (key === 'x') {\n                        key = 'cx';\n                    } else if (key === 'y') {\n                        key = 'cy';\n                    }\n                }\n                return this._defaultGetter(key);\n            },\n\n            /**\n             * Get the current value of an attribute or pseudo attribute, used mainly\n             * for animation. Called internally from the {@link\n             * Highcharts.SVGRenderer#attr}\n             * function.\n             *\n             * @private\n             */\n            _defaultGetter: function(key) {\n                var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n                if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n                    ret = parseFloat(ret);\n                }\n                return ret;\n            },\n\n\n            dSetter: function(value, key, element) {\n                if (value && value.join) { // join path\n                    value = value.join(' ');\n                }\n                if (/(NaN| {2}|^$)/.test(value)) {\n                    value = 'M 0 0';\n                }\n                element.setAttribute(key, value);\n\n                this[key] = value;\n            },\n\n            dashstyleSetter: function(value) {\n                var i,\n                    strokeWidth = this['stroke-width'];\n\n                // If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new strokeWidth \n                // function, we should be able to use that instead.\n                if (strokeWidth === 'inherit') {\n                    strokeWidth = 1;\n                }\n                value = value && value.toLowerCase();\n                if (value) {\n                    value = value\n                        .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                        .replace('shortdashdot', '3,1,1,1')\n                        .replace('shortdot', '1,1,')\n                        .replace('shortdash', '3,1,')\n                        .replace('longdash', '8,3,')\n                        .replace(/dot/g, '1,3,')\n                        .replace('dash', '4,3,')\n                        .replace(/,$/, '')\n                        .split(','); // ending comma\n\n                    i = value.length;\n                    while (i--) {\n                        value[i] = pInt(value[i]) * strokeWidth;\n                    }\n                    value = value.join(',')\n                        .replace(/NaN/g, 'none'); // #3226\n                    this.element.setAttribute('stroke-dasharray', value);\n                }\n            },\n\n            alignSetter: function(value) {\n                var convert = {\n                    left: 'start',\n                    center: 'middle',\n                    right: 'end'\n                };\n                this.element.setAttribute('text-anchor', convert[value]);\n            },\n            opacitySetter: function(value, key, element) {\n                this[key] = value;\n                element.setAttribute(key, value);\n            },\n            titleSetter: function(value) {\n                var titleNode = this.element.getElementsByTagName('title')[0];\n                if (!titleNode) {\n                    titleNode = doc.createElementNS(this.SVG_NS, 'title');\n                    this.element.appendChild(titleNode);\n                }\n\n                // Remove text content if it exists\n                if (titleNode.firstChild) {\n                    titleNode.removeChild(titleNode.firstChild);\n                }\n\n                titleNode.appendChild(\n                    doc.createTextNode(\n                        (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n                    )\n                );\n            },\n            textSetter: function(value) {\n                if (value !== this.textStr) {\n                    // Delete bBox memo when the text changes\n                    delete this.bBox;\n\n                    this.textStr = value;\n                    if (this.added) {\n                        this.renderer.buildText(this);\n                    }\n                }\n            },\n            fillSetter: function(value, key, element) {\n                if (typeof value === 'string') {\n                    element.setAttribute(key, value);\n                } else if (value) {\n                    this.colorGradient(value, key, element);\n                }\n            },\n            visibilitySetter: function(value, key, element) {\n                // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n                if (value === 'inherit') {\n                    element.removeAttribute(key);\n                } else {\n                    element.setAttribute(key, value);\n                }\n            },\n            zIndexSetter: function(value, key) {\n                var renderer = this.renderer,\n                    parentGroup = this.parentGroup,\n                    parentWrapper = parentGroup || renderer,\n                    parentNode = parentWrapper.element || renderer.box,\n                    childNodes,\n                    otherElement,\n                    otherZIndex,\n                    element = this.element,\n                    inserted,\n                    run = this.added,\n                    i;\n\n                if (defined(value)) {\n                    element.zIndex = value; // So we can read it for other elements in the group\n                    value = +value;\n                    if (this[key] === value) { // Only update when needed (#3865)\n                        run = false;\n                    }\n                    this[key] = value;\n                }\n\n                // Insert according to this and other elements' zIndex. Before .add() is called,\n                // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n                // is placed on the right place in the DOM.\n                if (run) {\n                    value = this.zIndex;\n\n                    if (value && parentGroup) {\n                        parentGroup.handleZ = true;\n                    }\n\n                    childNodes = parentNode.childNodes;\n                    for (i = 0; i < childNodes.length && !inserted; i++) {\n                        otherElement = childNodes[i];\n                        otherZIndex = otherElement.zIndex;\n                        if (otherElement !== element && (\n                                // Insert before the first element with a higher zIndex\n                                pInt(otherZIndex) > value ||\n                                // If no zIndex given, insert before the first element with a zIndex\n                                (!defined(value) && defined(otherZIndex)) ||\n                                // Negative zIndex versus no zIndex:\n                                // On all levels except the highest. If the parent is <svg>,\n                                // then we don't want to put items before <desc> or <defs>\n                                (value < 0 && !defined(otherZIndex) && parentNode !== renderer.box)\n\n                            )) {\n                            parentNode.insertBefore(element, otherElement);\n                            inserted = true;\n                        }\n                    }\n                    if (!inserted) {\n                        parentNode.appendChild(element);\n                    }\n                }\n                return inserted;\n            },\n            _defaultSetter: function(value, key, element) {\n                element.setAttribute(key, value);\n            }\n        });\n\n        // Some shared setters and getters\n        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function(value, key) {\n                this[key] = value;\n                this.doTransform = true;\n            };\n\n\n        // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n        // stroke attribute altogether. #1270, #1369, #3065, #3072.\n        SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function(value, key, element) {\n            this[key] = value;\n            // Only apply the stroke attribute if the stroke width is defined and larger than 0\n            if (this.stroke && this['stroke-width']) {\n                SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n                element.setAttribute('stroke-width', this['stroke-width']);\n                this.hasStroke = true;\n            } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n                element.removeAttribute('stroke');\n                this.hasStroke = false;\n            }\n        };\n\n\n        /**\n         * Allows direct access to the Highcharts rendering layer in order to draw\n         * primitive shapes like circles, rectangles, paths or text directly on a chart,\n         * or independent from any chart. The SVGRenderer represents a wrapper object\n         * for SVGin modern browsers and through the VMLRenderer, for VML in IE < 8.\n         *\n         * An existing chart's renderer can be accessed through {@link Chart#renderer}.\n         * The renderer can also be used completely decoupled from a chart.\n         *\n         * @param {HTMLDOMElement} container - Where to put the SVG in the web page.\n         * @param {number} width - The width of the SVG.\n         * @param {number} height - The height of the SVG.\n         * @param {boolean} [forExport=false] - Whether the rendered content is intended\n         *   for export.\n         * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to\n         *   include HTML text, which will be projected on top of the SVG.\n         *\n         * @example\n         * // Use directly without a chart object.\n         * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n         *\n         * @sample highcharts/members/renderer-on-chart - Annotating a chart programmatically.\n         * @sample highcharts/members/renderer-basic - Independedt SVG drawing.\n         *\n         * @class Highcharts.SVGRenderer\n         */\n        SVGRenderer = H.SVGRenderer = function() {\n            this.init.apply(this, arguments);\n        };\n        extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {\n            /**\n             * A pointer to the renderer's associated Element class. The VMLRenderer\n             * will have a pointer to VMLElement here.\n             * @type {Highcharts.SVGElement}\n             */\n            Element: SVGElement,\n            SVG_NS: SVG_NS,\n            /**\n             * Initialize the SVGRenderer. Overridable initiator function that takes\n             * the same parameters as the constructor.\n             */\n            init: function(container, width, height, style, forExport, allowHTML) {\n                var renderer = this,\n                    boxWrapper,\n                    element,\n                    desc;\n\n                boxWrapper = renderer.createElement('svg')\n                    .attr({\n                        'version': '1.1',\n                        'class': 'highcharts-root'\n                    })\n\n                    .css(this.getStyle(style));\n                element = boxWrapper.element;\n                container.appendChild(element);\n\n                // For browsers other than IE, add the namespace attribute (#1978)\n                if (container.innerHTML.indexOf('xmlns') === -1) {\n                    attr(element, 'xmlns', this.SVG_NS);\n                }\n\n                // object properties\n                renderer.isSVG = true;\n\n                /** \n                 * The root `svg` node of the renderer.\n                 * @type {SVGDOMElement}\n                 */\n                this.box = element;\n                /** \n                 * The wrapper for the root `svg` node of the renderer.\n                 * @type {Highcharts.SVGElement}\n                 */\n                this.boxWrapper = boxWrapper;\n                renderer.alignedObjects = [];\n\n                /**\n                 * Page url used for internal references.\n                 * @type {string}\n                 */\n                // #24, #672, #1070\n                this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                    win.location.href\n                    .replace(/#.*?$/, '') // remove the hash\n                    .replace(/<[^>]*>/g, '') // wing cut HTML\n                    .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                    .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                    '';\n\n                // Add description\n                desc = this.createElement('desc').add();\n                desc.element.appendChild(doc.createTextNode('Created with Highcharts 5.0.12'));\n\n\n                renderer.defs = this.createElement('defs').add();\n                renderer.allowHTML = allowHTML;\n                renderer.forExport = forExport;\n                renderer.gradients = {}; // Object where gradient SvgElements are stored\n                renderer.cache = {}; // Cache for numerical bounding boxes\n                renderer.cacheKeys = [];\n                renderer.imgCount = 0;\n\n                renderer.setSize(width, height, false);\n\n\n\n                // Issue 110 workaround:\n                // In Firefox, if a div is positioned by percentage, its pixel position may land\n                // between pixels. The container itself doesn't display this, but an SVG element\n                // inside this container will be drawn at subpixel precision. In order to draw\n                // sharp lines, this must be compensated for. This doesn't seem to work inside\n                // iframes though (like in jsFiddle).\n                var subPixelFix, rect;\n                if (isFirefox && container.getBoundingClientRect) {\n                    subPixelFix = function() {\n                        css(container, {\n                            left: 0,\n                            top: 0\n                        });\n                        rect = container.getBoundingClientRect();\n                        css(container, {\n                            left: (Math.ceil(rect.left) - rect.left) + 'px',\n                            top: (Math.ceil(rect.top) - rect.top) + 'px'\n                        });\n                    };\n\n                    // run the fix now\n                    subPixelFix();\n\n                    // run it on resize\n                    renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n                }\n            },\n\n\n\n            /**\n             * Get the global style setting for the renderer.\n             * @private\n             * @param  {CSSObject} style - Style settings.\n             * @return {CSSObject} The style settings mixed with defaults.\n             */\n            getStyle: function(style) {\n                this.style = extend({\n\n                    fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n                    fontSize: '12px'\n\n                }, style);\n                return this.style;\n            },\n            /**\n             * Apply the global style on the renderer, mixed with the default styles.\n             * @param {CSSObject} style - CSS to apply.\n             */\n            setStyle: function(style) {\n                this.boxWrapper.css(this.getStyle(style));\n            },\n\n\n            /**\n             * Detect whether the renderer is hidden. This happens when one of the\n             * parent elements has display: none. Used internally to detect when we need\n             * to render preliminarily in another div to get the text bounding boxes \n             * right.\n             *\n             * @returns {boolean} True if it is hidden.\n             */\n            isHidden: function() { // #608\n                return !this.boxWrapper.getBBox().width;\n            },\n\n            /**\n             * Destroys the renderer and its allocated members.\n             */\n            destroy: function() {\n                var renderer = this,\n                    rendererDefs = renderer.defs;\n                renderer.box = null;\n                renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n                // Call destroy on all gradient elements\n                destroyObjectProperties(renderer.gradients || {});\n                renderer.gradients = null;\n\n                // Defs are null in VMLRenderer\n                // Otherwise, destroy them here.\n                if (rendererDefs) {\n                    renderer.defs = rendererDefs.destroy();\n                }\n\n                // Remove sub pixel fix handler (#982)\n                if (renderer.unSubPixelFix) {\n                    renderer.unSubPixelFix();\n                }\n\n                renderer.alignedObjects = null;\n\n                return null;\n            },\n\n            /**\n             * Create a wrapper for an SVG element. Serves as a factory for \n             * {@link SVGElement}, but this function is itself mostly called from \n             * primitive factories like {@link SVGRenderer#path}, {@link\n             * SVGRenderer#rect} or {@link SVGRenderer#text}.\n             * \n             * @param {string} nodeName - The node name, for example `rect`, `g` etc.\n             * @returns {Highcharts.SVGElement} The generated SVGElement.\n             */\n            createElement: function(nodeName) {\n                var wrapper = new this.Element();\n                wrapper.init(this, nodeName);\n                return wrapper;\n            },\n\n            /**\n             * Dummy function for plugins, called every time the renderer is updated.\n             * Prior to Highcharts 5, this was used for the canvg renderer.\n             * @function\n             */\n            draw: noop,\n\n            /**\n             * Get converted radial gradient attributes according to the radial\n             * reference. Used internally from the {@link SVGElement#colorGradient}\n             * function.\n             *\n             * @private\n             */\n            getRadialAttr: function(radialReference, gradAttr) {\n                return {\n                    cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n                    cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n                    r: gradAttr.r * radialReference[2]\n                };\n            },\n\n            getSpanWidth: function(wrapper, tspan) {\n                var renderer = this,\n                    bBox = wrapper.getBBox(true),\n                    actualWidth = bBox.width;\n\n                // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                if (!svg && renderer.forExport) {\n                    actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                }\n                return actualWidth;\n            },\n\n            applyEllipsis: function(wrapper, tspan, text, width) {\n                var renderer = this,\n                    actualWidth = renderer.getSpanWidth(wrapper, tspan),\n                    wasTooLong = actualWidth > width,\n                    str = text,\n                    currentIndex,\n                    minIndex = 0,\n                    maxIndex = text.length,\n                    updateTSpan = function(s) {\n                        tspan.removeChild(tspan.firstChild);\n                        if (s) {\n                            tspan.appendChild(doc.createTextNode(s));\n                        }\n                    };\n                if (wasTooLong) {\n                    while (minIndex <= maxIndex) {\n                        currentIndex = Math.ceil((minIndex + maxIndex) / 2);\n                        str = text.substring(0, currentIndex) + '\\u2026';\n                        updateTSpan(str);\n                        actualWidth = renderer.getSpanWidth(wrapper, tspan);\n                        if (minIndex === maxIndex) {\n                            // Complete\n                            minIndex = maxIndex + 1;\n                        } else if (actualWidth > width) {\n                            // Too large. Set max index to current.\n                            maxIndex = currentIndex - 1;\n                        } else {\n                            // Within width. Set min index to current.\n                            minIndex = currentIndex;\n                        }\n                    }\n                    // If max index was 0 it means just ellipsis was also to large.\n                    if (maxIndex === 0) {\n                        // Remove ellipses.\n                        updateTSpan('');\n                    }\n                }\n                return wasTooLong;\n            },\n\n            /**\n             * Parse a simple HTML string into SVG tspans. Called internally when text\n             *   is set on an SVGElement. The function supports a subset of HTML tags,\n             *   CSS text features like `width`, `text-overflow`, `white-space`, and\n             *   also attributes like `href` and `style`.\n             * @private\n             * @param {Highcharts.SVGElement} wrapper The parent SVGElement.\n             */\n            buildText: function(wrapper) {\n                var textNode = wrapper.element,\n                    renderer = this,\n                    forExport = renderer.forExport,\n                    textStr = pick(wrapper.textStr, '').toString(),\n                    hasMarkup = textStr.indexOf('<') !== -1,\n                    lines,\n                    childNodes = textNode.childNodes,\n                    wasTooLong,\n                    parentX = attr(textNode, 'x'),\n                    textStyles = wrapper.styles,\n                    width = wrapper.textWidth,\n                    textLineHeight = textStyles && textStyles.lineHeight,\n                    textOutline = textStyles && textStyles.textOutline,\n                    ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n                    noWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n                    fontSize = textStyles && textStyles.fontSize,\n                    textCache,\n                    isSubsequentLine,\n                    i = childNodes.length,\n                    tempParent = width && !wrapper.added && this.box,\n                    getLineHeight = function(tspan) {\n                        var fontSizeStyle;\n\n                        fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                            tspan.style.fontSize :\n                            (fontSize || renderer.style.fontSize || 12);\n\n\n                        return textLineHeight ?\n                            pInt(textLineHeight) :\n                            renderer.fontMetrics(\n                                fontSizeStyle,\n                                // Get the computed size from parent if not explicit\n                                tspan.getAttribute('style') ? tspan : textNode\n                            ).h;\n                    },\n                    unescapeAngleBrackets = function(inputStr) {\n                        return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n                    },\n                    parseAttribute = function (s, attr) {\n                        var start,\n                            delimiter;\n        \n                        start = s.indexOf('<');\n                        s = s.substring(start, s.indexOf('>') - start);\n        \n                        start = s.indexOf(attr + '=');\n                        if (start !== -1) {\n                            start = start + attr.length + 1;\n                            delimiter = s.charAt(start);\n                            if (delimiter === '\"' || delimiter === \"'\") { // eslint-disable-line quotes\n                                s = s.substring(start + 1);\n                                return s.substring(0, s.indexOf(delimiter));\n                            }\n                        }\n                    };\n\n                // The buildText code is quite heavy, so if we're not changing something\n                // that affects the text, skip it (#6113).\n                textCache = [\n                    textStr,\n                    ellipsis,\n                    noWrap,\n                    textLineHeight,\n                    textOutline,\n                    fontSize,\n                    width\n                ].join(',');\n                if (textCache === wrapper.textCache) {\n                    return;\n                }\n                wrapper.textCache = textCache;\n\n                /// remove old text\n                while (i--) {\n                    textNode.removeChild(childNodes[i]);\n                }\n\n                // Skip tspans, add text directly to text node. The forceTSpan is a hook\n                // used in text outline hack.\n                if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {\n                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n                    // Complex strings, add more logic\n                } else {\n                    if (tempParent) {\n                        tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n                    }\n\n                    if (hasMarkup) {\n                        lines = textStr\n\n                            .replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n                            .replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\n                            .replace(/<a/g, '<span')\n                            .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                            .split(/<br.*?>/g);\n\n                    } else {\n                        lines = [textStr];\n                    }\n\n\n                    // Trim empty lines (#5261)\n                    lines = grep(lines, function(line) {\n                        return line !== '';\n                    });\n\n\n                    // build the lines\n                    each(lines, function buildTextLines(line, lineNo) {\n                        var spans,\n                            spanNo = 0;\n                        line = line\n                            .replace(/^\\s+|\\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)\n                            .replace(/<span/g, '|||<span')\n                            .replace(/<\\/span>/g, '</span>|||');\n                        spans = line.split('|||');\n\n                        each(spans, function buildTextSpans(span) {\n                            if (span !== '' || spans.length === 1) {\n                                var attributes = {},\n                                    tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                                    classAttribute,\n                                    styleAttribute, // #390\n                                    hrefAttribute;\n                                \n                                classAttribute = parseAttribute(span, 'class');\n                                if (classAttribute) {\n                                    attr(tspan, 'class', classAttribute);\n                                }\n        \n                                styleAttribute = parseAttribute(span, 'style');\n                                if (styleAttribute) {\n                                    styleAttribute = styleAttribute.replace(\n                                        /(;| |^)color([ :])/,\n                                        '$1fill$2'\n                                    );\n                                    attr(tspan, 'style', styleAttribute);\n                                }\n        \n                                // Not for export - #1529\n                                hrefAttribute = parseAttribute(span, 'href');\n                                if (hrefAttribute && !forExport) {\n                                    attr(\n                                        tspan,\n                                        'onclick',\n                                        'location.href=\\\"' + hrefAttribute + '\\\"'\n                                    );\n                                    attr(tspan, 'class', 'highcharts-anchor');\n                                    /*= if (build.classic) { =*/\n                                    css(tspan, { cursor: 'pointer' });\n                                    /*= } =*/\n                                }        \n\n                                span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                                // Nested tags aren't supported, and cause crash in Safari (#1596)\n                                if (span !== ' ') {\n\n                                    // add the text node\n                                    tspan.appendChild(doc.createTextNode(span));\n\n                                    if (!spanNo) { // first span in a line, align it to the left\n                                        if (lineNo && parentX !== null) {\n                                            attributes.x = parentX;\n                                        }\n                                    } else {\n                                        attributes.dx = 0; // #16\n                                    }\n\n                                    // add attributes\n                                    attr(tspan, attributes);\n\n                                    // Append it\n                                    textNode.appendChild(tspan);\n\n                                    // first span on subsequent line, add the line height\n                                    if (!spanNo && isSubsequentLine) {\n\n                                        // allow getting the right offset height in exporting in IE\n                                        if (!svg && forExport) {\n                                            css(tspan, {\n                                                display: 'block'\n                                            });\n                                        }\n\n                                        // Set the line height based on the font size of either\n                                        // the text element or the tspan element\n                                        attr(\n                                            tspan,\n                                            'dy',\n                                            getLineHeight(tspan)\n                                        );\n                                    }\n\n                                    /*if (width) {\n                                    \trenderer.breakText(wrapper, width);\n                                    }*/\n\n                                    // Check width and apply soft breaks or ellipsis\n                                    if (width) {\n                                        var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                            hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),\n                                            tooLong,\n                                            rest = [],\n                                            actualWidth,\n                                            dy = getLineHeight(tspan),\n                                            rotation = wrapper.rotation;\n\n                                        if (ellipsis) {\n                                            wasTooLong = renderer.applyEllipsis(wrapper, tspan, span, width);\n                                        }\n\n                                        while (!ellipsis && hasWhiteSpace && (words.length || rest.length)) {\n                                            wrapper.rotation = 0; // discard rotation when computing box\n                                            actualWidth = renderer.getSpanWidth(wrapper, tspan);\n                                            tooLong = actualWidth > width;\n\n                                            // For ellipsis, do a binary search for the correct string length\n                                            if (wasTooLong === undefined) {\n                                                wasTooLong = tooLong; // First time\n                                            }\n\n                                            // Looping down, this is the first word sequence that is not too long,\n                                            // so we can move on to build the next line.\n                                            if (!tooLong || words.length === 1) {\n                                                words = rest;\n                                                rest = [];\n\n                                                if (words.length && !noWrap) {\n                                                    tspan = doc.createElementNS(SVG_NS, 'tspan');\n                                                    attr(tspan, {\n                                                        dy: dy,\n                                                        x: parentX\n                                                    });\n                                                    if (styleAttribute) { // #390\n                                                        attr(\n                                                            tspan,\n                                                            'style',\n                                                            styleAttribute\n                                                        );\n                                                    }\n                                                    textNode.appendChild(tspan);\n                                                }\n                                                if (actualWidth > width) { // a single word is pressing it out\n                                                    width = actualWidth;\n                                                }\n                                            } else { // append to existing line tspan\n                                                tspan.removeChild(tspan.firstChild);\n                                                rest.unshift(words.pop());\n                                            }\n                                            if (words.length) {\n                                                tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                            }\n                                        }\n                                        wrapper.rotation = rotation;\n                                    }\n\n                                    spanNo++;\n                                }\n                            }\n                        });\n                        // To avoid beginning lines that doesn't add to the textNode (#6144)\n                        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;\n                    });\n\n                    if (wasTooLong) {\n                        wrapper.attr('title', wrapper.textStr);\n                    }\n                    if (tempParent) {\n                        tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n                    }\n\n                    // Apply the text outline\n                    if (textOutline && wrapper.applyTextOutline) {\n                        wrapper.applyTextOutline(textOutline);\n                    }\n                }\n            },\n\n\n\n            /*\n            breakText: function (wrapper, width) {\n            \tvar bBox = wrapper.getBBox(),\n            \t\tnode = wrapper.element,\n            \t\ttextLength = node.textContent.length,\n            \t\tpos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width\n            \t\tincrement = 0,\n            \t\tfinalPos;\n\n            \tif (bBox.width > width) {\n            \t\twhile (finalPos === undefined) {\n            \t\t\ttextLength = node.getSubStringLength(0, pos);\n\n            \t\t\tif (textLength <= width) {\n            \t\t\t\tif (increment === -1) {\n            \t\t\t\t\tfinalPos = pos;\n            \t\t\t\t} else {\n            \t\t\t\t\tincrement = 1;\n            \t\t\t\t}\n            \t\t\t} else {\n            \t\t\t\tif (increment === 1) {\n            \t\t\t\t\tfinalPos = pos - 1;\n            \t\t\t\t} else {\n            \t\t\t\t\tincrement = -1;\n            \t\t\t\t}\n            \t\t\t}\n            \t\t\tpos += increment;\n            \t\t}\n            \t}\n            \tconsole.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))\n            },\n            */\n\n            /**\n             * Returns white for dark colors and black for bright colors.\n             *\n             * @param {ColorString} rgba - The color to get the contrast for.\n             * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.\n             */\n            getContrast: function(rgba) {\n                rgba = color(rgba).rgba;\n\n                // The threshold may be discussed. Here's a proposal for adding\n                // different weight to the color channels (#6216)\n                /*\n        rgba[0] *= 1; // red\n        rgba[1] *= 1.2; // green\n        rgba[2] *= 0.7; // blue\n        */\n\n                return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';\n            },\n\n            /**\n             * Create a button with preset states.\n             * @param {string} text - The text or HTML to draw.\n             * @param {number} x - The x position of the button's left side.\n             * @param {number} y - The y position of the button's top side.\n             * @param {Function} callback - The function to execute on button click or \n             *    touch.\n             * @param {SVGAttributes} [normalState] - SVG attributes for the normal\n             *    state.\n             * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.\n             * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed\n             *    state.\n             * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled\n             *    state.\n             * @param {Symbol} [shape=rect] - The shape type.\n             * @returns {SVGRenderer} The button element.\n             */\n            button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n                var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n                    curState = 0;\n\n                // Default, non-stylable attributes\n                label.attr(merge({\n                    'padding': 8,\n                    'r': 2\n                }, normalState));\n\n\n                // Presentational\n                var normalStyle,\n                    hoverStyle,\n                    pressedStyle,\n                    disabledStyle;\n\n                // Normal state - prepare the attributes\n                normalState = merge({\n                    fill: '#f7f7f7',\n                    stroke: '#cccccc',\n                    'stroke-width': 1,\n                    style: {\n                        color: '#333333',\n                        cursor: 'pointer',\n                        fontWeight: 'normal'\n                    }\n                }, normalState);\n                normalStyle = normalState.style;\n                delete normalState.style;\n\n                // Hover state\n                hoverState = merge(normalState, {\n                    fill: '#e6e6e6'\n                }, hoverState);\n                hoverStyle = hoverState.style;\n                delete hoverState.style;\n\n                // Pressed state\n                pressedState = merge(normalState, {\n                    fill: '#e6ebf5',\n                    style: {\n                        color: '#000000',\n                        fontWeight: 'bold'\n                    }\n                }, pressedState);\n                pressedStyle = pressedState.style;\n                delete pressedState.style;\n\n                // Disabled state\n                disabledState = merge(normalState, {\n                    style: {\n                        color: '#cccccc'\n                    }\n                }, disabledState);\n                disabledStyle = disabledState.style;\n                delete disabledState.style;\n\n\n                // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n                addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {\n                    if (curState !== 3) {\n                        label.setState(1);\n                    }\n                });\n                addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {\n                    if (curState !== 3) {\n                        label.setState(curState);\n                    }\n                });\n\n                label.setState = function(state) {\n                    // Hover state is temporary, don't record it\n                    if (state !== 1) {\n                        label.state = curState = state;\n                    }\n                    // Update visuals\n                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)\n                        .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);\n\n\n                    label.attr([normalState, hoverState, pressedState, disabledState][state || 0])\n                        .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);\n\n                };\n\n\n\n                // Presentational attributes\n                label\n                    .attr(normalState)\n                    .css(extend({\n                        cursor: 'default'\n                    }, normalStyle));\n\n\n                return label\n                    .on('click', function(e) {\n                        if (curState !== 3) {\n                            callback.call(label, e);\n                        }\n                    });\n            },\n\n            /**\n             * Make a straight line crisper by not spilling out to neighbour pixels.\n             * \n             * @param {Array} points - The original points on the format `['M', 0, 0,\n             *    'L', 100, 0]`.\n             * @param {number} width - The width of the line.\n             * @returns {Array} The original points array, but modified to render\n             * crisply.\n             */\n            crispLine: function(points, width) {\n                // normalize to a crisp line\n                if (points[1] === points[4]) {\n                    // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                    points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n                }\n                if (points[2] === points[5]) {\n                    points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n                }\n                return points;\n            },\n\n\n            /**\n             * Draw a path, wraps the SVG `path` element.\n             * \n             * @param {Array} [path] An SVG path definition in array form.\n             * \n             * @example\n             * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n             *     .attr({ stroke: '#ff00ff' })\n             *     .add();\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-path-on-chart/\n             *         Draw a path in a chart\n             * @sample highcharts/members/renderer-path/\n             *         Draw a path independent from a chart\n             *\n             */\n            /**\n             * Draw a path, wraps the SVG `path` element.\n             * \n             * @param {SVGAttributes} [attribs] The initial attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            path: function(path) {\n                var attribs = {\n\n                    fill: 'none'\n\n                };\n                if (isArray(path)) {\n                    attribs.d = path;\n                } else if (isObject(path)) { // attributes\n                    extend(attribs, path);\n                }\n                return this.createElement('path').attr(attribs);\n            },\n\n            /**\n             * Draw a circle, wraps the SVG `circle` element.\n             * \n             * @param {number} [x] The center x position.\n             * @param {number} [y] The center y position.\n             * @param {number} [r] The radius.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-circle/ Drawing a circle\n             */\n            /**\n             * Draw a circle, wraps the SVG `circle` element.\n             * \n             * @param {SVGAttributes} [attribs] The initial attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            circle: function(x, y, r) {\n                var attribs = isObject(x) ? x : {\n                        x: x,\n                        y: y,\n                        r: r\n                    },\n                    wrapper = this.createElement('circle');\n\n                // Setting x or y translates to cx and cy\n                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {\n                    element.setAttribute('c' + key, value);\n                };\n\n                return wrapper.attr(attribs);\n            },\n\n            /**\n             * Draw and return an arc.\n             * @param {number} [x=0] Center X position.\n             * @param {number} [y=0] Center Y position.\n             * @param {number} [r=0] The outer radius of the arc.\n             * @param {number} [innerR=0] Inner radius like used in donut charts.\n             * @param {number} [start=0] The starting angle of the arc in radians, where\n             *    0 is to the right and `-Math.PI/2` is up.\n             * @param {number} [end=0] The ending angle of the arc in radians, where 0\n             *    is to the right and `-Math.PI/2` is up.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-arc/\n             *         Drawing an arc\n             */\n            /**\n             * Draw and return an arc. Overloaded function that takes arguments object.\n             * @param {SVGAttributes} attribs Initial SVG attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            arc: function(x, y, r, innerR, start, end) {\n                var arc,\n                    options;\n\n                if (isObject(x)) {\n                    options = x;\n                    y = options.y;\n                    r = options.r;\n                    innerR = options.innerR;\n                    start = options.start;\n                    end = options.end;\n                    x = options.x;\n                } else {\n                    options = {\n                        innerR: innerR,\n                        start: start,\n                        end: end\n                    };\n                }\n\n                // Arcs are defined as symbols for the ability to set\n                // attributes in attr and animate\n                arc = this.symbol('arc', x, y, r, r, options);\n                arc.r = r; // #959\n                return arc;\n            },\n\n            /**\n             * Draw and return a rectangle.\n             * @param {number} [x] Left position.\n             * @param {number} [y] Top position.\n             * @param {number} [width] Width of the rectangle.\n             * @param {number} [height] Height of the rectangle.\n             * @param {number} [r] Border corner radius.\n             * @param {number} [strokeWidth] A stroke width can be supplied to allow\n             *    crisp drawing.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            /**\n             * Draw and return a rectangle.\n             * @param  {SVGAttributes} [attributes]\n             *         General SVG attributes for the rectangle.\n             * @return {Highcharts.SVGElement}\n             *         The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-rect-on-chart/\n             *         Draw a rectangle in a chart\n             * @sample highcharts/members/renderer-rect/\n             *         Draw a rectangle independent from a chart\n             */\n            rect: function(x, y, width, height, r, strokeWidth) {\n\n                r = isObject(x) ? x.r : r;\n\n                var wrapper = this.createElement('rect'),\n                    attribs = isObject(x) ? x : x === undefined ? {} : {\n                        x: x,\n                        y: y,\n                        width: Math.max(width, 0),\n                        height: Math.max(height, 0)\n                    };\n\n\n                if (strokeWidth !== undefined) {\n                    attribs.strokeWidth = strokeWidth;\n                    attribs = wrapper.crisp(attribs);\n                }\n                attribs.fill = 'none';\n\n\n                if (r) {\n                    attribs.r = r;\n                }\n\n                wrapper.rSetter = function(value, key, element) {\n                    attr(element, {\n                        rx: value,\n                        ry: value\n                    });\n                };\n\n                return wrapper.attr(attribs);\n            },\n\n            /**\n             * Resize the {@link SVGRenderer#box} and re-align all aligned child\n             * elements.\n             * @param {number} width The new pixel width.\n             * @param {number} height The new pixel height.\n             * @param {boolean} animate Whether to animate.\n             */\n            setSize: function(width, height, animate) {\n                var renderer = this,\n                    alignedObjects = renderer.alignedObjects,\n                    i = alignedObjects.length;\n\n                renderer.width = width;\n                renderer.height = height;\n\n                renderer.boxWrapper.animate({\n                    width: width,\n                    height: height\n                }, {\n                    step: function() {\n                        this.attr({\n                            viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')\n                        });\n                    },\n                    duration: pick(animate, true) ? undefined : 0\n                });\n\n                while (i--) {\n                    alignedObjects[i].align();\n                }\n            },\n\n            /**\n             * Create and return an svg group element. Child {@link Highcharts.SVGElement}\n             * objects are added to the group by using the group as the first parameter\n             * in {@link Highcharts.SVGElement#add|add()}.\n             * \n             * @param {string} [name] The group will be given a class name of\n             * `highcharts-{name}`. This can be used for styling and scripting.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-g/\n             *         Show and hide grouped objects\n             */\n            g: function(name) {\n                var elem = this.createElement('g');\n                return name ? elem.attr({\n                    'class': 'highcharts-' + name\n                }) : elem;\n            },\n\n            /**\n             * Display an image.\n             * @param {string} src The image source.\n             * @param {number} [x] The X position.\n             * @param {number} [y] The Y position.\n             * @param {number} [width] The image width. If omitted, it defaults to the \n             *    image file width.\n             * @param {number} [height] The image height. If omitted it defaults to the\n             *    image file height.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-image-on-chart/\n             *         Add an image in a chart\n             * @sample highcharts/members/renderer-image/\n             *         Add an image independent of a chart\n             */\n            image: function(src, x, y, width, height) {\n                var attribs = {\n                        preserveAspectRatio: 'none'\n                    },\n                    elemWrapper;\n\n                // optional properties\n                if (arguments.length > 1) {\n                    extend(attribs, {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    });\n                }\n\n                elemWrapper = this.createElement('image').attr(attribs);\n\n                // set the href in the xlink namespace\n                if (elemWrapper.element.setAttributeNS) {\n                    elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                        'href', src);\n                } else {\n                    // could be exporting in IE\n                    // using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n                    elemWrapper.element.setAttribute('hc-svg-href', src);\n                }\n                return elemWrapper;\n            },\n\n            /**\n             * Draw a symbol out of pre-defined shape paths from {@SVGRenderer#symbols}.\n             * It is used in Highcharts for point makers, which cake a `symbol` option,\n             * and label and button backgrounds like in the tooltip and stock flags.\n             *\n             * @param {Symbol} symbol - The symbol name.\n             * @param {number} x - The X coordinate for the top left position.\n             * @param {number} y - The Y coordinate for the top left position.\n             * @param {number} width - The pixel width.\n             * @param {number} height - The pixel height.\n             * @param {Object} [options] - Additional options, depending on the actual\n             *    symbol drawn. \n             * @param {number} [options.anchorX] - The anchor X position for the\n             *    `callout` symbol. This is where the chevron points to.\n             * @param {number} [options.anchorY] - The anchor Y position for the\n             *    `callout` symbol. This is where the chevron points to.\n             * @param {number} [options.end] - The end angle of an `arc` symbol.\n             * @param {boolean} [options.open] - Whether to draw `arc` symbol open or\n             *    closed.\n             * @param {number} [options.r] - The radius of an `arc` symbol, or the\n             *    border radius for the `callout` symbol.\n             * @param {number} [options.start] - The start angle of an `arc` symbol.\n             */\n            symbol: function(symbol, x, y, width, height, options) {\n\n                var ren = this,\n                    obj,\n                    imageRegex = /^url\\((.*?)\\)$/,\n                    isImage = imageRegex.test(symbol),\n                    sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n\n\n                    // get the symbol definition function\n                    symbolFn = sym && this.symbols[sym],\n\n                    // check if there's a path defined for this symbol\n                    path = defined(x) && symbolFn && symbolFn.call(\n                        this.symbols,\n                        Math.round(x),\n                        Math.round(y),\n                        width,\n                        height,\n                        options\n                    ),\n                    imageSrc,\n                    centerImage;\n\n                if (symbolFn) {\n                    obj = this.path(path);\n\n\n                    obj.attr('fill', 'none');\n\n\n                    // expando properties for use in animate and attr\n                    extend(obj, {\n                        symbolName: sym,\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    });\n                    if (options) {\n                        extend(obj, options);\n                    }\n\n\n                    // Image symbols\n                } else if (isImage) {\n\n\n                    imageSrc = symbol.match(imageRegex)[1];\n\n                    // Create the image synchronously, add attribs async\n                    obj = this.image(imageSrc);\n\n                    // The image width is not always the same as the symbol width. The\n                    // image may be centered within the symbol, as is the case when\n                    // image shapes are used as label backgrounds, for example in flags.\n                    obj.imgwidth = pick(\n                        symbolSizes[imageSrc] && symbolSizes[imageSrc].width,\n                        options && options.width\n                    );\n                    obj.imgheight = pick(\n                        symbolSizes[imageSrc] && symbolSizes[imageSrc].height,\n                        options && options.height\n                    );\n                    /**\n                     * Set the size and position\n                     */\n                    centerImage = function() {\n                        obj.attr({\n                            width: obj.width,\n                            height: obj.height\n                        });\n                    };\n\n                    /**\n                     * Width and height setters that take both the image's physical size\n                     * and the label size into consideration, and translates the image\n                     * to center within the label.\n                     */\n                    each(['width', 'height'], function(key) {\n                        obj[key + 'Setter'] = function(value, key) {\n                            var attribs = {},\n                                imgSize = this['img' + key],\n                                trans = key === 'width' ? 'translateX' : 'translateY';\n                            this[key] = value;\n                            if (defined(imgSize)) {\n                                if (this.element) {\n                                    this.element.setAttribute(key, imgSize);\n                                }\n                                if (!this.alignByTranslate) {\n                                    attribs[trans] = ((this[key] || 0) - imgSize) / 2;\n                                    this.attr(attribs);\n                                }\n                            }\n                        };\n                    });\n\n\n                    if (defined(x)) {\n                        obj.attr({\n                            x: x,\n                            y: y\n                        });\n                    }\n                    obj.isImg = true;\n\n                    if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n                        centerImage();\n                    } else {\n                        // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                        obj.attr({\n                            width: 0,\n                            height: 0\n                        });\n\n                        // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                        // the created element must be assigned to a variable in order to load (#292).\n                        createElement('img', {\n                            onload: function() {\n\n                                var chart = charts[ren.chartIndex];\n\n                                // Special case for SVGs on IE11, the width is not accessible until the image is\n                                // part of the DOM (#2854).\n                                if (this.width === 0) {\n                                    css(this, {\n                                        position: 'absolute',\n                                        top: '-999em'\n                                    });\n                                    doc.body.appendChild(this);\n                                }\n\n                                // Center the image\n                                symbolSizes[imageSrc] = { // Cache for next\t\n                                    width: this.width,\n                                    height: this.height\n                                };\n                                obj.imgwidth = this.width;\n                                obj.imgheight = this.height;\n\n                                if (obj.element) {\n                                    centerImage();\n                                }\n\n                                // Clean up after #2854 workaround.\n                                if (this.parentNode) {\n                                    this.parentNode.removeChild(this);\n                                }\n\n                                // Fire the load event when all external images are loaded\n                                ren.imgCount--;\n                                if (!ren.imgCount && chart && chart.onload) {\n                                    chart.onload();\n                                }\n                            },\n                            src: imageSrc\n                        });\n                        this.imgCount++;\n                    }\n                }\n\n                return obj;\n            },\n\n            /**\n             * @typedef {string} Symbol\n             * \n             * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n             * `triangle`, `triangle-down`. Symbols are used internally for point\n             * markers, button and label borders and backgrounds, or custom shapes.\n             * Extendable by adding to {@link SVGRenderer#symbols}.\n             */\n            /**\n             * An extendable collection of functions for defining symbol paths.\n             */\n            symbols: {\n                'circle': function(x, y, w, h) {\n                    // Return a full arc\n                    return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n                        start: 0,\n                        end: Math.PI * 2,\n                        open: false\n                    });\n                },\n\n                'square': function(x, y, w, h) {\n                    return [\n                        'M', x, y,\n                        'L', x + w, y,\n                        x + w, y + h,\n                        x, y + h,\n                        'Z'\n                    ];\n                },\n\n                'triangle': function(x, y, w, h) {\n                    return [\n                        'M', x + w / 2, y,\n                        'L', x + w, y + h,\n                        x, y + h,\n                        'Z'\n                    ];\n                },\n\n                'triangle-down': function(x, y, w, h) {\n                    return [\n                        'M', x, y,\n                        'L', x + w, y,\n                        x + w / 2, y + h,\n                        'Z'\n                    ];\n                },\n                'diamond': function(x, y, w, h) {\n                    return [\n                        'M', x + w / 2, y,\n                        'L', x + w, y + h / 2,\n                        x + w / 2, y + h,\n                        x, y + h / 2,\n                        'Z'\n                    ];\n                },\n                'arc': function(x, y, w, h, options) {\n                    var start = options.start,\n                        rx = options.r || w,\n                        ry = options.r || h || w,\n                        end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                        innerRadius = options.innerR,\n                        open = options.open,\n                        cosStart = Math.cos(start),\n                        sinStart = Math.sin(start),\n                        cosEnd = Math.cos(end),\n                        sinEnd = Math.sin(end),\n                        longArc = options.end - start < Math.PI ? 0 : 1,\n                        arc;\n\n                    arc = [\n                        'M',\n                        x + rx * cosStart,\n                        y + ry * sinStart,\n                        'A', // arcTo\n                        rx, // x radius\n                        ry, // y radius\n                        0, // slanting\n                        longArc, // long or short arc\n                        1, // clockwise\n                        x + rx * cosEnd,\n                        y + ry * sinEnd\n                    ];\n\n                    if (defined(innerRadius)) {\n                        arc.push(\n                            open ? 'M' : 'L',\n                            x + innerRadius * cosEnd,\n                            y + innerRadius * sinEnd,\n                            'A', // arcTo\n                            innerRadius, // x radius\n                            innerRadius, // y radius\n                            0, // slanting\n                            longArc, // long or short arc\n                            0, // clockwise\n                            x + innerRadius * cosStart,\n                            y + innerRadius * sinStart\n                        );\n                    }\n\n                    arc.push(open ? '' : 'Z'); // close\n                    return arc;\n                },\n\n                /**\n                 * Callout shape used for default tooltips, also used for rounded rectangles in VML\n                 */\n                callout: function(x, y, w, h, options) {\n                    var arrowLength = 6,\n                        halfDistance = 6,\n                        r = Math.min((options && options.r) || 0, w, h),\n                        safeDistance = r + halfDistance,\n                        anchorX = options && options.anchorX,\n                        anchorY = options && options.anchorY,\n                        path;\n\n                    path = [\n                        'M', x + r, y,\n                        'L', x + w - r, y, // top side\n                        'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                        'L', x + w, y + h - r, // right side\n                        'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                        'L', x + r, y + h, // bottom side\n                        'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                        'L', x, y + r, // left side\n                        'C', x, y, x, y, x + r, y // top-left corner\n                    ];\n\n                    // Anchor on right side\n                    if (anchorX && anchorX > w) {\n\n                        // Chevron\n                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n                            path.splice(13, 3,\n                                'L', x + w, anchorY - halfDistance,\n                                x + w + arrowLength, anchorY,\n                                x + w, anchorY + halfDistance,\n                                x + w, y + h - r\n                            );\n\n                            // Simple connector\n                        } else {\n                            path.splice(13, 3,\n                                'L', x + w, h / 2,\n                                anchorX, anchorY,\n                                x + w, h / 2,\n                                x + w, y + h - r\n                            );\n                        }\n\n                        // Anchor on left side\n                    } else if (anchorX && anchorX < 0) {\n\n                        // Chevron\n                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n                            path.splice(33, 3,\n                                'L', x, anchorY + halfDistance,\n                                x - arrowLength, anchorY,\n                                x, anchorY - halfDistance,\n                                x, y + r\n                            );\n\n                            // Simple connector\n                        } else {\n                            path.splice(33, 3,\n                                'L', x, h / 2,\n                                anchorX, anchorY,\n                                x, h / 2,\n                                x, y + r\n                            );\n                        }\n\n                    } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                        path.splice(23, 3,\n                            'L', anchorX + halfDistance, y + h,\n                            anchorX, y + h + arrowLength,\n                            anchorX - halfDistance, y + h,\n                            x + r, y + h\n                        );\n                    } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                        path.splice(3, 3,\n                            'L', anchorX - halfDistance, y,\n                            anchorX, y - arrowLength,\n                            anchorX + halfDistance, y,\n                            w - r, y\n                        );\n                    }\n\n                    return path;\n                }\n            },\n\n            /**\n             * @typedef {Highcharts.SVGElement} ClipRect - A clipping rectangle that can be applied\n             * to one or more {@link SVGElement} instances. It is instanciated with the\n             * {@link SVGRenderer#clipRect} function and applied with the {@link \n             * SVGElement#clip} function.\n             *\n             * @example\n             * var circle = renderer.circle(100, 100, 100)\n             *     .attr({ fill: 'red' })\n             *     .add();\n             * var clipRect = renderer.clipRect(100, 100, 100, 100);\n             *\n             * // Leave only the lower right quarter visible\n             * circle.clip(clipRect);\n             */\n            /**\n             * Define a clipping rectangle\n             * @param {String} id\n             * @param {number} x\n             * @param {number} y\n             * @param {number} width\n             * @param {number} height\n             * @returns {ClipRect} A clipping rectangle.\n             */\n            clipRect: function(x, y, width, height) {\n                var wrapper,\n                    id = H.uniqueKey(),\n\n                    clipPath = this.createElement('clipPath').attr({\n                        id: id\n                    }).add(this.defs);\n\n                wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n                wrapper.id = id;\n                wrapper.clipPath = clipPath;\n                wrapper.count = 0;\n\n                return wrapper;\n            },\n\n\n\n\n\n            /**\n             * Draw text. The text can contain a subset of HTML, like spans and anchors\n             * and some basic text styling of these. For more advanced features like\n             * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n             * To update the text after render, run `text.attr({ text: 'New text' })`.\n             * @param  {String} str\n             *         The text of (subset) HTML to draw.\n             * @param  {number} x\n             *         The x position of the text's lower left corner.\n             * @param  {number} y\n             *         The y position of the text's lower left corner.\n             * @param  {Boolean} [useHTML=false]\n             *         Use HTML to render the text.\n             *\n             * @return {Highcharts.SVGElement} The text object.\n             *\n             * @sample highcharts/members/renderer-text-on-chart/\n             *         Annotate the chart freely\n             * @sample highcharts/members/renderer-on-chart/\n             *         Annotate with a border and in response to the data\n             * @sample highcharts/members/renderer-text/\n             *         Formatted text\n             */\n            text: function(str, x, y, useHTML) {\n\n                // declare variables\n                var renderer = this,\n                    fakeSVG = !svg && renderer.forExport,\n                    wrapper,\n                    attribs = {};\n\n                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n                    return renderer.html(str, x, y);\n                }\n\n                attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic\n                if (y) {\n                    attribs.y = Math.round(y);\n                }\n                if (str || str === 0) {\n                    attribs.text = str;\n                }\n\n                wrapper = renderer.createElement('text')\n                    .attr(attribs);\n\n                // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n                if (fakeSVG) {\n                    wrapper.css({\n                        position: 'absolute'\n                    });\n                }\n\n                if (!useHTML) {\n                    wrapper.xSetter = function(value, key, element) {\n                        var tspans = element.getElementsByTagName('tspan'),\n                            tspan,\n                            parentVal = element.getAttribute(key),\n                            i;\n                        for (i = 0; i < tspans.length; i++) {\n                            tspan = tspans[i];\n                            // If the x values are equal, the tspan represents a linebreak\n                            if (tspan.getAttribute(key) === parentVal) {\n                                tspan.setAttribute(key, value);\n                            }\n                        }\n                        element.setAttribute(key, value);\n                    };\n                }\n\n                return wrapper;\n            },\n\n            /**\n             * Utility to return the baseline offset and total line height from the font\n             * size.\n             *\n             * @param {?string} fontSize The current font size to inspect. If not given,\n             *   the font size will be found from the DOM element.\n             * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a\n             *   current font size.\n             * @returns {Object} An object containing `h`: the line height, `b`: the\n             * baseline relative to the top of the box, and `f`: the font size.\n             */\n            fontMetrics: function(fontSize, elem) {\n                var lineHeight,\n                    baseline;\n\n\n                fontSize = fontSize ||\n                    // When the elem is a DOM element (#5932)\n                    (elem && elem.style && elem.style.fontSize) ||\n                    // Fall back on the renderer style default\n                    (this.style && this.style.fontSize);\n\n\n\n                // Handle different units\n                if (/px/.test(fontSize)) {\n                    fontSize = pInt(fontSize);\n                } else if (/em/.test(fontSize)) {\n                    // The em unit depends on parent items\n                    fontSize = parseFloat(fontSize) *\n                        (elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n                } else {\n                    fontSize = 12;\n                }\n\n                // Empirical values found by comparing font size and bounding box\n                // height. Applies to the default font family.\n                // http://jsfiddle.net/highcharts/7xvn7/\n                lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n                baseline = Math.round(lineHeight * 0.8);\n\n                return {\n                    h: lineHeight,\n                    b: baseline,\n                    f: fontSize\n                };\n            },\n\n            /**\n             * Correct X and Y positioning of a label for rotation (#1764)\n             */\n            rotCorr: function(baseline, rotation, alterY) {\n                var y = baseline;\n                if (rotation && alterY) {\n                    y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n                }\n                return {\n                    x: (-baseline / 3) * Math.sin(rotation * deg2rad),\n                    y: y\n                };\n            },\n\n            /**\n             * Draw a label, which is an extended text element with support for border\n             * and background. Highcharts creates a `g` element with a text and a `path`\n             * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n             * background are set through `stroke`, `stroke-width` and `fill` attributes\n             * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n             * text after render, run `label.attr({ text: 'New text' })`.\n             * \n             * @param  {string} str\n             *         The initial text string or (subset) HTML to render.\n             * @param  {number} x\n             *         The x position of the label's left side.\n             * @param  {number} y\n             *         The y position of the label's top side or baseline, depending on\n             *         the `baseline` parameter.\n             * @param  {String} shape\n             *         The shape of the label's border/background, if any. Defaults to\n             *         `rect`. Other possible values are `callout` or other shapes\n             *         defined in {@link Highcharts.SVGRenderer#symbols}.\n             * @param  {number} anchorX\n             *         In case the `shape` has a pointer, like a flag, this is the\n             *         coordinates it should be pinned to.\n             * @param  {number} anchorY\n             *         In case the `shape` has a pointer, like a flag, this is the\n             *         coordinates it should be pinned to.\n             * @param  {Boolean} baseline\n             *         Whether to position the label relative to the text baseline,\n             *\t       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n             *\t       upper border of the rectangle.\n             * @param  {String} className\n             *         Class name for the group.\n             *\n             * @return {Highcharts.SVGElement}\n             *         The generated label.\n             *\n             * @sample highcharts/members/renderer-label-on-chart/\n             *         A label on the chart\n             */\n            label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n                var renderer = this,\n                    wrapper = renderer.g(className !== 'button' && 'label'),\n                    text = wrapper.text = renderer.text('', 0, 0, useHTML)\n                    .attr({\n                        zIndex: 1\n                    }),\n                    box,\n                    bBox,\n                    alignFactor = 0,\n                    padding = 3,\n                    paddingLeft = 0,\n                    width,\n                    height,\n                    wrapperX,\n                    wrapperY,\n                    textAlign,\n                    deferredAttr = {},\n                    strokeWidth,\n                    baselineOffset,\n                    hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n                    needsBox = hasBGImage,\n                    getCrispAdjust,\n                    updateBoxSize,\n                    updateTextPadding,\n                    boxAttr;\n\n                if (className) {\n                    wrapper.addClass('highcharts-' + className);\n                }\n\n\n                needsBox = hasBGImage;\n                getCrispAdjust = function() {\n                    return (strokeWidth || 0) % 2 / 2;\n                };\n\n\n\n                /**\n                 * This function runs after the label is added to the DOM (when the bounding box is\n                 * available), and after the text of the label is updated to detect the new bounding\n                 * box and reflect it in the border box.\n                 */\n                updateBoxSize = function() {\n                    var style = text.element.style,\n                        crispAdjust,\n                        attribs = {};\n\n                    bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&\n                        text.getBBox(); //#3295 && 3514 box failure when string equals 0\n                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n                    wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n                    // Update the label-scoped y offset\n                    baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n                    if (needsBox) {\n\n                        // Create the border box if it is not already present\n                        if (!box) {\n                            wrapper.box = box = renderer.symbols[shape] || hasBGImage ? // Symbol definition exists (#5324)\n                                renderer.symbol(shape) :\n                                renderer.rect();\n\n                            box.addClass(\n                                (className === 'button' ? '' : 'highcharts-label-box') + // Don't use label className for buttons\n                                (className ? ' highcharts-' + className + '-box' : '')\n                            );\n\n                            box.add(wrapper);\n\n                            crispAdjust = getCrispAdjust();\n                            attribs.x = crispAdjust;\n                            attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n                        }\n\n                        // Apply the box attributes\n                        attribs.width = Math.round(wrapper.width);\n                        attribs.height = Math.round(wrapper.height);\n\n                        box.attr(extend(attribs, deferredAttr));\n                        deferredAttr = {};\n                    }\n                };\n\n                /**\n                 * This function runs after setting text or padding, but only if padding is changed\n                 */\n                updateTextPadding = function() {\n                    var textX = paddingLeft + padding,\n                        textY;\n\n                    // determin y based on the baseline\n                    textY = baseline ? 0 : baselineOffset;\n\n                    // compensate for alignment\n                    if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                        textX += {\n                            center: 0.5,\n                            right: 1\n                        }[textAlign] * (width - bBox.width);\n                    }\n\n                    // update if anything changed\n                    if (textX !== text.x || textY !== text.y) {\n                        text.attr('x', textX);\n                        if (textY !== undefined) {\n                            text.attr('y', textY);\n                        }\n                    }\n\n                    // record current values\n                    text.x = textX;\n                    text.y = textY;\n                };\n\n                /**\n                 * Set a box attribute, or defer it if the box is not yet created\n                 * @param {Object} key\n                 * @param {Object} value\n                 */\n                boxAttr = function(key, value) {\n                    if (box) {\n                        box.attr(key, value);\n                    } else {\n                        deferredAttr[key] = value;\n                    }\n                };\n\n                /**\n                 * After the text element is added, get the desired size of the border box\n                 * and add it before the text in the DOM.\n                 */\n                wrapper.onAdd = function() {\n                    text.add(wrapper);\n                    wrapper.attr({\n                        text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                        x: x,\n                        y: y\n                    });\n\n                    if (box && defined(anchorX)) {\n                        wrapper.attr({\n                            anchorX: anchorX,\n                            anchorY: anchorY\n                        });\n                    }\n                };\n\n                /*\n                 * Add specific attribute setters.\n                 */\n\n                // only change local variables\n                wrapper.widthSetter = function(value) {\n                    width = H.isNumber(value) ? value : null; // width:auto => null\n                };\n                wrapper.heightSetter = function(value) {\n                    height = value;\n                };\n                wrapper['text-alignSetter'] = function(value) {\n                    textAlign = value;\n                };\n                wrapper.paddingSetter = function(value) {\n                    if (defined(value) && value !== padding) {\n                        padding = wrapper.padding = value;\n                        updateTextPadding();\n                    }\n                };\n                wrapper.paddingLeftSetter = function(value) {\n                    if (defined(value) && value !== paddingLeft) {\n                        paddingLeft = value;\n                        updateTextPadding();\n                    }\n                };\n\n\n                // change local variable and prevent setting attribute on the group\n                wrapper.alignSetter = function(value) {\n                    value = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[value];\n                    if (value !== alignFactor) {\n                        alignFactor = value;\n                        if (bBox) { // Bounding box exists, means we're dynamically changing\n                            wrapper.attr({\n                                x: wrapperX\n                            }); // #5134\n                        }\n                    }\n                };\n\n                // apply these to the box and the text alike\n                wrapper.textSetter = function(value) {\n                    if (value !== undefined) {\n                        text.textSetter(value);\n                    }\n                    updateBoxSize();\n                    updateTextPadding();\n                };\n\n                // apply these to the box but not to the text\n                wrapper['stroke-widthSetter'] = function(value, key) {\n                    if (value) {\n                        needsBox = true;\n                    }\n                    strokeWidth = this['stroke-width'] = value;\n                    boxAttr(key, value);\n                };\n\n                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key) {\n                    if (key === 'fill' && value) {\n                        needsBox = true;\n                    }\n                    boxAttr(key, value);\n                };\n\n                wrapper.anchorXSetter = function(value, key) {\n                    anchorX = wrapper.anchorX = value;\n                    boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n                };\n                wrapper.anchorYSetter = function(value, key) {\n                    anchorY = wrapper.anchorY = value;\n                    boxAttr(key, value - wrapperY);\n                };\n\n                // rename attributes\n                wrapper.xSetter = function(value) {\n                    wrapper.x = value; // for animation getter\n                    if (alignFactor) {\n                        value -= alignFactor * ((width || bBox.width) + 2 * padding);\n                    }\n                    wrapperX = Math.round(value);\n                    wrapper.attr('translateX', wrapperX);\n                };\n                wrapper.ySetter = function(value) {\n                    wrapperY = wrapper.y = Math.round(value);\n                    wrapper.attr('translateY', wrapperY);\n                };\n\n                // Redirect certain methods to either the box or the text\n                var baseCss = wrapper.css;\n                return extend(wrapper, {\n                    /**\n                     * Pick up some properties and apply them to the text instead of the\n                     * wrapper.\n                     * @ignore\n                     */\n                    css: function(styles) {\n                        if (styles) {\n                            var textStyles = {};\n                            styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                            each(wrapper.textProps, function(prop) {\n                                if (styles[prop] !== undefined) {\n                                    textStyles[prop] = styles[prop];\n                                    delete styles[prop];\n                                }\n                            });\n                            text.css(textStyles);\n                        }\n                        return baseCss.call(wrapper, styles);\n                    },\n                    /**\n                     * Return the bounding box of the box, not the group.\n                     * @ignore\n                     */\n                    getBBox: function() {\n                        return {\n                            width: bBox.width + 2 * padding,\n                            height: bBox.height + 2 * padding,\n                            x: bBox.x - padding,\n                            y: bBox.y - padding\n                        };\n                    },\n\n                    /**\n                     * Apply the shadow to the box.\n                     * @ignore\n                     */\n                    shadow: function(b) {\n                        if (b) {\n                            updateBoxSize();\n                            if (box) {\n                                box.shadow(b);\n                            }\n                        }\n                        return wrapper;\n                    },\n\n                    /**\n                     * Destroy and release memory.\n                     * @ignore\n                     */\n                    destroy: function() {\n\n                        // Added by button implementation\n                        removeEvent(wrapper.element, 'mouseenter');\n                        removeEvent(wrapper.element, 'mouseleave');\n\n                        if (text) {\n                            text = text.destroy();\n                        }\n                        if (box) {\n                            box = box.destroy();\n                        }\n                        // Call base implementation to destroy the rest\n                        SVGElement.prototype.destroy.call(wrapper);\n\n                        // Release local pointers (#1298)\n                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n                    }\n                });\n            }\n        }); // end SVGRenderer\n\n\n        // general renderer\n        H.Renderer = SVGRenderer;\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var attr = H.attr,\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            isFirefox = H.isFirefox,\n            isMS = H.isMS,\n            isWebKit = H.isWebKit,\n            pInt = H.pInt,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            win = H.win,\n            wrap = H.wrap;\n\n        // Extend SvgElement for useHTML option\n        extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {\n            /**\n             * Apply CSS to HTML elements. This is used in text within SVG rendering and\n             * by the VML renderer\n             */\n            htmlCss: function(styles) {\n                var wrapper = this,\n                    element = wrapper.element,\n                    textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n                if (textWidth) {\n                    delete styles.width;\n                    wrapper.textWidth = textWidth;\n                    wrapper.updateTransform();\n                }\n                if (styles && styles.textOverflow === 'ellipsis') {\n                    styles.whiteSpace = 'nowrap';\n                    styles.overflow = 'hidden';\n                }\n                wrapper.styles = extend(wrapper.styles, styles);\n                css(wrapper.element, styles);\n\n                return wrapper;\n            },\n\n            /**\n             * VML and useHTML method for calculating the bounding box based on offsets\n             * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n             * use the cached value\n             *\n             * @return {Object} A hash containing values for x, y, width and height\n             */\n\n            htmlGetBBox: function() {\n                var wrapper = this,\n                    element = wrapper.element;\n\n                // faking getBBox in exported SVG in legacy IE\n                // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n                if (element.nodeName === 'text') {\n                    element.style.position = 'absolute';\n                }\n\n                return {\n                    x: element.offsetLeft,\n                    y: element.offsetTop,\n                    width: element.offsetWidth,\n                    height: element.offsetHeight\n                };\n            },\n\n            /**\n             * VML override private method to update elements based on internal\n             * properties based on SVG transform\n             */\n            htmlUpdateTransform: function() {\n                // aligning non added elements is expensive\n                if (!this.added) {\n                    this.alignOnAdd = true;\n                    return;\n                }\n\n                var wrapper = this,\n                    renderer = wrapper.renderer,\n                    elem = wrapper.element,\n                    translateX = wrapper.translateX || 0,\n                    translateY = wrapper.translateY || 0,\n                    x = wrapper.x || 0,\n                    y = wrapper.y || 0,\n                    align = wrapper.textAlign || 'left',\n                    alignCorrection = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[align],\n                    styles = wrapper.styles;\n\n                // apply translate\n                css(elem, {\n                    marginLeft: translateX,\n                    marginTop: translateY\n                });\n\n\n                if (wrapper.shadows) { // used in labels/tooltip\n                    each(wrapper.shadows, function(shadow) {\n                        css(shadow, {\n                            marginLeft: translateX + 1,\n                            marginTop: translateY + 1\n                        });\n                    });\n                }\n\n\n                // apply inversion\n                if (wrapper.inverted) { // wrapper is a group\n                    each(elem.childNodes, function(child) {\n                        renderer.invertChild(child, elem);\n                    });\n                }\n\n                if (elem.tagName === 'SPAN') {\n\n                    var rotation = wrapper.rotation,\n                        baseline,\n                        textWidth = pInt(wrapper.textWidth),\n                        whiteSpace = styles && styles.whiteSpace,\n                        currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n                    if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                        baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                        // Renderer specific handling of span rotation\n                        if (defined(rotation)) {\n                            wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                        }\n\n                        // Reset multiline/ellipsis in order to read width (#4928, #5417)\n                        css(elem, {\n                            width: '',\n                            whiteSpace: whiteSpace || 'nowrap'\n                        });\n\n                        // Update textWidth\n                        if (elem.offsetWidth > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                            css(elem, {\n                                width: textWidth + 'px',\n                                display: 'block',\n                                whiteSpace: whiteSpace || 'normal' // #3331\n                            });\n                        }\n\n\n                        wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);\n                    }\n\n                    // apply position with correction\n                    css(elem, {\n                        left: (x + (wrapper.xCorr || 0)) + 'px',\n                        top: (y + (wrapper.yCorr || 0)) + 'px'\n                    });\n\n                    // force reflow in webkit to apply the left and top on useHTML element (#1249)\n                    if (isWebKit) {\n                        baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n                    }\n\n                    // record current text transform\n                    wrapper.cTT = currentTextTransform;\n                }\n            },\n\n            /**\n             * Set the rotation of an individual HTML span\n             */\n            setSpanRotation: function(rotation, alignCorrection, baseline) {\n                var rotationStyle = {},\n                    cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : '';\n\n                rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n                rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n                css(this.element, rotationStyle);\n            },\n\n            /**\n             * Get the correction in X and Y positioning as the element is rotated.\n             */\n            getSpanCorrection: function(width, baseline, alignCorrection) {\n                this.xCorr = -width * alignCorrection;\n                this.yCorr = -baseline;\n            }\n        });\n\n        // Extend SvgRenderer for useHTML option.\n        extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {\n            /**\n             * Create HTML text node. This is used by the VML renderer as well as the SVG\n             * renderer through the useHTML option.\n             *\n             * @param {String} str\n             * @param {Number} x\n             * @param {Number} y\n             */\n            html: function(str, x, y) {\n                var wrapper = this.createElement('span'),\n                    element = wrapper.element,\n                    renderer = wrapper.renderer,\n                    isSVG = renderer.isSVG,\n                    addSetters = function(element, style) {\n                        // These properties are set as attributes on the SVG group, and as\n                        // identical CSS properties on the div. (#3542)\n                        each(['opacity', 'visibility'], function(prop) {\n                            wrap(element, prop + 'Setter', function(proceed, value, key, elem) {\n                                proceed.call(this, value, key, elem);\n                                style[key] = value;\n                            });\n                        });\n                    };\n\n                // Text setter\n                wrapper.textSetter = function(value) {\n                    if (value !== element.innerHTML) {\n                        delete this.bBox;\n                    }\n                    element.innerHTML = this.textStr = value;\n                    wrapper.htmlUpdateTransform();\n                };\n\n                // Add setters for the element itself (#4938)\n                if (isSVG) { // #4938, only for HTML within SVG\n                    addSetters(wrapper, wrapper.element.style);\n                }\n\n                // Various setters which rely on update transform\n                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {\n                    if (key === 'align') {\n                        key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n                    }\n                    wrapper[key] = value;\n                    wrapper.htmlUpdateTransform();\n                };\n\n                // Set the default attributes\n                wrapper\n                    .attr({\n                        text: str,\n                        x: Math.round(x),\n                        y: Math.round(y)\n                    })\n                    .css({\n\n                        fontFamily: this.style.fontFamily,\n                        fontSize: this.style.fontSize,\n\n                        position: 'absolute'\n                    });\n\n                // Keep the whiteSpace style outside the wrapper.styles collection\n                element.style.whiteSpace = 'nowrap';\n\n                // Use the HTML specific .css method\n                wrapper.css = wrapper.htmlCss;\n\n                // This is specific for HTML within SVG\n                if (isSVG) {\n                    wrapper.add = function(svgGroupWrapper) {\n\n                        var htmlGroup,\n                            container = renderer.box.parentNode,\n                            parentGroup,\n                            parents = [];\n\n                        this.parentGroup = svgGroupWrapper;\n\n                        // Create a mock group to hold the HTML elements\n                        if (svgGroupWrapper) {\n                            htmlGroup = svgGroupWrapper.div;\n                            if (!htmlGroup) {\n\n                                // Read the parent chain into an array and read from top down\n                                parentGroup = svgGroupWrapper;\n                                while (parentGroup) {\n\n                                    parents.push(parentGroup);\n\n                                    // Move up to the next parent group\n                                    parentGroup = parentGroup.parentGroup;\n                                }\n\n                                // Ensure dynamically updating position when any parent is translated\n                                each(parents.reverse(), function(parentGroup) {\n                                    var htmlGroupStyle,\n                                        cls = attr(parentGroup.element, 'class');\n\n                                    if (cls) {\n                                        cls = {\n                                            className: cls\n                                        };\n                                    } // else null\n\n                                    // Create a HTML div and append it to the parent div to emulate\n                                    // the SVG group structure\n                                    htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls, {\n                                        position: 'absolute',\n                                        left: (parentGroup.translateX || 0) + 'px',\n                                        top: (parentGroup.translateY || 0) + 'px',\n                                        display: parentGroup.display,\n                                        opacity: parentGroup.opacity, // #5075\n                                        pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents // #5595\n                                    }, htmlGroup || container); // the top group is appended to container\n\n                                    // Shortcut\n                                    htmlGroupStyle = htmlGroup.style;\n\n                                    // Set listeners to update the HTML div's position whenever the SVG group\n                                    // position is changed\n                                    extend(parentGroup, {\n                                        on: function() {\n                                            wrapper.on.apply({\n                                                element: parents[0].div\n                                            }, arguments);\n                                            return parentGroup;\n                                        },\n                                        translateXSetter: function(value, key) {\n                                            htmlGroupStyle.left = value + 'px';\n                                            parentGroup[key] = value;\n                                            parentGroup.doTransform = true;\n                                        },\n                                        translateYSetter: function(value, key) {\n                                            htmlGroupStyle.top = value + 'px';\n                                            parentGroup[key] = value;\n                                            parentGroup.doTransform = true;\n                                        }\n                                    });\n                                    addSetters(parentGroup, htmlGroupStyle);\n                                });\n\n                            }\n                        } else {\n                            htmlGroup = container;\n                        }\n\n                        htmlGroup.appendChild(element);\n\n                        // Shared with VML:\n                        wrapper.added = true;\n                        if (wrapper.alignOnAdd) {\n                            wrapper.htmlUpdateTransform();\n                        }\n\n                        return wrapper;\n                    };\n                }\n                return wrapper;\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var VMLRenderer,\n            VMLRendererExtension,\n            VMLElement,\n\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            discardElement = H.discardElement,\n            doc = H.doc,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            pInt = H.pInt,\n            svg = H.svg,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            win = H.win;\n\n        /* ****************************************************************************\n         *                                                                            *\n         * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n         *                                                                            *\n         * For applications and websites that don't need IE support, like platform    *\n         * targeted mobile apps and web apps, this code can be removed.               *\n         *                                                                            *\n         *****************************************************************************/\n\n        /**\n         * @constructor\n         */\n        if (!svg) {\n\n            /**\n             * The VML element wrapper.\n             */\n            VMLElement = {\n\n                docMode8: doc && doc.documentMode === 8,\n\n                /**\n                 * Initialize a new VML element wrapper. It builds the markup as a string\n                 * to minimize DOM traffic.\n                 * @param {Object} renderer\n                 * @param {Object} nodeName\n                 */\n                init: function(renderer, nodeName) {\n                    var wrapper = this,\n                        markup = ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n                        style = ['position: ', 'absolute', ';'],\n                        isDiv = nodeName === 'div';\n\n                    // divs and shapes need size\n                    if (nodeName === 'shape' || isDiv) {\n                        style.push('left:0;top:0;width:1px;height:1px;');\n                    }\n                    style.push('visibility: ', isDiv ? 'hidden' : 'visible');\n\n                    markup.push(' style=\"', style.join(''), '\"/>');\n\n                    // create element with default attributes and style\n                    if (nodeName) {\n                        markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                            markup.join('') :\n                            renderer.prepVML(markup);\n                        wrapper.element = createElement(markup);\n                    }\n\n                    wrapper.renderer = renderer;\n                },\n\n                /**\n                 * Add the node to the given parent\n                 * @param {Object} parent\n                 */\n                add: function(parent) {\n                    var wrapper = this,\n                        renderer = wrapper.renderer,\n                        element = wrapper.element,\n                        box = renderer.box,\n                        inverted = parent && parent.inverted,\n\n                        // get the parent node\n                        parentNode = parent ?\n                        parent.element || parent :\n                        box;\n\n                    if (parent) {\n                        this.parentGroup = parent;\n                    }\n\n                    // if the parent group is inverted, apply inversion on all children\n                    if (inverted) { // only on groups\n                        renderer.invertChild(element, parentNode);\n                    }\n\n                    // append it\n                    parentNode.appendChild(element);\n\n                    // align text after adding to be able to read offset\n                    wrapper.added = true;\n                    if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n                        wrapper.updateTransform();\n                    }\n\n                    // fire an event for internal hooks\n                    if (wrapper.onAdd) {\n                        wrapper.onAdd();\n                    }\n\n                    // IE8 Standards can't set the class name before the element is appended\n                    if (this.className) {\n                        this.attr('class', this.className);\n                    }\n\n                    return wrapper;\n                },\n\n                /**\n                 * VML always uses htmlUpdateTransform\n                 */\n                updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n                /**\n                 * Set the rotation of a span with oldIE's filter\n                 */\n                setSpanRotation: function() {\n                    // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n                    // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n                    // has support for CSS3 transform. The getBBox method also needs to be updated\n                    // to compensate for the rotation, like it currently does for SVG.\n                    // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n                    var rotation = this.rotation,\n                        costheta = Math.cos(rotation * deg2rad),\n                        sintheta = Math.sin(rotation * deg2rad);\n\n                    css(this.element, {\n                        filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                            ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                            ', sizingMethod=\\'auto expand\\')'\n                        ].join('') : 'none'\n                    });\n                },\n\n                /**\n                 * Get the positioning correction for the span after rotating.\n                 */\n                getSpanCorrection: function(width, baseline, alignCorrection, rotation, align) {\n\n                    var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,\n                        sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,\n                        height = pick(this.elemHeight, this.element.offsetHeight),\n                        quad,\n                        nonLeft = align && align !== 'left';\n\n                    // correct x and y\n                    this.xCorr = costheta < 0 && -width;\n                    this.yCorr = sintheta < 0 && -height;\n\n                    // correct for baseline and corners spilling out after rotation\n                    quad = costheta * sintheta < 0;\n                    this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n                    this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n                    // correct for the length/height of the text\n                    if (nonLeft) {\n                        this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n                        if (rotation) {\n                            this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n                        }\n                        css(this.element, {\n                            textAlign: align\n                        });\n                    }\n                },\n\n                /**\n                 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n                 * as the parameter and returns a string.\n                 */\n                pathToVML: function(value) {\n                    // convert paths\n                    var i = value.length,\n                        path = [];\n\n                    while (i--) {\n\n                        // Multiply by 10 to allow subpixel precision.\n                        // Substracting half a pixel seems to make the coordinates\n                        // align with SVG, but this hasn't been tested thoroughly\n                        if (isNumber(value[i])) {\n                            path[i] = Math.round(value[i] * 10) - 5;\n                        } else if (value[i] === 'Z') { // close the path\n                            path[i] = 'x';\n                        } else {\n                            path[i] = value[i];\n\n                            // When the start X and end X coordinates of an arc are too close,\n                            // they are rounded to the same value above. In this case, substract or\n                            // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                            if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                                // Start and end X\n                                if (path[i + 5] === path[i + 7]) {\n                                    path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                                }\n                                // Start and end Y\n                                if (path[i + 6] === path[i + 8]) {\n                                    path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                                }\n                            }\n                        }\n                    }\n\n\n                    // Loop up again to handle path shortcuts (#2132)\n                    /*while (i++ < path.length) {\n                    \tif (path[i] === 'H') { // horizontal line to\n                    \t\tpath[i] = 'L';\n                    \t\tpath.splice(i + 2, 0, path[i - 1]);\n                    \t} else if (path[i] === 'V') { // vertical line to\n                    \t\tpath[i] = 'L';\n                    \t\tpath.splice(i + 1, 0, path[i - 2]);\n                    \t}\n                    }*/\n                    return path.join(' ') || 'x';\n                },\n\n                /**\n                 * Set the element's clipping to a predefined rectangle\n                 *\n                 * @param {String} id The id of the clip rectangle\n                 */\n                clip: function(clipRect) {\n                    var wrapper = this,\n                        clipMembers,\n                        cssRet;\n\n                    if (clipRect) {\n                        clipMembers = clipRect.members;\n                        erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n                        clipMembers.push(wrapper);\n                        wrapper.destroyClip = function() {\n                            erase(clipMembers, wrapper);\n                        };\n                        cssRet = clipRect.getCSS(wrapper);\n\n                    } else {\n                        if (wrapper.destroyClip) {\n                            wrapper.destroyClip();\n                        }\n                        cssRet = {\n                            clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)'\n                        }; // #1214\n                    }\n\n                    return wrapper.css(cssRet);\n\n                },\n\n                /**\n                 * Set styles for the element\n                 * @param {Object} styles\n                 */\n                css: SVGElement.prototype.htmlCss,\n\n                /**\n                 * Removes a child either by removeChild or move to garbageBin.\n                 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n                 */\n                safeRemoveChild: function(element) {\n                    // discardElement will detach the node from its parent before attaching it\n                    // to the garbage bin. Therefore it is important that the node is attached and have parent.\n                    if (element.parentNode) {\n                        discardElement(element);\n                    }\n                },\n\n                /**\n                 * Extend element.destroy by removing it from the clip members array\n                 */\n                destroy: function() {\n                    if (this.destroyClip) {\n                        this.destroyClip();\n                    }\n\n                    return SVGElement.prototype.destroy.apply(this);\n                },\n\n                /**\n                 * Add an event listener. VML override for normalizing event parameters.\n                 * @param {String} eventType\n                 * @param {Function} handler\n                 */\n                on: function(eventType, handler) {\n                    // simplest possible event model for internal use\n                    this.element['on' + eventType] = function() {\n                        var evt = win.event;\n                        evt.target = evt.srcElement;\n                        handler(evt);\n                    };\n                    return this;\n                },\n\n                /**\n                 * In stacked columns, cut off the shadows so that they don't overlap\n                 */\n                cutOffPath: function(path, length) {\n\n                    var len;\n\n                    path = path.split(/[ ,]/); // The extra comma tricks the trailing comma remover in \"gulp scripts\" task\n                    len = path.length;\n\n                    if (len === 9 || len === 11) {\n                        path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n                    }\n                    return path.join(' ');\n                },\n\n                /**\n                 * Apply a drop shadow by copying elements and giving them different strokes\n                 * @param {Boolean|Object} shadowOptions\n                 */\n                shadow: function(shadowOptions, group, cutOff) {\n                    var shadows = [],\n                        i,\n                        element = this.element,\n                        renderer = this.renderer,\n                        shadow,\n                        elemStyle = element.style,\n                        markup,\n                        path = element.path,\n                        strokeWidth,\n                        modifiedPath,\n                        shadowWidth,\n                        shadowElementOpacity;\n\n                    // some times empty paths are not strings\n                    if (path && typeof path.value !== 'string') {\n                        path = 'x';\n                    }\n                    modifiedPath = path;\n\n                    if (shadowOptions) {\n                        shadowWidth = pick(shadowOptions.width, 3);\n                        shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                        for (i = 1; i <= 3; i++) {\n\n                            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                            // Cut off shadows for stacked column items\n                            if (cutOff) {\n                                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                            }\n\n                            markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n                                '\" filled=\"false\" path=\"', modifiedPath,\n                                '\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'\n                            ];\n\n                            shadow = createElement(renderer.prepVML(markup),\n                                null, {\n                                    left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                                    top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                                }\n                            );\n                            if (cutOff) {\n                                shadow.cutOff = strokeWidth + 1;\n                            }\n\n                            // apply the opacity\n                            markup = [\n                                '<stroke color=\"',\n                                shadowOptions.color || '#000000',\n                                '\" opacity=\"', shadowElementOpacity * i, '\"/>'\n                            ];\n                            createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                            // insert it\n                            if (group) {\n                                group.element.appendChild(shadow);\n                            } else {\n                                element.parentNode.insertBefore(shadow, element);\n                            }\n\n                            // record it\n                            shadows.push(shadow);\n\n                        }\n\n                        this.shadows = shadows;\n                    }\n                    return this;\n                },\n                updateShadows: noop, // Used in SVG only\n\n                setAttr: function(key, value) {\n                    if (this.docMode8) { // IE8 setAttribute bug\n                        this.element[key] = value;\n                    } else {\n                        this.element.setAttribute(key, value);\n                    }\n                },\n                classSetter: function(value) {\n                    // IE8 Standards mode has problems retrieving the className unless set like this.\n                    // IE8 Standards can't set the class name before the element is appended.\n                    (this.added ? this.element : this).className = value;\n                },\n                dashstyleSetter: function(value, key, element) {\n                    var strokeElem = element.getElementsByTagName('stroke')[0] ||\n                        createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n                    strokeElem[key] = value || 'solid';\n                    this[key] = value;\n                    /* because changing stroke-width will change the dash length\n\t\t\t\tand cause an epileptic effect */\n                },\n                dSetter: function(value, key, element) {\n                    var i,\n                        shadows = this.shadows;\n                    value = value || [];\n                    this.d = value.join && value.join(' '); // used in getter for animation\n\n                    element.path = value = this.pathToVML(value);\n\n                    // update shadows\n                    if (shadows) {\n                        i = shadows.length;\n                        while (i--) {\n                            shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n                        }\n                    }\n                    this.setAttr(key, value);\n                },\n                fillSetter: function(value, key, element) {\n                    var nodeName = element.nodeName;\n                    if (nodeName === 'SPAN') { // text color\n                        element.style.color = value;\n                    } else if (nodeName !== 'IMG') { // #1336\n                        element.filled = value !== 'none';\n                        this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n                    }\n                },\n                'fill-opacitySetter': function(value, key, element) {\n                    createElement(\n                        this.renderer.prepVML(['<', key.split('-')[0], ' opacity=\"', value, '\"/>']),\n                        null,\n                        null,\n                        element\n                    );\n                },\n                opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n                rotationSetter: function(value, key, element) {\n                    var style = element.style;\n                    this[key] = style[key] = value; // style is for #1873\n\n                    // Correction for the 1x1 size of the shape container. Used in gauge needles.\n                    style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';\n                    style.top = Math.round(Math.cos(value * deg2rad)) + 'px';\n                },\n                strokeSetter: function(value, key, element) {\n                    this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n                },\n                'stroke-widthSetter': function(value, key, element) {\n                    element.stroked = !!value; // VML \"stroked\" attribute\n                    this[key] = value; // used in getter, issue #113\n                    if (isNumber(value)) {\n                        value += 'px';\n                    }\n                    this.setAttr('strokeweight', value);\n                },\n                titleSetter: function(value, key) {\n                    this.setAttr(key, value);\n                },\n                visibilitySetter: function(value, key, element) {\n\n                    // Handle inherited visibility\n                    if (value === 'inherit') {\n                        value = 'visible';\n                    }\n\n                    // Let the shadow follow the main element\n                    if (this.shadows) {\n                        each(this.shadows, function(shadow) {\n                            shadow.style[key] = value;\n                        });\n                    }\n\n                    // Instead of toggling the visibility CSS property, move the div out of the viewport.\n                    // This works around #61 and #586\n                    if (element.nodeName === 'DIV') {\n                        value = value === 'hidden' ? '-999em' : 0;\n\n                        // In order to redraw, IE7 needs the div to be visible when tucked away\n                        // outside the viewport. So the visibility is actually opposite of\n                        // the expected value. This applies to the tooltip only.\n                        if (!this.docMode8) {\n                            element.style[key] = value ? 'visible' : 'hidden';\n                        }\n                        key = 'top';\n                    }\n                    element.style[key] = value;\n                },\n                xSetter: function(value, key, element) {\n                    this[key] = value; // used in getter\n\n                    if (key === 'x') {\n                        key = 'left';\n                    } else if (key === 'y') {\n                        key = 'top';\n                    }\n                    /* else {\n                    \t\t\t\tvalue = Math.max(0, value); // don't set width or height below zero (#311)\n                    \t\t\t}*/\n\n                    // clipping rectangle special\n                    if (this.updateClipping) {\n                        this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n                        this.updateClipping();\n                    } else {\n                        // normal\n                        element.style[key] = value;\n                    }\n                },\n                zIndexSetter: function(value, key, element) {\n                    element.style[key] = value;\n                }\n            };\n            VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n            H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n            // Some shared setters\n            VMLElement.prototype.ySetter =\n                VMLElement.prototype.widthSetter =\n                VMLElement.prototype.heightSetter =\n                VMLElement.prototype.xSetter;\n\n\n            /**\n             * The VML renderer\n             */\n            VMLRendererExtension = { // inherit SVGRenderer\n\n                Element: VMLElement,\n                isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,\n\n\n                /**\n                 * Initialize the VMLRenderer\n                 * @param {Object} container\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                init: function(container, width, height) {\n                    var renderer = this,\n                        boxWrapper,\n                        box,\n                        css;\n\n                    renderer.alignedObjects = [];\n\n                    boxWrapper = renderer.createElement('div')\n                        .css({\n                            position: 'relative'\n                        });\n                    box = boxWrapper.element;\n                    container.appendChild(boxWrapper.element);\n\n\n                    // generate the containing box\n                    renderer.isVML = true;\n                    renderer.box = box;\n                    renderer.boxWrapper = boxWrapper;\n                    renderer.gradients = {};\n                    renderer.cache = {}; // Cache for numerical bounding boxes\n                    renderer.cacheKeys = [];\n                    renderer.imgCount = 0;\n\n\n                    renderer.setSize(width, height, false);\n\n                    // The only way to make IE6 and IE7 print is to use a global namespace. However,\n                    // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n                    // seems to be to add the xmlns attribute and the behaviour style inline.\n                    if (!doc.namespaces.hcv) {\n\n                        doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n                        // Setup default CSS (#2153, #2368, #2384)\n                        css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                            '{ behavior:url(#default#VML); display: inline-block; } ';\n                        try {\n                            doc.createStyleSheet().cssText = css;\n                        } catch (e) {\n                            doc.styleSheets[0].cssText += css;\n                        }\n\n                    }\n                },\n\n\n                /**\n                 * Detect whether the renderer is hidden. This happens when one of the parent elements\n                 * has display: none\n                 */\n                isHidden: function() {\n                    return !this.box.offsetWidth;\n                },\n\n                /**\n                 * Define a clipping rectangle. In VML it is accomplished by storing the values\n                 * for setting the CSS style to all associated members.\n                 *\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                clipRect: function(x, y, width, height) {\n\n                    // create a dummy element\n                    var clipRect = this.createElement(),\n                        isObj = isObject(x);\n\n                    // mimic a rectangle with its style object for automatic updating in attr\n                    return extend(clipRect, {\n                        members: [],\n                        count: 0,\n                        left: (isObj ? x.x : x) + 1,\n                        top: (isObj ? x.y : y) + 1,\n                        width: (isObj ? x.width : width) - 1,\n                        height: (isObj ? x.height : height) - 1,\n                        getCSS: function(wrapper) {\n                            var element = wrapper.element,\n                                nodeName = element.nodeName,\n                                isShape = nodeName === 'shape',\n                                inverted = wrapper.inverted,\n                                rect = this,\n                                top = rect.top - (isShape ? element.offsetTop : 0),\n                                left = rect.left,\n                                right = left + rect.width,\n                                bottom = top + rect.height,\n                                ret = {\n                                    clip: 'rect(' +\n                                        Math.round(inverted ? left : top) + 'px,' +\n                                        Math.round(inverted ? bottom : right) + 'px,' +\n                                        Math.round(inverted ? right : bottom) + 'px,' +\n                                        Math.round(inverted ? top : left) + 'px)'\n                                };\n\n                            // issue 74 workaround\n                            if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {\n                                extend(ret, {\n                                    width: right + 'px',\n                                    height: bottom + 'px'\n                                });\n                            }\n                            return ret;\n                        },\n\n                        // used in attr and animation to update the clipping of all members\n                        updateClipping: function() {\n                            each(clipRect.members, function(member) {\n                                // Member.element is falsy on deleted series, like in\n                                // stock/members/series-remove demo. Should be removed\n                                // from members, but this will do.\n                                if (member.element) {\n                                    member.css(clipRect.getCSS(member));\n                                }\n                            });\n                        }\n                    });\n\n                },\n\n\n                /**\n                 * Take a color and return it if it's a string, make it a gradient if it's a\n                 * gradient configuration object, and apply opacity.\n                 *\n                 * @param {Object} color The color or config object\n                 */\n                color: function(color, elem, prop, wrapper) {\n                    var renderer = this,\n                        colorObject,\n                        regexRgba = /^rgba/,\n                        markup,\n                        fillType,\n                        ret = 'none';\n\n                    // Check for linear or radial gradient\n                    if (color && color.linearGradient) {\n                        fillType = 'gradient';\n                    } else if (color && color.radialGradient) {\n                        fillType = 'pattern';\n                    }\n\n\n                    if (fillType) {\n\n                        var stopColor,\n                            stopOpacity,\n                            gradient = color.linearGradient || color.radialGradient,\n                            x1,\n                            y1,\n                            x2,\n                            y2,\n                            opacity1,\n                            opacity2,\n                            color1,\n                            color2,\n                            fillAttr = '',\n                            stops = color.stops,\n                            firstStop,\n                            lastStop,\n                            colors = [],\n                            addFillNode = function() {\n                                // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                                // are reversed.\n                                markup = ['<fill colors=\"' + colors.join(',') +\n                                    '\" opacity=\"', opacity2, '\" o:opacity2=\"',\n                                    opacity1, '\" type=\"', fillType, '\" ', fillAttr,\n                                    'focus=\"100%\" method=\"any\" />'\n                                ];\n                                createElement(renderer.prepVML(markup), null, null, elem);\n                            };\n\n                        // Extend from 0 to 1\n                        firstStop = stops[0];\n                        lastStop = stops[stops.length - 1];\n                        if (firstStop[0] > 0) {\n                            stops.unshift([\n                                0,\n                                firstStop[1]\n                            ]);\n                        }\n                        if (lastStop[0] < 1) {\n                            stops.push([\n                                1,\n                                lastStop[1]\n                            ]);\n                        }\n\n                        // Compute the stops\n                        each(stops, function(stop, i) {\n                            if (regexRgba.test(stop[1])) {\n                                colorObject = H.color(stop[1]);\n                                stopColor = colorObject.get('rgb');\n                                stopOpacity = colorObject.get('a');\n                            } else {\n                                stopColor = stop[1];\n                                stopOpacity = 1;\n                            }\n\n                            // Build the color attribute\n                            colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                            // Only start and end opacities are allowed, so we use the first and the last\n                            if (!i) {\n                                opacity1 = stopOpacity;\n                                color2 = stopColor;\n                            } else {\n                                opacity2 = stopOpacity;\n                                color1 = stopColor;\n                            }\n                        });\n\n                        // Apply the gradient to fills only.\n                        if (prop === 'fill') {\n\n                            // Handle linear gradient angle\n                            if (fillType === 'gradient') {\n                                x1 = gradient.x1 || gradient[0] || 0;\n                                y1 = gradient.y1 || gradient[1] || 0;\n                                x2 = gradient.x2 || gradient[2] || 0;\n                                y2 = gradient.y2 || gradient[3] || 0;\n                                fillAttr = 'angle=\"' + (90 - Math.atan(\n                                    (y2 - y1) / // y vector\n                                    (x2 - x1) // x vector\n                                ) * 180 / Math.PI) + '\"';\n\n                                addFillNode();\n\n                                // Radial (circular) gradient\n                            } else {\n\n                                var r = gradient.r,\n                                    sizex = r * 2,\n                                    sizey = r * 2,\n                                    cx = gradient.cx,\n                                    cy = gradient.cy,\n                                    radialReference = elem.radialReference,\n                                    bBox,\n                                    applyRadialGradient = function() {\n                                        if (radialReference) {\n                                            bBox = wrapper.getBBox();\n                                            cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                            cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                            sizex *= radialReference[2] / bBox.width;\n                                            sizey *= radialReference[2] / bBox.height;\n                                        }\n                                        fillAttr = 'src=\"' + H.getOptions().global.VMLRadialGradientURL + '\" ' +\n                                            'size=\"' + sizex + ',' + sizey + '\" ' +\n                                            'origin=\"0.5,0.5\" ' +\n                                            'position=\"' + cx + ',' + cy + '\" ' +\n                                            'color2=\"' + color2 + '\" ';\n\n                                        addFillNode();\n                                    };\n\n                                // Apply radial gradient\n                                if (wrapper.added) {\n                                    applyRadialGradient();\n                                } else {\n                                    // We need to know the bounding box to get the size and position right\n                                    wrapper.onAdd = applyRadialGradient;\n                                }\n\n                                // The fill element's color attribute is broken in IE8 standards mode, so we\n                                // need to set the parent shape's fillcolor attribute instead.\n                                ret = color1;\n                            }\n\n                            // Gradients are not supported for VML stroke, return the first color. #722.\n                        } else {\n                            ret = stopColor;\n                        }\n\n                        // If the color is an rgba color, split it and add a fill node\n                        // to hold the opacity component\n                    } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n                        colorObject = H.color(color);\n\n                        wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n                        ret = colorObject.get('rgb');\n\n\n                    } else {\n                        var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n                        if (propNodes.length) {\n                            propNodes[0].opacity = 1;\n                            propNodes[0].type = 'solid';\n                        }\n                        ret = color;\n                    }\n\n                    return ret;\n                },\n\n                /**\n                 * Take a VML string and prepare it for either IE8 or IE6/IE7.\n                 * @param {Array} markup A string array of the VML markup to prepare\n                 */\n                prepVML: function(markup) {\n                    var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n                        isIE8 = this.isIE8;\n\n                    markup = markup.join('');\n\n                    if (isIE8) { // add xmlns and style inline\n                        markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n                        if (markup.indexOf('style=\"') === -1) {\n                            markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n                        } else {\n                            markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n                        }\n\n                    } else { // add namespace\n                        markup = markup.replace('<', '<hcv:');\n                    }\n\n                    return markup;\n                },\n\n                /**\n                 * Create rotated and aligned text\n                 * @param {String} str\n                 * @param {Number} x\n                 * @param {Number} y\n                 */\n                text: SVGRenderer.prototype.html,\n\n                /**\n                 * Create and return a path element\n                 * @param {Array} path\n                 */\n                path: function(path) {\n                    var attr = {\n                        // subpixel precision down to 0.1 (width and height = 1px)\n                        coordsize: '10 10'\n                    };\n                    if (isArray(path)) {\n                        attr.d = path;\n                    } else if (isObject(path)) { // attributes\n                        extend(attr, path);\n                    }\n                    // create the shape\n                    return this.createElement('shape').attr(attr);\n                },\n\n                /**\n                 * Create and return a circle element. In VML circles are implemented as\n                 * shapes, which is faster than v:oval\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} r\n                 */\n                circle: function(x, y, r) {\n                    var circle = this.symbol('circle');\n                    if (isObject(x)) {\n                        r = x.r;\n                        y = x.y;\n                        x = x.x;\n                    }\n                    circle.isCircle = true; // Causes x and y to mean center (#1682)\n                    circle.r = r;\n                    return circle.attr({\n                        x: x,\n                        y: y\n                    });\n                },\n\n                /**\n                 * Create a group using an outer div and an inner v:group to allow rotating\n                 * and flipping. A simple v:group would have problems with positioning\n                 * child HTML elements and CSS clip.\n                 *\n                 * @param {String} name The name of the group\n                 */\n                g: function(name) {\n                    var wrapper,\n                        attribs;\n\n                    // set the class name\n                    if (name) {\n                        attribs = {\n                            'className': 'highcharts-' + name,\n                            'class': 'highcharts-' + name\n                        };\n                    }\n\n                    // the div to hold HTML and clipping\n                    wrapper = this.createElement('div').attr(attribs);\n\n                    return wrapper;\n                },\n\n                /**\n                 * VML override to create a regular HTML image\n                 * @param {String} src\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                image: function(src, x, y, width, height) {\n                    var obj = this.createElement('img')\n                        .attr({\n                            src: src\n                        });\n\n                    if (arguments.length > 1) {\n                        obj.attr({\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        });\n                    }\n                    return obj;\n                },\n\n                /**\n                 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n                 */\n                createElement: function(nodeName) {\n                    return nodeName === 'rect' ?\n                        this.symbol(nodeName) :\n                        SVGRenderer.prototype.createElement.call(this, nodeName);\n                },\n\n                /**\n                 * In the VML renderer, each child of an inverted div (group) is inverted\n                 * @param {Object} element\n                 * @param {Object} parentNode\n                 */\n                invertChild: function(element, parentNode) {\n                    var ren = this,\n                        parentStyle = parentNode.style,\n                        imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n                    css(element, {\n                        flip: 'x',\n                        left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n                        top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n                        rotation: -90\n                    });\n\n                    // Recursively invert child elements, needed for nested composite\n                    // shapes like box plots and error bars. #1680, #1806.\n                    each(element.childNodes, function(child) {\n                        ren.invertChild(child, element);\n                    });\n                },\n\n                /**\n                 * Symbol definitions that override the parent SVG renderer's symbols\n                 *\n                 */\n                symbols: {\n                    // VML specific arc function\n                    arc: function(x, y, w, h, options) {\n                        var start = options.start,\n                            end = options.end,\n                            radius = options.r || w || h,\n                            innerRadius = options.innerR,\n                            cosStart = Math.cos(start),\n                            sinStart = Math.sin(start),\n                            cosEnd = Math.cos(end),\n                            sinEnd = Math.sin(end),\n                            ret;\n\n                        if (end - start === 0) { // no angle, don't show it.\n                            return ['x'];\n                        }\n\n                        ret = [\n                            'wa', // clockwise arc to\n                            x - radius, // left\n                            y - radius, // top\n                            x + radius, // right\n                            y + radius, // bottom\n                            x + radius * cosStart, // start x\n                            y + radius * sinStart, // start y\n                            x + radius * cosEnd, // end x\n                            y + radius * sinEnd // end y\n                        ];\n\n                        if (options.open && !innerRadius) {\n                            ret.push(\n                                'e',\n                                'M',\n                                x, // - innerRadius,\n                                y // - innerRadius\n                            );\n                        }\n\n                        ret.push(\n                            'at', // anti clockwise arc to\n                            x - innerRadius, // left\n                            y - innerRadius, // top\n                            x + innerRadius, // right\n                            y + innerRadius, // bottom\n                            x + innerRadius * cosEnd, // start x\n                            y + innerRadius * sinEnd, // start y\n                            x + innerRadius * cosStart, // end x\n                            y + innerRadius * sinStart, // end y\n                            'x', // finish path\n                            'e' // close\n                        );\n\n                        ret.isArc = true;\n                        return ret;\n\n                    },\n                    // Add circle symbol path. This performs significantly faster than v:oval.\n                    circle: function(x, y, w, h, wrapper) {\n\n                        if (wrapper && defined(wrapper.r)) {\n                            w = h = 2 * wrapper.r;\n                        }\n\n                        // Center correction, #1682\n                        if (wrapper && wrapper.isCircle) {\n                            x -= w / 2;\n                            y -= h / 2;\n                        }\n\n                        // Return the path\n                        return [\n                            'wa', // clockwisearcto\n                            x, // left\n                            y, // top\n                            x + w, // right\n                            y + h, // bottom\n                            x + w, // start x\n                            y + h / 2, // start y\n                            x + w, // end x\n                            y + h / 2, // end y\n                            //'x', // finish path\n                            'e' // close\n                        ];\n                    },\n                    /**\n                     * Add rectangle symbol path which eases rotation and omits arcsize problems\n                     * compared to the built-in VML roundrect shape. When borders are not rounded,\n                     * use the simpler square path, else use the callout path without the arrow.\n                     */\n                    rect: function(x, y, w, h, options) {\n                        return SVGRenderer.prototype.symbols[!defined(options) || !options.r ? 'square' : 'callout'].call(0, x, y, w, h, options);\n                    }\n                }\n            };\n            H.VMLRenderer = VMLRenderer = function() {\n                this.init.apply(this, arguments);\n            };\n            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n            // general renderer\n            H.Renderer = VMLRenderer;\n        }\n\n        // This method is used with exporting in old IE, when emulating SVG (see #2314)\n        SVGRenderer.prototype.measureSpanWidth = function(text, styles) {\n            var measuringSpan = doc.createElement('span'),\n                offsetWidth,\n                textNode = doc.createTextNode(text);\n\n            measuringSpan.appendChild(textNode);\n            css(measuringSpan, styles);\n            this.box.appendChild(measuringSpan);\n            offsetWidth = measuringSpan.offsetWidth;\n            discardElement(measuringSpan); // #2463\n            return offsetWidth;\n        };\n\n\n        /* ****************************************************************************\n         *                                                                            *\n         * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n         *                                                                            *\n         *****************************************************************************/\n\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var color = H.color,\n            each = H.each,\n            getTZOffset = H.getTZOffset,\n            isTouchDevice = H.isTouchDevice,\n            merge = H.merge,\n            pick = H.pick,\n            svg = H.svg,\n            win = H.win;\n\n        /* ****************************************************************************\n         * Handle the options                                                         *\n         *****************************************************************************/\n        H.defaultOptions = {\n\n            colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),\n\n            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n            lang: {\n                loading: 'Loading...',\n                months: [\n                    'January', 'February', 'March', 'April', 'May', 'June', 'July',\n                    'August', 'September', 'October', 'November', 'December'\n                ],\n                shortMonths: [\n                    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n                    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n                ],\n                weekdays: [\n                    'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n                    'Thursday', 'Friday', 'Saturday'\n                ],\n                // invalidDate: '',\n                decimalPoint: '.',\n                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n                resetZoom: 'Reset zoom',\n                resetZoomTitle: 'Reset zoom level 1:1',\n                thousandsSep: ' '\n            },\n            global: {\n                useUTC: true,\n                //timezoneOffset: 0,\n\n                VMLRadialGradientURL: 'http://code.highcharts.com/5.0.12/gfx/vml-radial-gradient.png'\n\n            },\n            chart: {\n                //animation: true,\n                //alignTicks: false,\n                //reflow: true,\n                //className: null,\n                //events: { load, selection },\n                //margin: [null],\n                //marginTop: null,\n                //marginRight: null,\n                //marginBottom: null,\n                //marginLeft: null,\n                borderRadius: 0,\n\n                defaultSeriesType: 'line',\n                ignoreHiddenSeries: true,\n                //inverted: false,\n                spacing: [10, 10, 15, 10],\n                //spacingTop: 10,\n                //spacingRight: 10,\n                //spacingBottom: 15,\n                //spacingLeft: 10,\n                //zoomType: ''\n                resetZoomButton: {\n                    theme: {\n                        zIndex: 20\n                    },\n                    position: {\n                        align: 'right',\n                        x: -10,\n                        //verticalAlign: 'top',\n                        y: 10\n                    }\n                    // relativeTo: 'plot'\n                },\n                width: null,\n                height: null,\n\n\n                borderColor: '#335cad',\n                //borderWidth: 0,\n                //style: {\n                //\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n                //\tfontSize: '12px'\n                //},\n                backgroundColor: '#ffffff',\n                //plotBackgroundColor: null,\n                plotBorderColor: '#cccccc'\n                //plotBorderWidth: 0,\n                //plotShadow: false\n\n            },\n            title: {\n                text: 'Chart title',\n                align: 'center',\n                // floating: false,\n                margin: 15,\n                // x: 0,\n                // verticalAlign: 'top',\n                // y: null,\n                // style: {}, // defined inline\n                widthAdjust: -44\n\n            },\n            subtitle: {\n                text: '',\n                align: 'center',\n                // floating: false\n                // x: 0,\n                // verticalAlign: 'top',\n                // y: null,\n                // style: {}, // defined inline\n                widthAdjust: -44\n            },\n\n            plotOptions: {},\n            labels: {\n                //items: [],\n                style: {\n                    //font: defaultFont,\n                    position: 'absolute',\n                    color: '#333333'\n                }\n            },\n            legend: {\n                enabled: true,\n                align: 'center',\n                //floating: false,\n                layout: 'horizontal',\n                labelFormatter: function() {\n                    return this.name;\n                },\n                //borderWidth: 0,\n                borderColor: '#999999',\n                borderRadius: 0,\n                navigation: {\n\n                    activeColor: '#003399',\n                    inactiveColor: '#cccccc'\n\n                    // animation: true,\n                    // arrowSize: 12\n                    // style: {} // text styles\n                },\n                // margin: 20,\n                // reversed: false,\n                // backgroundColor: null,\n                /*style: {\n                \tpadding: '5px'\n                },*/\n\n                itemStyle: {\n                    color: '#333333',\n                    fontSize: '12px',\n                    fontWeight: 'bold',\n                    textOverflow: 'ellipsis'\n                },\n                itemHoverStyle: {\n                    //cursor: 'pointer', removed as of #601\n                    color: '#000000'\n                },\n                itemHiddenStyle: {\n                    color: '#cccccc'\n                },\n                shadow: false,\n\n                itemCheckboxStyle: {\n                    position: 'absolute',\n                    width: '13px', // for IE precision\n                    height: '13px'\n                },\n                // itemWidth: undefined,\n                squareSymbol: true,\n                // symbolRadius: 0,\n                // symbolWidth: 16,\n                symbolPadding: 5,\n                verticalAlign: 'bottom',\n                // width: undefined,\n                x: 0,\n                y: 0,\n                title: {\n                    //text: null,\n\n                    style: {\n                        fontWeight: 'bold'\n                    }\n\n                }\n            },\n\n            loading: {\n                // hideDuration: 100,\n                // showDuration: 0,\n\n                labelStyle: {\n                    fontWeight: 'bold',\n                    position: 'relative',\n                    top: '45%'\n                },\n                style: {\n                    position: 'absolute',\n                    backgroundColor: '#ffffff',\n                    opacity: 0.5,\n                    textAlign: 'center'\n                }\n\n            },\n\n            tooltip: {\n                enabled: true,\n                animation: svg,\n                //crosshairs: null,\n                borderRadius: 3,\n                dateTimeLabelFormats: {\n                    millisecond: '%A, %b %e, %H:%M:%S.%L',\n                    second: '%A, %b %e, %H:%M:%S',\n                    minute: '%A, %b %e, %H:%M',\n                    hour: '%A, %b %e, %H:%M',\n                    day: '%A, %b %e, %Y',\n                    week: 'Week from %A, %b %e, %Y',\n                    month: '%B %Y',\n                    year: '%Y'\n                },\n                footerFormat: '',\n                //formatter: defaultFormatter,\n                /* todo: em font-size when finished comparing against HC4\n                headerFormat: '<span style=\"font-size: 0.85em\">{point.key}</span><br/>',\n                */\n                padding: 8,\n\n                //shape: 'callout',\n                //shared: false,\n                snap: isTouchDevice ? 25 : 10,\n\n                backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),\n                borderWidth: 1,\n                headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n                shadow: true,\n                style: {\n                    color: '#333333',\n                    cursor: 'default',\n                    fontSize: '12px',\n                    pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events\n                    whiteSpace: 'nowrap'\n                }\n\n                //xDateFormat: '%A, %b %e, %Y',\n                //valueDecimals: null,\n                //valuePrefix: '',\n                //valueSuffix: ''\n            },\n\n            credits: {\n                enabled: true,\n                href: 'http://www.highcharts.com',\n                position: {\n                    align: 'right',\n                    x: -10,\n                    verticalAlign: 'bottom',\n                    y: -5\n                },\n\n                style: {\n                    cursor: 'pointer',\n                    color: '#999999',\n                    fontSize: '9px'\n                },\n\n                text: 'Highcharts.com'\n            }\n        };\n\n\n\n        /**\n         * Sets the getTimezoneOffset function. If the timezone option is set, a default\n         * getTimezoneOffset function with that timezone is returned. If not, the\n         * specified getTimezoneOffset function is returned. If neither are specified,\n         * undefined is returned.\n         * @return {function} a getTimezoneOffset function or undefined\n         */\n        function getTimezoneOffsetOption() {\n            var globalOptions = H.defaultOptions.global,\n                moment = win.moment;\n\n            if (globalOptions.timezone) {\n                if (!moment) {\n                    // getTimezoneOffset-function stays undefined because it depends on\n                    // Moment.js\n                    H.error(25);\n\n                } else {\n                    return function(timestamp) {\n                        return -moment.tz(\n                            timestamp,\n                            globalOptions.timezone\n                        ).utcOffset();\n                    };\n                }\n            }\n\n            // If not timezone is set, look for the getTimezoneOffset callback\n            return globalOptions.useUTC && globalOptions.getTimezoneOffset;\n        }\n\n        /**\n         * Set the time methods globally based on the useUTC option. Time method can be\n         *   either local time or UTC (default). It is called internally on initiating\n         *   Highcharts and after running `Highcharts.setOptions`.\n         *\n         * @private\n         */\n        function setTimeMethods() {\n            var globalOptions = H.defaultOptions.global,\n                Date,\n                useUTC = globalOptions.useUTC,\n                GET = useUTC ? 'getUTC' : 'get',\n                SET = useUTC ? 'setUTC' : 'set';\n\n            H.Date = Date = globalOptions.Date || win.Date; // Allow using a different Date class\n            Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;\n            Date.hcGetTimezoneOffset = getTimezoneOffsetOption();\n            Date.hcMakeTime = function(year, month, date, hours, minutes, seconds) {\n                var d;\n                if (useUTC) {\n                    d = Date.UTC.apply(0, arguments);\n                    d += getTZOffset(d);\n                } else {\n                    d = new Date(\n                        year,\n                        month,\n                        pick(date, 1),\n                        pick(hours, 0),\n                        pick(minutes, 0),\n                        pick(seconds, 0)\n                    ).getTime();\n                }\n                return d;\n            };\n            each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function(s) {\n                Date['hcGet' + s] = GET + s;\n            });\n            each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function(s) {\n                Date['hcSet' + s] = SET + s;\n            });\n        }\n\n        /**\n         * Merge the default options with custom options and return the new options\n         * structure. Commonly used for defining reusable templates.\n         *\n         * @function #setOptions\n         * @memberOf  Highcharts\n         * @sample highcharts/global/useutc-false Setting a global option\n         * @sample highcharts/members/setoptions Applying a global theme\n         * @param {Object} options The new custom chart options.\n         * @returns {Object} Updated options.\n         */\n        H.setOptions = function(options) {\n\n            // Copy in the default options\n            H.defaultOptions = merge(true, H.defaultOptions, options);\n\n            // Apply UTC\n            setTimeMethods();\n\n            return H.defaultOptions;\n        };\n\n        /**\n         * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n         * wasn't enough because the setOptions method created a new object.\n         */\n        H.getOptions = function() {\n            return H.defaultOptions;\n        };\n\n\n        // Series defaults\n        H.defaultPlotOptions = H.defaultOptions.plotOptions;\n\n        // set the default time methods\n        setTimeMethods();\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var correctFloat = H.correctFloat,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            isNumber = H.isNumber,\n            merge = H.merge,\n            pick = H.pick,\n            deg2rad = H.deg2rad;\n\n        /**\n         * The Tick class\n         */\n        H.Tick = function(axis, pos, type, noLabel) {\n            this.axis = axis;\n            this.pos = pos;\n            this.type = type || '';\n            this.isNew = true;\n            this.isNewLabel = true;\n\n            if (!type && !noLabel) {\n                this.addLabel();\n            }\n        };\n\n        H.Tick.prototype = {\n            /**\n             * Write the tick label\n             */\n            addLabel: function() {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    chart = axis.chart,\n                    categories = axis.categories,\n                    names = axis.names,\n                    pos = tick.pos,\n                    labelOptions = options.labels,\n                    str,\n                    tickPositions = axis.tickPositions,\n                    isFirst = pos === tickPositions[0],\n                    isLast = pos === tickPositions[tickPositions.length - 1],\n                    value = categories ?\n                    pick(categories[pos], names[pos], pos) :\n                    pos,\n                    label = tick.label,\n                    tickPositionInfo = tickPositions.info,\n                    dateTimeLabelFormat;\n\n                // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n                // use the general format.\n                if (axis.isDatetimeAxis && tickPositionInfo) {\n                    dateTimeLabelFormat =\n                        options.dateTimeLabelFormats[\n                            tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName\n                        ];\n                }\n                // set properties for access in render method\n                tick.isFirst = isFirst;\n                tick.isLast = isLast;\n\n                // get the string\n                str = axis.labelFormatter.call({\n                    axis: axis,\n                    chart: chart,\n                    isFirst: isFirst,\n                    isLast: isLast,\n                    dateTimeLabelFormat: dateTimeLabelFormat,\n                    value: axis.isLog ? correctFloat(axis.lin2log(value)) : value\n                });\n\n                // prepare CSS\n                //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };\n\n                // first call\n                if (!defined(label)) {\n\n                    tick.label = label =\n                        defined(str) && labelOptions.enabled ?\n                        chart.renderer.text(\n                            str,\n                            0,\n                            0,\n                            labelOptions.useHTML\n                        )\n\n                        // without position absolute, IE export sometimes is wrong\n                        .css(merge(labelOptions.style))\n\n                        .add(axis.labelGroup) :\n                        null;\n                    tick.labelLength = label && label.getBBox().width; // Un-rotated length\n                    tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n                    // update\n                } else if (label) {\n                    label.attr({\n                        text: str\n                    });\n                }\n            },\n\n            /**\n             * Get the offset height or width of the label\n             */\n            getLabelSize: function() {\n                return this.label ?\n                    this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n                    0;\n            },\n\n            /**\n             * Handle the label overflow by adjusting the labels to the left and right edge, or\n             * hide them if they collide into the neighbour label.\n             */\n            handleOverflow: function(xy) {\n                var axis = this.axis,\n                    pxPos = xy.x,\n                    chartWidth = axis.chart.chartWidth,\n                    spacing = axis.chart.spacing,\n                    leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n                    rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),\n                    label = this.label,\n                    rotation = this.rotation,\n                    factor = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[axis.labelAlign],\n                    labelWidth = label.getBBox().width,\n                    slotWidth = axis.getSlotWidth(),\n                    modifiedSlotWidth = slotWidth,\n                    xCorrection = factor,\n                    goRight = 1,\n                    leftPos,\n                    rightPos,\n                    textWidth,\n                    css = {};\n\n                // Check if the label overshoots the chart spacing box. If it does, move it.\n                // If it now overshoots the slotWidth, add ellipsis.\n                if (!rotation) {\n                    leftPos = pxPos - factor * labelWidth;\n                    rightPos = pxPos + (1 - factor) * labelWidth;\n\n                    if (leftPos < leftBound) {\n                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n                    } else if (rightPos > rightBound) {\n                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n                        goRight = -1;\n                    }\n\n                    modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n                    if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *\n                            (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n                    }\n                    // If the label width exceeds the available space, set a text width to be\n                    // picked up below. Also, if a width has been set before, we need to set a new\n                    // one because the reported labelWidth will be limited by the box (#3938).\n                    if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {\n                        textWidth = modifiedSlotWidth;\n                    }\n\n                    // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n                    textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n                    textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n                }\n\n                if (textWidth) {\n                    css.width = textWidth;\n                    if (!(axis.options.labels.style || {}).textOverflow) {\n                        css.textOverflow = 'ellipsis';\n                    }\n                    label.css(css);\n                }\n            },\n\n            /**\n             * Get the x and y position for ticks and labels\n             */\n            getPosition: function(horiz, pos, tickmarkOffset, old) {\n                var axis = this.axis,\n                    chart = axis.chart,\n                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n                return {\n                    x: horiz ?\n                        axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset +\n                        (axis.opposite ?\n                            ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :\n                            0\n                        ),\n\n                    y: horiz ?\n                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n                };\n\n            },\n\n            /**\n             * Get the x, y position of the tick label\n             */\n            getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n                var axis = this.axis,\n                    transA = axis.transA,\n                    reversed = axis.reversed,\n                    staggerLines = axis.staggerLines,\n                    rotCorr = axis.tickRotCorr || {\n                        x: 0,\n                        y: 0\n                    },\n                    yOffset = labelOptions.y,\n                    line;\n\n                if (!defined(yOffset)) {\n                    if (axis.side === 0) {\n                        yOffset = label.rotation ? -8 : -label.getBBox().height;\n                    } else if (axis.side === 2) {\n                        yOffset = rotCorr.y + 8;\n                    } else {\n                        // #3140, #3140\n                        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n                    }\n                }\n\n                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n                    tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n                y = y + yOffset - (tickmarkOffset && !horiz ?\n                    tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n                // Correct for staggered labels\n                if (staggerLines) {\n                    line = (index / (step || 1) % staggerLines);\n                    if (axis.opposite) {\n                        line = staggerLines - line - 1;\n                    }\n                    y += line * (axis.labelOffset / staggerLines);\n                }\n\n                return {\n                    x: x,\n                    y: Math.round(y)\n                };\n            },\n\n            /**\n             * Extendible method to return the path of the marker\n             */\n            getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {\n                return renderer.crispLine([\n                    'M',\n                    x,\n                    y,\n                    'L',\n                    x + (horiz ? 0 : -tickLength),\n                    y + (horiz ? tickLength : 0)\n                ], tickWidth);\n            },\n\n            /**\n             * Renders the gridLine.\n             * @param  {Boolean} old         Whether or not the tick is old\n             * @param  {number} opacity      The opacity of the grid line\n             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n             * @return {undefined}\n             */\n            renderGridLine: function(old, opacity, reverseCrisp) {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    gridLine = tick.gridLine,\n                    gridLinePath,\n                    attribs = {},\n                    pos = tick.pos,\n                    type = tick.type,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    renderer = axis.chart.renderer;\n\n\n                var gridPrefix = type ? type + 'Grid' : 'grid',\n                    gridLineWidth = options[gridPrefix + 'LineWidth'],\n                    gridLineColor = options[gridPrefix + 'LineColor'],\n                    dashStyle = options[gridPrefix + 'LineDashStyle'];\n\n\n                if (!gridLine) {\n\n                    attribs.stroke = gridLineColor;\n                    attribs['stroke-width'] = gridLineWidth;\n                    if (dashStyle) {\n                        attribs.dashstyle = dashStyle;\n                    }\n\n                    if (!type) {\n                        attribs.zIndex = 1;\n                    }\n                    if (old) {\n                        attribs.opacity = 0;\n                    }\n                    tick.gridLine = gridLine = renderer.path()\n                        .attr(attribs)\n                        .addClass(\n                            'highcharts-' + (type ? type + '-' : '') + 'grid-line'\n                        )\n                        .add(axis.gridGroup);\n                }\n\n                // If the parameter 'old' is set, the current call will be followed\n                // by another call, therefore do not do any animations this time\n                if (!old && gridLine) {\n                    gridLinePath = axis.getPlotLinePath(\n                        pos + tickmarkOffset,\n                        gridLine.strokeWidth() * reverseCrisp,\n                        old, true\n                    );\n                    if (gridLinePath) {\n                        gridLine[tick.isNew ? 'attr' : 'animate']({\n                            d: gridLinePath,\n                            opacity: opacity\n                        });\n                    }\n                }\n            },\n\n            /**\n             * Renders the tick mark.\n             * @param  {Object} xy           The position vector of the mark\n             * @param  {number} xy.x         The x position of the mark\n             * @param  {number} xy.y         The y position of the mark\n             * @param  {number} opacity      The opacity of the mark\n             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n             * @return {undefined}\n             */\n            renderMark: function(xy, opacity, reverseCrisp) {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    renderer = axis.chart.renderer,\n                    type = tick.type,\n                    tickPrefix = type ? type + 'Tick' : 'tick',\n                    tickSize = axis.tickSize(tickPrefix),\n                    mark = tick.mark,\n                    isNewMark = !mark,\n                    x = xy.x,\n                    y = xy.y;\n\n\n                var tickWidth = pick(\n                        options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0\n                    ), // X axis defaults to 1\n                    tickColor = options[tickPrefix + 'Color'];\n\n\n                if (tickSize) {\n\n                    // negate the length\n                    if (axis.opposite) {\n                        tickSize[0] = -tickSize[0];\n                    }\n\n                    // First time, create it\n                    if (isNewMark) {\n                        tick.mark = mark = renderer.path()\n                            .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')\n                            .add(axis.axisGroup);\n\n\n                        mark.attr({\n                            stroke: tickColor,\n                            'stroke-width': tickWidth\n                        });\n\n                    }\n                    mark[isNewMark ? 'attr' : 'animate']({\n                        d: tick.getMarkPath(\n                            x,\n                            y,\n                            tickSize[0],\n                            mark.strokeWidth() * reverseCrisp,\n                            axis.horiz,\n                            renderer),\n                        opacity: opacity\n                    });\n\n                }\n            },\n\n            /**\n             * Renders the tick label.\n             * Note: The label should already be created in init(), so it should only\n             * have to be moved into place.\n             * @param  {Object} xy      The position vector of the label\n             * @param  {number} xy.x    The x position of the label\n             * @param  {number} xy.y    The y position of the label\n             * @param  {Boolean} old    Whether or not the tick is old\n             * @param  {number} opacity The opacity of the label\n             * @param  {number} index   The index of the tick\n             * @return {undefined}\n             */\n            renderLabel: function(xy, old, opacity, index) {\n                var tick = this,\n                    axis = tick.axis,\n                    horiz = axis.horiz,\n                    options = axis.options,\n                    label = tick.label,\n                    labelOptions = options.labels,\n                    step = labelOptions.step,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    show = true,\n                    x = xy.x,\n                    y = xy.y;\n                if (label && isNumber(x)) {\n                    label.xy = xy = tick.getLabelPosition(\n                        x,\n                        y,\n                        label,\n                        horiz,\n                        labelOptions,\n                        tickmarkOffset,\n                        index,\n                        step\n                    );\n\n                    // Apply show first and show last. If the tick is both first and\n                    // last, it is a single centered tick, in which case we show the\n                    // label anyway (#2100).\n                    if (\n                        (\n                            tick.isFirst &&\n                            !tick.isLast &&\n                            !pick(options.showFirstLabel, 1)\n                        ) ||\n                        (\n                            tick.isLast &&\n                            !tick.isFirst &&\n                            !pick(options.showLastLabel, 1)\n                        )\n                    ) {\n                        show = false;\n\n                        // Handle label overflow and show or hide accordingly\n                    } else if (horiz && !axis.isRadial && !labelOptions.step &&\n                        !labelOptions.rotation && !old && opacity !== 0) {\n                        tick.handleOverflow(xy);\n                    }\n\n                    // apply step\n                    if (step && index % step) {\n                        // show those indices dividable by step\n                        show = false;\n                    }\n\n                    // Set the new position, and show or hide\n                    if (show && isNumber(xy.y)) {\n                        xy.opacity = opacity;\n                        label[tick.isNewLabel ? 'attr' : 'animate'](xy);\n                        tick.isNewLabel = false;\n                    } else {\n                        label.attr('y', -9999); // #1338\n                        tick.isNewLabel = true;\n                    }\n                    tick.isNew = false;\n                }\n            },\n\n            /**\n             * Put everything in place\n             *\n             * @param index {Number}\n             * @param old {Boolean} Use old coordinates to prepare an animation into new\n             *                      position\n             */\n            render: function(index, old, opacity) {\n                var tick = this,\n                    axis = tick.axis,\n                    horiz = axis.horiz,\n                    pos = tick.pos,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n                    x = xy.x,\n                    y = xy.y,\n                    reverseCrisp = ((horiz && x === axis.pos + axis.len) ||\n                        (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n                opacity = pick(opacity, 1);\n                this.isActive = true;\n\n                // Create the grid line\n                this.renderGridLine(old, opacity, reverseCrisp);\n\n                // create the tick mark\n                this.renderMark(xy, opacity, reverseCrisp);\n\n                // the label is created on init - now move it into place\n                this.renderLabel(xy, old, opacity, index);\n            },\n\n            /**\n             * Destructor for the tick prototype\n             */\n            destroy: function() {\n                destroyObjectProperties(this, this.axis);\n            }\n        };\n\n    }(Highcharts));\n    var Axis = (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var addEvent = H.addEvent,\n            animObject = H.animObject,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            color = H.color,\n            correctFloat = H.correctFloat,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            getMagnitude = H.getMagnitude,\n            grep = H.grep,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isString = H.isString,\n            merge = H.merge,\n            normalizeTickInterval = H.normalizeTickInterval,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            syncTimeout = H.syncTimeout,\n            Tick = H.Tick;\n\n        /**\n         * Create a new axis object. Called internally when instanciating a new chart or\n         * adding axes by {@link Highcharts.Chart#addAxis}.\n         *\n         * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n         * series cartesian chart, there is one X axis and one Y axis.\n         * \n         * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n         * an array of Axis objects. If there is only one axis, it can be referenced\n         * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n         * pattern goes for Y axes.\n         * \n         * If you need to get the axes from a series object, use the `series.xAxis` and\n         * `series.yAxis` properties. These are not arrays, as one series can only be\n         * associated to one X and one Y axis.\n         * \n         * A third way to reference the axis programmatically is by `id`. Add an `id` in\n         * the axis configuration options, and get the axis by\n         * {@link Highcharts.Chart#get}.\n         * \n         * Configuration options for the axes are given in options.xAxis and\n         * options.yAxis.\n         * \n         * @class Highcharts.Axis\n         * @memberOf Highcharts\n         * @param {Highcharts.Chart} chart - The Chart instance to apply the axis on.\n         * @param {Object} options - Axis options\n         */\n        var Axis = function() {\n            this.init.apply(this, arguments);\n        };\n\n        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Default options for the X axis - the Y axis has extended defaults.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultOptions: {\n                // allowDecimals: null,\n                // alternateGridColor: null,\n                // categories: [],\n                dateTimeLabelFormats: {\n                    millisecond: '%H:%M:%S.%L',\n                    second: '%H:%M:%S',\n                    minute: '%H:%M',\n                    hour: '%H:%M',\n                    day: '%e. %b',\n                    week: '%e. %b',\n                    month: '%b \\'%y',\n                    year: '%Y'\n                },\n                endOnTick: false,\n                // reversed: false,\n\n                labels: {\n                    enabled: true,\n                    // rotation: 0,\n                    // align: 'center',\n                    // step: null,\n\n                    style: {\n                        color: '#666666',\n                        cursor: 'default',\n                        fontSize: '11px'\n                    },\n\n                    x: 0\n                    //y: undefined\n                    /*formatter: function () {\n                    \treturn this.value;\n                    },*/\n                },\n                //linkedTo: null,\n                //max: undefined,\n                //min: undefined,\n                minPadding: 0.01,\n                maxPadding: 0.01,\n                //minRange: null,\n                //minorTickInterval: null,\n                minorTickLength: 2,\n                minorTickPosition: 'outside', // inside or outside\n                //opposite: false,\n                //offset: 0,\n                //plotBands: [{\n                //\tevents: {},\n                //\tzIndex: 1,\n                //\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n                //}],\n                //plotLines: [{\n                //\tevents: {}\n                //  dashStyle: {}\n                //\tzIndex:\n                //\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n                //}],\n                //reversed: false,\n                // showFirstLabel: true,\n                // showLastLabel: true,\n                startOfWeek: 1,\n                startOnTick: false,\n                //tickInterval: null,\n                tickLength: 10,\n                tickmarkPlacement: 'between', // on or between\n                tickPixelInterval: 100,\n                tickPosition: 'outside',\n                title: {\n                    //text: null,\n                    align: 'middle', // low, middle or high\n                    //margin: 0 for horizontal, 10 for vertical axes,\n                    // reserveSpace: true,\n                    //rotation: 0,\n                    //side: 'outside',\n\n                    style: {\n                        color: '#666666'\n                    }\n\n                    //x: 0,\n                    //y: 0\n                },\n                type: 'linear', // linear, logarithmic or datetime\n                //visible: true\n\n                minorGridLineColor: '#f2f2f2',\n                // minorGridLineDashStyle: null,\n                minorGridLineWidth: 1,\n                minorTickColor: '#999999',\n                //minorTickWidth: 0,\n                lineColor: '#ccd6eb',\n                lineWidth: 1,\n                gridLineColor: '#e6e6e6',\n                // gridLineDashStyle: 'solid',\n                // gridLineWidth: 0,\n                tickColor: '#ccd6eb'\n                // tickWidth: 1\n\n            },\n\n            /**\n             * This options set extends the defaultOptions for Y axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultYAxisOptions: {\n                endOnTick: true,\n                tickPixelInterval: 72,\n                showLastLabel: true,\n                labels: {\n                    x: -8\n                },\n                maxPadding: 0.05,\n                minPadding: 0.05,\n                startOnTick: true,\n                title: {\n                    rotation: 270,\n                    text: 'Values'\n                },\n                stackLabels: {\n                    enabled: false,\n                    //align: dynamic,\n                    //y: dynamic,\n                    //x: dynamic,\n                    //verticalAlign: dynamic,\n                    //textAlign: dynamic,\n                    //rotation: 0,\n                    formatter: function() {\n                        return H.numberFormat(this.total, -1);\n                    },\n\n                    style: {\n                        fontSize: '11px',\n                        fontWeight: 'bold',\n                        color: '#000000',\n                        textOutline: '1px contrast'\n                    }\n\n                },\n\n                gridLineWidth: 1,\n                lineWidth: 0\n                // tickWidth: 0\n\n            },\n\n            /**\n             * These options extend the defaultOptions for left axes.\n             * \n             * @private\n             * @type {Object}\n             */\n            defaultLeftAxisOptions: {\n                labels: {\n                    x: -15\n                },\n                title: {\n                    rotation: 270\n                }\n            },\n\n            /**\n             * These options extend the defaultOptions for right axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultRightAxisOptions: {\n                labels: {\n                    x: 15\n                },\n                title: {\n                    rotation: 90\n                }\n            },\n\n            /**\n             * These options extend the defaultOptions for bottom axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultBottomAxisOptions: {\n                labels: {\n                    autoRotation: [-45],\n                    x: 0\n                    // overflow: undefined,\n                    // staggerLines: null\n                },\n                title: {\n                    rotation: 0\n                }\n            },\n            /**\n             * These options extend the defaultOptions for top axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultTopAxisOptions: {\n                labels: {\n                    autoRotation: [-45],\n                    x: 0\n                    // overflow: undefined\n                    // staggerLines: null\n                },\n                title: {\n                    rotation: 0\n                }\n            },\n\n            /**\n             * Initialize the axis\n             */\n            init: function(chart, userOptions) {\n\n\n                var isXAxis = userOptions.isX,\n                    axis = this;\n\n                axis.chart = chart;\n\n                // Flag, is the axis horizontal\n                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;\n\n                // Flag, isXAxis\n                axis.isXAxis = isXAxis;\n                axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n\n                axis.opposite = userOptions.opposite; // needed in setOptions\n                axis.side = userOptions.side || (axis.horiz ?\n                    (axis.opposite ? 0 : 2) : // top : bottom\n                    (axis.opposite ? 1 : 3)); // right : left\n\n                axis.setOptions(userOptions);\n\n\n                var options = this.options,\n                    type = options.type,\n                    isDatetimeAxis = type === 'datetime';\n\n                axis.labelFormatter = options.labels.formatter ||\n                    axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n                // Flag, stagger lines or not\n                axis.userOptions = userOptions;\n\n                //axis.axisTitleMargin = undefined,// = options.title.margin,\n                axis.minPixelPadding = 0;\n\n                axis.reversed = options.reversed;\n                axis.visible = options.visible !== false;\n                axis.zoomEnabled = options.zoomEnabled !== false;\n\n                // Initial categories\n                axis.hasNames = type === 'category' || options.categories === true;\n                axis.categories = options.categories || axis.hasNames;\n                axis.names = axis.names || []; // Preserve on update (#3830)\n\n                // Elements\n                //axis.axisGroup = undefined;\n                //axis.gridGroup = undefined;\n                //axis.axisTitle = undefined;\n                //axis.axisLine = undefined;\n\n                // Placeholder for plotlines and plotbands groups\n                axis.plotLinesAndBandsGroups = {};\n\n                // Shorthand types\n                axis.isLog = type === 'logarithmic';\n                axis.isDatetimeAxis = isDatetimeAxis;\n                axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;\n\n                // Flag, if axis is linked to another axis\n                axis.isLinked = defined(options.linkedTo);\n                // Linked axis.\n                //axis.linkedParent = undefined;\n\n                // Major ticks\n                axis.ticks = {};\n                axis.labelEdge = [];\n                // Minor ticks\n                axis.minorTicks = {};\n\n                // List of plotLines/Bands\n                axis.plotLinesAndBands = [];\n\n                // Alternate bands\n                axis.alternateBands = {};\n\n                // Axis metrics\n                //axis.left = undefined;\n                //axis.top = undefined;\n                //axis.width = undefined;\n                //axis.height = undefined;\n                //axis.bottom = undefined;\n                //axis.right = undefined;\n                //axis.transA = undefined;\n                //axis.transB = undefined;\n                //axis.oldTransA = undefined;\n                axis.len = 0;\n                //axis.oldMin = undefined;\n                //axis.oldMax = undefined;\n                //axis.oldUserMin = undefined;\n                //axis.oldUserMax = undefined;\n                //axis.oldAxisLength = undefined;\n                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n                axis.range = options.range;\n                axis.offset = options.offset || 0;\n\n\n                // Dictionary for stacks\n                axis.stacks = {};\n                axis.oldStacks = {};\n                axis.stacksTouched = 0;\n\n                // Min and max in the data\n                //axis.dataMin = undefined,\n                //axis.dataMax = undefined,\n\n                // The axis range\n                axis.max = null;\n                axis.min = null;\n\n                // User set min and max\n                //axis.userMin = undefined,\n                //axis.userMax = undefined,\n\n                // Crosshair options\n                axis.crosshair = pick(\n                    options.crosshair,\n                    splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],\n                    false\n                );\n\n                var events = axis.options.events;\n\n                // Register. Don't add it again on Axis.update().\n                if (inArray(axis, chart.axes) === -1) { // \n                    if (isXAxis) { // #2713\n                        chart.axes.splice(chart.xAxis.length, 0, axis);\n                    } else {\n                        chart.axes.push(axis);\n                    }\n\n                    chart[axis.coll].push(axis);\n                }\n\n                axis.series = axis.series || []; // populated by Series\n\n                // inverted charts have reversed xAxes as default\n                if (chart.inverted && !axis.isZAxis && isXAxis && axis.reversed === undefined) {\n                    axis.reversed = true;\n                }\n\n                // register event listeners\n                objectEach(events, function(event, eventType) {\n                    addEvent(axis, eventType, event);\n                });\n\n                // extend logarithmic axis\n                axis.lin2log = options.linearToLogConverter || axis.lin2log;\n                if (axis.isLog) {\n                    axis.val2lin = axis.log2lin;\n                    axis.lin2val = axis.lin2log;\n                }\n            },\n\n            /**\n             * Merge and set options\n             */\n            setOptions: function(userOptions) {\n                this.options = merge(\n                    this.defaultOptions,\n                    this.coll === 'yAxis' && this.defaultYAxisOptions, [\n                        this.defaultTopAxisOptions,\n                        this.defaultRightAxisOptions,\n                        this.defaultBottomAxisOptions,\n                        this.defaultLeftAxisOptions\n                    ][this.side],\n                    merge(\n                        defaultOptions[this.coll], // if set in setOptions (#1053)\n                        userOptions\n                    )\n                );\n            },\n\n            /**\n             * The default label formatter. The context is a special config object for\n             * the label. In apps, use the {@link\n             * https://api.highcharts.com/highcharts/xAxis.labels.formatter|\n             * labels.formatter} instead except when a modification is needed.\n             *\n             * @private\n             */\n            defaultLabelFormatter: function() {\n                var axis = this.axis,\n                    value = this.value,\n                    categories = axis.categories,\n                    dateTimeLabelFormat = this.dateTimeLabelFormat,\n                    lang = defaultOptions.lang,\n                    numericSymbols = lang.numericSymbols,\n                    numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n                    i = numericSymbols && numericSymbols.length,\n                    multi,\n                    ret,\n                    formatOption = axis.options.labels.format,\n\n                    // make sure the same symbol is added for all labels on a linear\n                    // axis\n                    numericSymbolDetector = axis.isLog ?\n                    Math.abs(value) :\n                    axis.tickInterval;\n\n                if (formatOption) {\n                    ret = format(formatOption, this);\n\n                } else if (categories) {\n                    ret = value;\n\n                } else if (dateTimeLabelFormat) { // datetime axis\n                    ret = H.dateFormat(dateTimeLabelFormat, value);\n\n                } else if (i && numericSymbolDetector >= 1000) {\n                    // Decide whether we should add a numeric symbol like k (thousands)\n                    // or M (millions). If we are to enable this in tooltip or other\n                    // places as well, we can move this logic to the numberFormatter and\n                    // enable it by a parameter.\n                    while (i-- && ret === undefined) {\n                        multi = Math.pow(numSymMagnitude, i + 1);\n                        if (\n                            numericSymbolDetector >= multi &&\n                            (value * 10) % multi === 0 &&\n                            numericSymbols[i] !== null &&\n                            value !== 0\n                        ) { // #5480\n                            ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n                        }\n                    }\n                }\n\n                if (ret === undefined) {\n                    if (Math.abs(value) >= 10000) { // add thousands separators\n                        ret = H.numberFormat(value, -1);\n                    } else { // small numbers\n                        ret = H.numberFormat(value, -1, undefined, ''); // #2466\n                    }\n                }\n\n                return ret;\n            },\n\n            /**\n             * Get the minimum and maximum for the series of each axis\n             */\n            getSeriesExtremes: function() {\n                var axis = this,\n                    chart = axis.chart;\n                axis.hasVisibleSeries = false;\n\n                // Reset properties in case we're redrawing (#3353)\n                axis.dataMin = axis.dataMax = axis.threshold = null;\n                axis.softThreshold = !axis.isXAxis;\n\n                if (axis.buildStacks) {\n                    axis.buildStacks();\n                }\n\n                // loop through this axis' series\n                each(axis.series, function(series) {\n\n                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                        var seriesOptions = series.options,\n                            xData,\n                            threshold = seriesOptions.threshold,\n                            seriesDataMin,\n                            seriesDataMax;\n\n                        axis.hasVisibleSeries = true;\n\n                        // Validate threshold in logarithmic axes\n                        if (axis.positiveValuesOnly && threshold <= 0) {\n                            threshold = null;\n                        }\n\n                        // Get dataMin and dataMax for X axes\n                        if (axis.isXAxis) {\n                            xData = series.xData;\n                            if (xData.length) {\n                                // If xData contains values which is not numbers, then\n                                // filter them out. To prevent performance hit, we only\n                                // do this after we have already found seriesDataMin\n                                // because in most cases all data is valid. #5234.\n                                seriesDataMin = arrayMin(xData);\n                                if (!isNumber(seriesDataMin) &&\n                                    !(seriesDataMin instanceof Date) // #5010\n                                ) {\n                                    xData = grep(xData, function(x) {\n                                        return isNumber(x);\n                                    });\n                                    seriesDataMin = arrayMin(xData); // Do it again with valid data\n                                }\n\n                                axis.dataMin = Math.min(\n                                    pick(axis.dataMin, xData[0]),\n                                    seriesDataMin\n                                );\n                                axis.dataMax = Math.max(\n                                    pick(axis.dataMax, xData[0]),\n                                    arrayMax(xData)\n                                );\n\n                            }\n\n                            // Get dataMin and dataMax for Y axes, as well as handle\n                            // stacking and processed data\n                        } else {\n\n                            // Get this particular series extremes\n                            series.getExtremes();\n                            seriesDataMax = series.dataMax;\n                            seriesDataMin = series.dataMin;\n\n                            // Get the dataMin and dataMax so far. If percentage is\n                            // used, the min and max are always 0 and 100. If\n                            // seriesDataMin and seriesDataMax is null, then series\n                            // doesn't have active y data, we continue with nulls\n                            if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                                axis.dataMin = Math.min(\n                                    pick(axis.dataMin, seriesDataMin),\n                                    seriesDataMin\n                                );\n                                axis.dataMax = Math.max(\n                                    pick(axis.dataMax, seriesDataMax),\n                                    seriesDataMax\n                                );\n                            }\n\n                            // Adjust to threshold\n                            if (defined(threshold)) {\n                                axis.threshold = threshold;\n                            }\n                            // If any series has a hard threshold, it takes precedence\n                            if (!seriesOptions.softThreshold ||\n                                axis.positiveValuesOnly\n                            ) {\n                                axis.softThreshold = false;\n                            }\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Translate from axis value to pixel position on the chart, or back\n             *\n             */\n            translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n                var axis = this.linkedParent || this, // #1417\n                    sign = 1,\n                    cvsOffset = 0,\n                    localA = old ? axis.oldTransA : axis.transA,\n                    localMin = old ? axis.oldMin : axis.min,\n                    returnValue,\n                    minPixelPadding = axis.minPixelPadding,\n                    doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;\n\n                if (!localA) {\n                    localA = axis.transA;\n                }\n\n                // In vertical axes, the canvas coordinates start from 0 at the top like in\n                // SVG.\n                if (cvsCoord) {\n                    sign *= -1; // canvas coordinates inverts the value\n                    cvsOffset = axis.len;\n                }\n\n                // Handle reversed axis\n                if (axis.reversed) {\n                    sign *= -1;\n                    cvsOffset -= sign * (axis.sector || axis.len);\n                }\n\n                // From pixels to value\n                if (backwards) { // reverse translation\n\n                    val = val * sign + cvsOffset;\n                    val -= minPixelPadding;\n                    returnValue = val / localA + localMin; // from chart pixel to value\n                    if (doPostTranslate) { // log and ordinal axes\n                        returnValue = axis.lin2val(returnValue);\n                    }\n\n                    // From value to pixels\n                } else {\n                    if (doPostTranslate) { // log and ordinal axes\n                        val = axis.val2lin(val);\n                    }\n                    returnValue = sign * (val - localMin) * localA + cvsOffset +\n                        (sign * minPixelPadding) +\n                        (isNumber(pointPlacement) ? localA * pointPlacement : 0);\n                }\n\n                return returnValue;\n            },\n\n            /**\n             * Translate a value in terms of axis units into pixels within the chart.\n             * \n             * @param  {Number} value\n             *         A value in terms of axis units.\n             * @param  {Boolean} paneCoordinates\n             *         Whether to return the pixel coordinate relative to the chart or\n             *         just the axis/pane itself.\n             * @return {Number} Pixel position of the value on the chart or axis.\n             */\n            toPixels: function(value, paneCoordinates) {\n                return this.translate(value, false, !this.horiz, null, true) +\n                    (paneCoordinates ? 0 : this.pos);\n            },\n\n            /**\n             * Translate a pixel position along the axis to a value in terms of axis\n             * units.\n             * @param  {Number} pixel\n             *         The pixel value coordinate.\n             * @param  {Boolean} paneCoordiantes\n             *         Whether the input pixel is relative to the chart or just the\n             *         axis/pane itself.\n             * @return {Number} The axis value.\n             */\n            toValue: function(pixel, paneCoordinates) {\n                return this.translate(\n                    pixel - (paneCoordinates ? 0 : this.pos),\n                    true, !this.horiz,\n                    null,\n                    true\n                );\n            },\n\n            /**\n             * Create the path for a plot line that goes from the given value on\n             * this axis, across the plot to the opposite side\n             * @param {Number} value\n             * @param {Number} lineWidth Used for calculation crisp line\n             * @param {Number] old Use old coordinates (for resizing and rescaling)\n             */\n            getPlotLinePath: function(value, lineWidth, old, force, translatedValue) {\n                var axis = this,\n                    chart = axis.chart,\n                    axisLeft = axis.left,\n                    axisTop = axis.top,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n                    cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n                    skip,\n                    transB = axis.transB,\n                    /**\n                     * Check if x is between a and b. If not, either move to a/b or skip,\n                     * depending on the force parameter.\n                     */\n                    between = function(x, a, b) {\n                        if (x < a || x > b) {\n                            if (force) {\n                                x = Math.min(Math.max(a, x), b);\n                            } else {\n                                skip = true;\n                            }\n                        }\n                        return x;\n                    };\n\n                translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n                x1 = x2 = Math.round(translatedValue + transB);\n                y1 = y2 = Math.round(cHeight - translatedValue - transB);\n                if (!isNumber(translatedValue)) { // no min or max\n                    skip = true;\n\n                } else if (axis.horiz) {\n                    y1 = axisTop;\n                    y2 = cHeight - axis.bottom;\n                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n                } else {\n                    x1 = axisLeft;\n                    x2 = cWidth - axis.right;\n                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n                }\n                return skip && !force ?\n                    null :\n                    chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n            },\n\n            /**\n             * Internal function to et the tick positions of a linear axis to round\n             * values like whole tens or every five.\n             *\n             * @param  {Number} tickInterval\n             *         The normalized tick interval\n             * @param  {Number} min\n             *         Axis minimum.\n             * @param  {Number} max\n             *         Axis maximum.\n             *\n             * @return {Array.<Number>}\n             *         An array of numbers where ticks should be placed.\n             */\n            getLinearTickPositions: function(tickInterval, min, max) {\n                var pos,\n                    lastPos,\n                    roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n                    roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n                    tickPositions = [];\n\n                // For single points, add a tick regardless of the relative position\n                // (#2662, #6274)\n                if (this.single) {\n                    return [min];\n                }\n\n                // Populate the intermediate values\n                pos = roundedMin;\n                while (pos <= roundedMax) {\n\n                    // Place the tick on the rounded value\n                    tickPositions.push(pos);\n\n                    // Always add the raw tickInterval, not the corrected one.\n                    pos = correctFloat(pos + tickInterval);\n\n                    // If the interval is not big enough in the current min - max range to actually increase\n                    // the loop variable, we need to break out to prevent endless loop. Issue #619\n                    if (pos === lastPos) {\n                        break;\n                    }\n\n                    // Record the last value\n                    lastPos = pos;\n                }\n                return tickPositions;\n            },\n\n            /**\n             * Return the minor tick positions. For logarithmic axes, reuse the same logic\n             * as for major ticks.\n             */\n            getMinorTickPositions: function() {\n                var axis = this,\n                    options = axis.options,\n                    tickPositions = axis.tickPositions,\n                    minorTickInterval = axis.minorTickInterval,\n                    minorTickPositions = [],\n                    pos,\n                    pointRangePadding = axis.pointRangePadding || 0,\n                    min = axis.min - pointRangePadding, // #1498\n                    max = axis.max + pointRangePadding, // #1498\n                    range = max - min;\n\n                // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n                if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n                    if (axis.isLog) {\n                        // For each interval in the major ticks, compute the minor ticks\n                        // separately.\n                        each(this.paddedTicks, function(pos, i, paddedTicks) {\n                            if (i) {\n                                minorTickPositions.push.apply(\n                                    minorTickPositions,\n                                    axis.getLogTickPositions(\n                                        minorTickInterval,\n                                        paddedTicks[i - 1],\n                                        paddedTicks[i],\n                                        true\n                                    )\n                                );\n                            }\n                        });\n\n                    } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                        minorTickPositions = minorTickPositions.concat(\n                            axis.getTimeTicks(\n                                axis.normalizeTimeTickInterval(minorTickInterval),\n                                min,\n                                max,\n                                options.startOfWeek\n                            )\n                        );\n                    } else {\n                        for (\n                            pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval\n                        ) {\n                            // Very, very, tight grid lines (#5771)\n                            if (pos === minorTickPositions[0]) {\n                                break;\n                            }\n                            minorTickPositions.push(pos);\n                        }\n                    }\n                }\n\n                if (minorTickPositions.length !== 0) {\n                    axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n                }\n                return minorTickPositions;\n            },\n\n            /**\n             * Adjust the min and max for the minimum range. Keep in mind that the series data is\n             * not yet processed, so we don't have information on data cropping and grouping, or\n             * updated axis.pointRange or series.pointRange. The data can't be processed until\n             * we have finally established min and max.\n             *\n             * @private\n             */\n            adjustForMinRange: function() {\n                var axis = this,\n                    options = axis.options,\n                    min = axis.min,\n                    max = axis.max,\n                    zoomOffset,\n                    spaceAvailable,\n                    closestDataRange,\n                    i,\n                    distance,\n                    xData,\n                    loopLength,\n                    minArgs,\n                    maxArgs,\n                    minRange;\n\n                // Set the automatic minimum range based on the closest point distance\n                if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n\n                    if (defined(options.min) || defined(options.max)) {\n                        axis.minRange = null; // don't do this again\n\n                    } else {\n\n                        // Find the closest distance between raw data points, as opposed to\n                        // closestPointRange that applies to processed points (cropped and grouped)\n                        each(axis.series, function(series) {\n                            xData = series.xData;\n                            loopLength = series.xIncrement ? 1 : xData.length - 1;\n                            for (i = loopLength; i > 0; i--) {\n                                distance = xData[i] - xData[i - 1];\n                                if (closestDataRange === undefined || distance < closestDataRange) {\n                                    closestDataRange = distance;\n                                }\n                            }\n                        });\n                        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n                    }\n                }\n\n                // if minRange is exceeded, adjust\n                if (max - min < axis.minRange) {\n\n                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n                    minRange = axis.minRange;\n                    zoomOffset = (minRange - max + min) / 2;\n\n                    // if min and max options have been set, don't go beyond it\n                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n                    if (spaceAvailable) { // if space is available, stay within the data range\n                        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;\n                    }\n                    min = arrayMax(minArgs);\n\n                    maxArgs = [min + minRange, pick(options.max, min + minRange)];\n                    if (spaceAvailable) { // if space is availabe, stay within the data range\n                        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;\n                    }\n\n                    max = arrayMin(maxArgs);\n\n                    // now if the max is adjusted, adjust the min back\n                    if (max - min < minRange) {\n                        minArgs[0] = max - minRange;\n                        minArgs[1] = pick(options.min, max - minRange);\n                        min = arrayMax(minArgs);\n                    }\n                }\n\n                // Record modified extremes\n                axis.min = min;\n                axis.max = max;\n            },\n\n            /**\n             * Find the closestPointRange across all series.\n             *\n             * @private\n             */\n            getClosest: function() {\n                var ret;\n\n                if (this.categories) {\n                    ret = 1;\n                } else {\n                    each(this.series, function(series) {\n                        var seriesClosest = series.closestPointRange,\n                            visible = series.visible ||\n                            !series.chart.options.chart.ignoreHiddenSeries;\n\n                        if (!series.noSharedTooltip &&\n                            defined(seriesClosest) &&\n                            visible\n                        ) {\n                            ret = defined(ret) ?\n                                Math.min(ret, seriesClosest) :\n                                seriesClosest;\n                        }\n                    });\n                }\n                return ret;\n            },\n\n            /**\n             * When a point name is given and no x, search for the name in the existing categories,\n             * or if categories aren't provided, search names or create a new category (#2522).\n             */\n            nameToX: function(point) {\n                var explicitCategories = isArray(this.categories),\n                    names = explicitCategories ? this.categories : this.names,\n                    nameX = point.options.x,\n                    x;\n\n                point.series.requireSorting = false;\n\n                if (!defined(nameX)) {\n                    nameX = this.options.uniqueNames === false ?\n                        point.series.autoIncrement() :\n                        inArray(point.name, names);\n                }\n                if (nameX === -1) { // The name is not found in currenct categories\n                    if (!explicitCategories) {\n                        x = names.length;\n                    }\n                } else {\n                    x = nameX;\n                }\n\n                // Write the last point's name to the names array\n                if (x !== undefined) {\n                    this.names[x] = point.name;\n                }\n\n                return x;\n            },\n\n            /**\n             * When changes have been done to series data, update the axis.names.\n             */\n            updateNames: function() {\n                var axis = this;\n\n                if (this.names.length > 0) {\n                    this.names.length = 0;\n                    this.minRange = this.userMinRange; // Reset\n                    each(this.series || [], function(series) {\n\n                        // Reset incrementer (#5928)\n                        series.xIncrement = null;\n\n                        // When adding a series, points are not yet generated\n                        if (!series.points || series.isDirtyData) {\n                            series.processData();\n                            series.generatePoints();\n                        }\n\n                        each(series.points, function(point, i) {\n                            var x;\n                            if (point.options) {\n                                x = axis.nameToX(point);\n                                if (x !== undefined && x !== point.x) {\n                                    point.x = x;\n                                    series.xData[i] = x;\n                                }\n                            }\n                        });\n                    });\n                }\n            },\n\n            /**\n             * Update translation information\n             */\n            setAxisTranslation: function(saveOld) {\n                var axis = this,\n                    range = axis.max - axis.min,\n                    pointRange = axis.axisPointRange || 0,\n                    closestPointRange,\n                    minPointOffset = 0,\n                    pointRangePadding = 0,\n                    linkedParent = axis.linkedParent,\n                    ordinalCorrection,\n                    hasCategories = !!axis.categories,\n                    transA = axis.transA,\n                    isXAxis = axis.isXAxis;\n\n                // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n                if (isXAxis || hasCategories || pointRange) {\n\n                    // Get the closest points\n                    closestPointRange = axis.getClosest();\n\n                    if (linkedParent) {\n                        minPointOffset = linkedParent.minPointOffset;\n                        pointRangePadding = linkedParent.pointRangePadding;\n                    } else {\n                        each(axis.series, function(series) {\n                            var seriesPointRange = hasCategories ?\n                                1 :\n                                (isXAxis ?\n                                    pick(series.options.pointRange, closestPointRange, 0) :\n                                    (axis.axisPointRange || 0)), // #2806\n                                pointPlacement = series.options.pointPlacement;\n\n                            pointRange = Math.max(pointRange, seriesPointRange);\n\n                            if (!axis.single) {\n                                // minPointOffset is the value padding to the left of the axis in order to make\n                                // room for points with a pointRange, typically columns. When the pointPlacement option\n                                // is 'between' or 'on', this padding does not apply.\n                                minPointOffset = Math.max(\n                                    minPointOffset,\n                                    isString(pointPlacement) ? 0 : seriesPointRange / 2\n                                );\n\n                                // Determine the total padding needed to the length of the axis to make room for the\n                                // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                                pointRangePadding = Math.max(\n                                    pointRangePadding,\n                                    pointPlacement === 'on' ? 0 : seriesPointRange\n                                );\n                            }\n                        });\n                    }\n\n                    // Record minPointOffset and pointRangePadding\n                    ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n                    // pointRange means the width reserved for each point, like in a column chart\n                    axis.pointRange = Math.min(pointRange, range);\n\n                    // closestPointRange means the closest distance between points. In columns\n                    // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n                    // is some other value\n                    if (isXAxis) {\n                        axis.closestPointRange = closestPointRange;\n                    }\n                }\n\n                // Secondary values\n                if (saveOld) {\n                    axis.oldTransA = transA;\n                }\n                axis.translationSlope = axis.transA = transA =\n                    axis.options.staticScale ||\n                    axis.len / ((range + pointRangePadding) || 1);\n                axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n                axis.minPixelPadding = transA * minPointOffset;\n            },\n\n            minFromRange: function() {\n                return this.max - this.range;\n            },\n\n            /**\n             * Set the tick positions to round values and optionally extend the extremes\n             * to the nearest tick\n             */\n            setTickInterval: function(secondPass) {\n                var axis = this,\n                    chart = axis.chart,\n                    options = axis.options,\n                    isLog = axis.isLog,\n                    log2lin = axis.log2lin,\n                    isDatetimeAxis = axis.isDatetimeAxis,\n                    isXAxis = axis.isXAxis,\n                    isLinked = axis.isLinked,\n                    maxPadding = options.maxPadding,\n                    minPadding = options.minPadding,\n                    length,\n                    linkedParentExtremes,\n                    tickIntervalOption = options.tickInterval,\n                    minTickInterval,\n                    tickPixelIntervalOption = options.tickPixelInterval,\n                    categories = axis.categories,\n                    threshold = axis.threshold,\n                    softThreshold = axis.softThreshold,\n                    thresholdMin,\n                    thresholdMax,\n                    hardMin,\n                    hardMax;\n\n                if (!isDatetimeAxis && !categories && !isLinked) {\n                    this.getTickAmount();\n                }\n\n                // Min or max set either by zooming/setExtremes or initial options\n                hardMin = pick(axis.userMin, options.min);\n                hardMax = pick(axis.userMax, options.max);\n\n                // Linked axis gets the extremes from the parent axis\n                if (isLinked) {\n                    axis.linkedParent = chart[axis.coll][options.linkedTo];\n                    linkedParentExtremes = axis.linkedParent.getExtremes();\n                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                    if (options.type !== axis.linkedParent.options.type) {\n                        H.error(11, 1); // Can't link axes of different type\n                    }\n\n                    // Initial min and max from the extreme data values\n                } else {\n\n                    // Adjust to hard threshold\n                    if (!softThreshold && defined(threshold)) {\n                        if (axis.dataMin >= threshold) {\n                            thresholdMin = threshold;\n                            minPadding = 0;\n                        } else if (axis.dataMax <= threshold) {\n                            thresholdMax = threshold;\n                            maxPadding = 0;\n                        }\n                    }\n\n                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n                }\n\n                if (isLog) {\n                    if (\n                        axis.positiveValuesOnly &&\n                        !secondPass &&\n                        Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0\n                    ) { // #978\n                        H.error(10, 1); // Can't plot negative values on log axis\n                    }\n                    // The correctFloat cures #934, float errors on full tens. But it\n                    // was too aggressive for #4360 because of conversion back to lin,\n                    // therefore use precision 15.\n                    axis.min = correctFloat(log2lin(axis.min), 15);\n                    axis.max = correctFloat(log2lin(axis.max), 15);\n                }\n\n                // handle zoomed range\n                if (axis.range && defined(axis.max)) {\n                    axis.userMin = axis.min = hardMin = Math.max(axis.min, axis.minFromRange()); // #618\n                    axis.userMax = hardMax = axis.max;\n\n                    axis.range = null; // don't use it when running setExtremes\n                }\n\n                // Hook for Highstock Scroller. Consider combining with beforePadding.\n                fireEvent(axis, 'foundExtremes');\n\n                // Hook for adjusting this.min and this.max. Used by bubble series.\n                if (axis.beforePadding) {\n                    axis.beforePadding();\n                }\n\n                // adjust min and max for the minimum range\n                axis.adjustForMinRange();\n\n                // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n                // into account, we do this after computing tick interval (#1337).\n                if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n                    length = axis.max - axis.min;\n                    if (length) {\n                        if (!defined(hardMin) && minPadding) {\n                            axis.min -= length * minPadding;\n                        }\n                        if (!defined(hardMax) && maxPadding) {\n                            axis.max += length * maxPadding;\n                        }\n                    }\n                }\n\n                // Handle options for floor, ceiling, softMin and softMax (#6359)\n                if (isNumber(options.softMin)) {\n                    axis.min = Math.min(axis.min, options.softMin);\n                }\n                if (isNumber(options.softMax)) {\n                    axis.max = Math.max(axis.max, options.softMax);\n                }\n                if (isNumber(options.floor)) {\n                    axis.min = Math.max(axis.min, options.floor);\n                }\n                if (isNumber(options.ceiling)) {\n                    axis.max = Math.min(axis.max, options.ceiling);\n                }\n\n\n                // When the threshold is soft, adjust the extreme value only if\n                // the data extreme and the padded extreme land on either side of the threshold. For example,\n                // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n                // default minPadding and startOnTick options. This is prevented by the softThreshold\n                // option.\n                if (softThreshold && defined(axis.dataMin)) {\n                    threshold = threshold || 0;\n                    if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                        axis.min = threshold;\n                    } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                        axis.max = threshold;\n                    }\n                }\n\n\n                // get tickInterval\n                if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n                    axis.tickInterval = 1;\n                } else if (isLinked && !tickIntervalOption &&\n                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n                } else {\n                    axis.tickInterval = pick(\n                        tickIntervalOption,\n                        this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,\n                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                        1 :\n                        // don't let it be more than the data range\n                        (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)\n                    );\n                }\n\n                // Now we're finished detecting min and max, crop and group series data. This\n                // is in turn needed in order to find tick positions in ordinal axes.\n                if (isXAxis && !secondPass) {\n                    each(axis.series, function(series) {\n                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n                    });\n                }\n\n                // set the translation factor used in translate function\n                axis.setAxisTranslation(true);\n\n                // hook for ordinal axes and radial axes\n                if (axis.beforeSetTickPositions) {\n                    axis.beforeSetTickPositions();\n                }\n\n                // hook for extensions, used in Highstock ordinal axes\n                if (axis.postProcessTickInterval) {\n                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n                }\n\n                // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n                if (axis.pointRange && !tickIntervalOption) {\n                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n                }\n\n                // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n                    axis.tickInterval = minTickInterval;\n                }\n\n                // for linear axes, get magnitude and normalize the interval\n                if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n                    axis.tickInterval = normalizeTickInterval(\n                        axis.tickInterval,\n                        null,\n                        getMagnitude(axis.tickInterval),\n                        // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                        // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                        pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount\n                    );\n                }\n\n                // Prevent ticks from getting so close that we can't draw the labels\n                if (!this.tickAmount) {\n                    axis.tickInterval = axis.unsquish();\n                }\n\n                this.setTickPositions();\n            },\n\n            /**\n             * Now we have computed the normalized tickInterval, get the tick positions\n             */\n            setTickPositions: function() {\n\n                var options = this.options,\n                    tickPositions,\n                    tickPositionsOption = options.tickPositions,\n                    tickPositioner = options.tickPositioner,\n                    startOnTick = options.startOnTick,\n                    endOnTick = options.endOnTick;\n\n                // Set the tickmarkOffset\n                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n                    this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n                // get minorTickInterval\n                this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n                    this.tickInterval / 5 : options.minorTickInterval;\n\n                // When there is only one point, or all points have the same value on\n                // this axis, then min and max are equal and tickPositions.length is 0\n                // or 1. In this case, add some padding in order to center the point,\n                // but leave it with one tick. #1337.\n                this.single =\n                    this.min === this.max &&\n                    defined(this.min) &&\n                    !this.tickAmount &&\n                    (\n                        // Data is on integer (#6563)\n                        parseInt(this.min, 10) === this.min ||\n\n                        // Between integers and decimals are not allowed (#6274)\n                        options.allowDecimals !== false\n                    );\n\n                // Find the tick positions\n                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n                if (!tickPositions) {\n\n                    if (this.isDatetimeAxis) {\n                        tickPositions = this.getTimeTicks(\n                            this.normalizeTimeTickInterval(\n                                this.tickInterval,\n                                options.units\n                            ),\n                            this.min,\n                            this.max,\n                            options.startOfWeek,\n                            this.ordinalPositions,\n                            this.closestPointRange,\n                            true\n                        );\n                    } else if (this.isLog) {\n                        tickPositions = this.getLogTickPositions(\n                            this.tickInterval,\n                            this.min,\n                            this.max\n                        );\n                    } else {\n                        tickPositions = this.getLinearTickPositions(\n                            this.tickInterval,\n                            this.min,\n                            this.max\n                        );\n                    }\n\n                    // Too dense ticks, keep only the first and last (#4477)\n                    if (tickPositions.length > this.len) {\n                        tickPositions = [tickPositions[0], tickPositions.pop()];\n                    }\n\n                    this.tickPositions = tickPositions;\n\n                    // Run the tick positioner callback, that allows modifying auto tick positions.\n                    if (tickPositioner) {\n                        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                        if (tickPositioner) {\n                            this.tickPositions = tickPositions = tickPositioner;\n                        }\n                    }\n\n                }\n\n                // Reset min/max or remove extremes based on start/end on tick\n                this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n                this.trimTicks(tickPositions, startOnTick, endOnTick);\n                if (!this.isLinked) {\n\n                    // Substract half a unit (#2619, #2846, #2515, #3390)\n                    if (this.single) {\n                        this.min -= 0.5;\n                        this.max += 0.5;\n                    }\n                    if (!tickPositionsOption && !tickPositioner) {\n                        this.adjustTickAmount();\n                    }\n                }\n            },\n\n            /**\n             * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n             */\n            trimTicks: function(tickPositions, startOnTick, endOnTick) {\n                var roundedMin = tickPositions[0],\n                    roundedMax = tickPositions[tickPositions.length - 1],\n                    minPointOffset = this.minPointOffset || 0;\n\n                if (!this.isLinked) {\n                    if (startOnTick && roundedMin !== -Infinity) { // #6502\n                        this.min = roundedMin;\n                    } else {\n                        while (this.min - minPointOffset > tickPositions[0]) {\n                            tickPositions.shift();\n                        }\n                    }\n\n                    if (endOnTick) {\n                        this.max = roundedMax;\n                    } else {\n                        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                            tickPositions.pop();\n                        }\n                    }\n\n                    // If no tick are left, set one tick in the middle (#3195)\n                    if (tickPositions.length === 0 && defined(roundedMin)) {\n                        tickPositions.push((roundedMax + roundedMin) / 2);\n                    }\n                }\n            },\n\n            /**\n             * Check if there are multiple axes in the same pane.\n             *\n             * @private\n             * @return {Boolean}\n             *         True if there are other axes.\n             */\n            alignToOthers: function() {\n                var others = {}, // Whether there is another axis to pair with this one\n                    hasOther,\n                    options = this.options;\n\n                if (\n                    // Only if alignTicks is true\n                    this.chart.options.chart.alignTicks !== false &&\n                    options.alignTicks !== false &&\n\n                    // Don't try to align ticks on a log axis, they are not evenly\n                    // spaced (#6021)\n                    !this.isLog\n                ) {\n                    each(this.chart[this.coll], function(axis) {\n                        var otherOptions = axis.options,\n                            horiz = axis.horiz,\n                            key = [\n                                horiz ? otherOptions.left : otherOptions.top,\n                                otherOptions.width,\n                                otherOptions.height,\n                                otherOptions.pane\n                            ].join(',');\n\n\n                        if (axis.series.length) { // #4442\n                            if (others[key]) {\n                                hasOther = true; // #4201\n                            } else {\n                                others[key] = 1;\n                            }\n                        }\n                    });\n                }\n                return hasOther;\n            },\n\n            /**\n             * Set the max ticks of either the x and y axis collection\n             */\n            getTickAmount: function() {\n                var options = this.options,\n                    tickAmount = options.tickAmount,\n                    tickPixelInterval = options.tickPixelInterval;\n\n                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                    !this.isLog && options.startOnTick && options.endOnTick) {\n                    tickAmount = 2;\n                }\n\n                if (!tickAmount && this.alignToOthers()) {\n                    // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n                }\n\n                // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n                // prevents the axis from adding ticks that are too far away from the data extremes.\n                if (tickAmount < 4) {\n                    this.finalTickAmt = tickAmount;\n                    tickAmount = 5;\n                }\n\n                this.tickAmount = tickAmount;\n            },\n\n            /**\n             * When using multiple axes, adjust the number of ticks to match the highest\n             * number of ticks in that group.\n             *\n             * @private\n             */\n            adjustTickAmount: function() {\n                var tickInterval = this.tickInterval,\n                    tickPositions = this.tickPositions,\n                    tickAmount = this.tickAmount,\n                    finalTickAmt = this.finalTickAmt,\n                    currentTickAmount = tickPositions && tickPositions.length,\n                    i,\n                    len;\n\n                if (currentTickAmount < tickAmount) {\n                    while (tickPositions.length < tickAmount) {\n                        tickPositions.push(correctFloat(\n                            tickPositions[tickPositions.length - 1] + tickInterval\n                        ));\n                    }\n                    this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                    this.max = tickPositions[tickPositions.length - 1];\n\n                    // We have too many ticks, run second pass to try to reduce ticks\n                } else if (currentTickAmount > tickAmount) {\n                    this.tickInterval *= 2;\n                    this.setTickPositions();\n                }\n\n                // The finalTickAmt property is set in getTickAmount\n                if (defined(finalTickAmt)) {\n                    i = len = tickPositions.length;\n                    while (i--) {\n                        if (\n                            (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                            (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                        ) {\n                            tickPositions.splice(i, 1);\n                        }\n                    }\n                    this.finalTickAmt = undefined;\n                }\n            },\n\n            /**\n             * Set the scale based on data min and max, user set min and max or options\n             *\n             */\n            setScale: function() {\n                var axis = this,\n                    isDirtyData,\n                    isDirtyAxisLength;\n\n                axis.oldMin = axis.min;\n                axis.oldMax = axis.max;\n                axis.oldAxisLength = axis.len;\n\n                // set the new axisLength\n                axis.setAxisSize();\n                //axisLength = horiz ? axisWidth : axisHeight;\n                isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n                // is there new data?\n                each(axis.series, function(series) {\n                    if (series.isDirtyData || series.isDirty ||\n                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                        isDirtyData = true;\n                    }\n                });\n\n                // do we really need to go through all this?\n                if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n                    if (axis.resetStacks) {\n                        axis.resetStacks();\n                    }\n\n                    axis.forceRedraw = false;\n\n                    // get data extremes if needed\n                    axis.getSeriesExtremes();\n\n                    // get fixed positions based on tickInterval\n                    axis.setTickInterval();\n\n                    // record old values to decide whether a rescale is necessary later on (#540)\n                    axis.oldUserMin = axis.userMin;\n                    axis.oldUserMax = axis.userMax;\n\n                    // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n                    if (!axis.isDirty) {\n                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n                    }\n                } else if (axis.cleanStacks) {\n                    axis.cleanStacks();\n                }\n            },\n\n            /**\n             * Set the minimum and maximum of the axes after render time. If the\n             * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n             * values are rounded off to the nearest tick. To prevent this, these\n             * options can be set to false before calling setExtremes. Also, setExtremes\n             * will not allow a range lower than the `minRange` option, which by default\n             * is the range of five points.\n             * \n             * @param  {Number} [newMin]\n             *         The new minimum value.\n             * @param  {Number} [newMax]\n             *         The new maximum value.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart or wait for an explicit call to \n             *         {@link Highcharts.Chart#redraw}\n             * @param  {AnimationOptions} [animation=true]\n             *         Enable or modify animations.\n             * @param  {Object} [eventArguments]\n             *         Arguments to be accessed in event handler.\n             *\n             * @sample highcharts/members/axis-setextremes/\n             *         Set extremes from a button\n             * @sample highcharts/members/axis-setextremes-datetime/\n             *         Set extremes on a datetime axis\n             * @sample highcharts/members/axis-setextremes-off-ticks/\n             *         Set extremes off ticks\n             * @sample stock/members/axis-setextremes/\n             *         Set extremes in Highstock\n             * @sample maps/members/axis-setextremes/\n             *         Set extremes in Highmaps\n             */\n            setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {\n                var axis = this,\n                    chart = axis.chart;\n\n                redraw = pick(redraw, true); // defaults to true\n\n                each(axis.series, function(serie) {\n                    delete serie.kdTree;\n                });\n\n                // Extend the arguments with min and max\n                eventArguments = extend(eventArguments, {\n                    min: newMin,\n                    max: newMax\n                });\n\n                // Fire the event\n                fireEvent(axis, 'setExtremes', eventArguments, function() { // the default event handler\n\n                    axis.userMin = newMin;\n                    axis.userMax = newMax;\n                    axis.eventArgs = eventArguments;\n\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                });\n            },\n\n            /**\n             * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n             * in stock charts.\n             */\n            zoom: function(newMin, newMax) {\n                var dataMin = this.dataMin,\n                    dataMax = this.dataMax,\n                    options = this.options,\n                    min = Math.min(dataMin, pick(options.min, dataMin)),\n                    max = Math.max(dataMax, pick(options.max, dataMax));\n\n                if (newMin !== this.min || newMax !== this.max) { // #5790\n\n                    // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n                    if (!this.allowZoomOutside) {\n                        // #6014, sometimes newMax will be smaller than min (or newMin will be larger than max).\n                        if (defined(dataMin)) {\n                            if (newMin < min) {\n                                newMin = min;\n                            }\n                            if (newMin > max) {\n                                newMin = max;\n                            }\n                        }\n                        if (defined(dataMax)) {\n                            if (newMax < min) {\n                                newMax = min;\n                            }\n                            if (newMax > max) {\n                                newMax = max;\n                            }\n                        }\n                    }\n\n                    // In full view, displaying the reset zoom button is not required\n                    this.displayBtn = newMin !== undefined || newMax !== undefined;\n\n                    // Do it\n                    this.setExtremes(\n                        newMin,\n                        newMax,\n                        false,\n                        undefined, {\n                            trigger: 'zoom'\n                        }\n                    );\n                }\n\n                return true;\n            },\n\n            /**\n             * Update the axis metrics\n             */\n            setAxisSize: function() {\n                var chart = this.chart,\n                    options = this.options,\n                    offsets = options.offsets || [0, 0, 0, 0], // top / right / bottom / left\n                    horiz = this.horiz,\n                    width = pick(options.width, chart.plotWidth - offsets[3] + offsets[1]),\n                    height = pick(options.height, chart.plotHeight - offsets[0] + offsets[2]),\n                    top = pick(options.top, chart.plotTop + offsets[0]),\n                    left = pick(options.left, chart.plotLeft + offsets[3]),\n                    percentRegex = /%$/;\n\n                // Check for percentage based input values. Rounding fixes problems with\n                // column overflow and plot line filtering (#4898, #4899)\n                if (percentRegex.test(height)) {\n                    height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n                }\n                if (percentRegex.test(top)) {\n                    top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n                }\n\n                // Expose basic values to use in Series object and navigator\n                this.left = left;\n                this.top = top;\n                this.width = width;\n                this.height = height;\n                this.bottom = chart.chartHeight - height - top;\n                this.right = chart.chartWidth - width - left;\n\n                // Direction agnostic properties\n                this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n                this.pos = horiz ? left : top; // distance from SVG origin\n            },\n\n            /**\n             * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n             * function. \n             * @typedef {Object} Extremes\n             * @property {Number} dataMax\n             *         The maximum value of the axis' associated series.\n             * @property {Number} dataMin\n             *         The minimum value of the axis' associated series.\n             * @property {Number} max\n             *         The maximum axis value, either automatic or set manually. If the\n             *         `max` option is not set, `maxPadding` is 0 and `endOnTick` is\n             *         false, this value will be the same as `dataMax`.\n             * @property {Number} min\n             *         The minimum axis value, either automatic or set manually. If the\n             *         `min` option is not set, `minPadding` is 0 and `startOnTick` is\n             *         false, this value will be the same as `dataMin`.\n             */\n            /**\n             * Get the current extremes for the axis.\n             *\n             * @returns {Extremes}\n             * An object containing extremes information.\n             * \n             * @sample  members/axis-getextremes/\n             *          Report extremes by click on a button\n             * @sample  maps/members/axis-getextremes/\n             *          Get extremes in Highmaps\n             */\n            getExtremes: function() {\n                var axis = this,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log;\n\n                return {\n                    min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n                    max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n                    dataMin: axis.dataMin,\n                    dataMax: axis.dataMax,\n                    userMin: axis.userMin,\n                    userMax: axis.userMax\n                };\n            },\n\n            /**\n             * Get the zero plane either based on zero or on the min or max value.\n             * Used in bar and area plots\n             */\n            getThreshold: function(threshold) {\n                var axis = this,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log,\n                    realMin = isLog ? lin2log(axis.min) : axis.min,\n                    realMax = isLog ? lin2log(axis.max) : axis.max;\n\n                if (threshold === null) {\n                    threshold = realMin;\n                } else if (realMin > threshold) {\n                    threshold = realMin;\n                } else if (realMax < threshold) {\n                    threshold = realMax;\n                }\n\n                return axis.translate(threshold, 0, 1, 0, 1);\n            },\n\n            /**\n             * Compute auto alignment for the axis label based on which side the axis is\n             * on and the given rotation for the label.\n             *\n             * @param  {Number} rotation\n             *         The rotation in degrees as set by either the `rotation` or \n             *         `autoRotation` options.\n             * @private\n             */\n            autoLabelAlign: function(rotation) {\n                var ret,\n                    angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n                if (angle > 15 && angle < 165) {\n                    ret = 'right';\n                } else if (angle > 195 && angle < 345) {\n                    ret = 'left';\n                } else {\n                    ret = 'center';\n                }\n                return ret;\n            },\n\n            /**\n             * Get the tick length and width for the axis.\n             * @param   {String} prefix 'tick' or 'minorTick'\n             * @returns {Array}        An array of tickLength and tickWidth\n             */\n            tickSize: function(prefix) {\n                var options = this.options,\n                    tickLength = options[prefix + 'Length'],\n                    tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1\n\n                if (tickWidth && tickLength) {\n                    // Negate the length\n                    if (options[prefix + 'Position'] === 'inside') {\n                        tickLength = -tickLength;\n                    }\n                    return [tickLength, tickWidth];\n                }\n\n            },\n\n            /**\n             * Return the size of the labels\n             */\n            labelMetrics: function() {\n                var index = this.tickPositions && this.tickPositions[0] || 0;\n                return this.chart.renderer.fontMetrics(\n                    this.options.labels.style && this.options.labels.style.fontSize,\n                    this.ticks[index] && this.ticks[index].label\n                );\n            },\n\n            /**\n             * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n             * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n             * On a vertical axis remove ticks and add ellipsis.\n             */\n            unsquish: function() {\n                var labelOptions = this.options.labels,\n                    horiz = this.horiz,\n                    tickInterval = this.tickInterval,\n                    newTickInterval = tickInterval,\n                    slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n                    rotation,\n                    rotationOption = labelOptions.rotation,\n                    labelMetrics = this.labelMetrics(),\n                    step,\n                    bestScore = Number.MAX_VALUE,\n                    autoRotation,\n                    // Return the multiple of tickInterval that is needed to avoid collision\n                    getStep = function(spaceNeeded) {\n                        var step = spaceNeeded / (slotSize || 1);\n                        step = step > 1 ? Math.ceil(step) : 1;\n                        return step * tickInterval;\n                    };\n\n                if (horiz) {\n                    autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                        defined(rotationOption) ? [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n                    );\n\n                    if (autoRotation) {\n\n                        // Loop over the given autoRotation options, and determine which gives the best score. The\n                        // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                        each(autoRotation, function(rot) {\n                            var score;\n\n                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\n                                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n\n                                score = step + Math.abs(rot / 360);\n\n                                if (score < bestScore) {\n                                    bestScore = score;\n                                    rotation = rot;\n                                    newTickInterval = step;\n                                }\n                            }\n                        });\n                    }\n\n                } else if (!labelOptions.step) { // #4411\n                    newTickInterval = getStep(labelMetrics.h);\n                }\n\n                this.autoRotation = autoRotation;\n                this.labelRotation = pick(rotation, rotationOption);\n\n                return newTickInterval;\n            },\n\n            /**\n             * Get the general slot width for this axis. This may change between the pre-render (from Axis.getOffset) \n             * and the final tick rendering and placement (#5086).\n             */\n            getSlotWidth: function() {\n                var chart = this.chart,\n                    horiz = this.horiz,\n                    labelOptions = this.options.labels,\n                    slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n                    marginLeft = chart.margin[3];\n\n                return (\n                    horiz &&\n                    (labelOptions.step || 0) < 2 &&\n                    !labelOptions.rotation && // #4415\n                    ((this.staggerLines || 1) * this.len) / slotCount\n                ) || (!horiz && (\n                    (marginLeft && (marginLeft - chart.spacing[3])) ||\n                    chart.chartWidth * 0.33\n                )); // #1580, #1931\n\n            },\n\n            /**\n             * Render the axis labels and determine whether ellipsis or rotation need to be applied\n             */\n            renderUnsquish: function() {\n                var chart = this.chart,\n                    renderer = chart.renderer,\n                    tickPositions = this.tickPositions,\n                    ticks = this.ticks,\n                    labelOptions = this.options.labels,\n                    horiz = this.horiz,\n                    slotWidth = this.getSlotWidth(),\n                    innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n                    attr = {},\n                    labelMetrics = this.labelMetrics(),\n                    textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,\n                    css,\n                    maxLabelLength = 0,\n                    label,\n                    i,\n                    pos;\n\n                // Set rotation option unless it is \"auto\", like in gauges\n                if (!isString(labelOptions.rotation)) {\n                    attr.rotation = labelOptions.rotation || 0; // #4443\n                }\n\n                // Get the longest label length\n                each(tickPositions, function(tick) {\n                    tick = ticks[tick];\n                    if (tick && tick.labelLength > maxLabelLength) {\n                        maxLabelLength = tick.labelLength;\n                    }\n                });\n                this.maxLabelLength = maxLabelLength;\n\n\n                // Handle auto rotation on horizontal axis\n                if (this.autoRotation) {\n\n                    // Apply rotation only if the label is too wide for the slot, and\n                    // the label is wider than its height.\n                    if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n                        attr.rotation = this.labelRotation;\n                    } else {\n                        this.labelRotation = 0;\n                    }\n\n                    // Handle word-wrap or ellipsis on vertical axis\n                } else if (slotWidth) {\n                    // For word-wrap or ellipsis\n                    css = {\n                        width: innerWidth + 'px'\n                    };\n\n                    if (!textOverflowOption) {\n                        css.textOverflow = 'clip';\n\n                        // On vertical axis, only allow word wrap if there is room for more lines.\n                        i = tickPositions.length;\n                        while (!horiz && i--) {\n                            pos = tickPositions[i];\n                            label = ticks[pos].label;\n                            if (label) {\n                                // Reset ellipsis in order to get the correct bounding box (#4070)\n                                if (label.styles && label.styles.textOverflow === 'ellipsis') {\n                                    label.css({\n                                        textOverflow: 'clip'\n                                    });\n\n                                    // Set the correct width in order to read the bounding box height (#4678, #5034)\n                                } else if (ticks[pos].labelLength > slotWidth) {\n                                    label.css({\n                                        width: slotWidth + 'px'\n                                    });\n                                }\n\n                                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n                                    label.specCss = {\n                                        textOverflow: 'ellipsis'\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n\n\n                // Add ellipsis if the label length is significantly longer than ideal\n                if (attr.rotation) {\n                    css = {\n                        width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'\n                    };\n                    if (!textOverflowOption) {\n                        css.textOverflow = 'ellipsis';\n                    }\n                }\n\n                // Set the explicit or automatic label alignment\n                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n                if (this.labelAlign) {\n                    attr.align = this.labelAlign;\n                }\n\n                // Apply general and specific CSS\n                each(tickPositions, function(pos) {\n                    var tick = ticks[pos],\n                        label = tick && tick.label;\n                    if (label) {\n                        label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                        if (css) {\n                            label.css(merge(css, label.specCss));\n                        }\n                        delete label.specCss;\n                        tick.rotation = attr.rotation;\n                    }\n                });\n\n                // Note: Why is this not part of getLabelPosition?\n                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n            },\n\n            /**\n             * Return true if the axis has associated data\n             */\n            hasData: function() {\n                return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n            },\n\n            /**\n             * Adds the title defined in axis.options.title.\n             * @param {Boolean} display - whether or not to display the title\n             */\n            addTitle: function(display) {\n                var axis = this,\n                    renderer = axis.chart.renderer,\n                    horiz = axis.horiz,\n                    opposite = axis.opposite,\n                    options = axis.options,\n                    axisTitleOptions = options.title,\n                    textAlign;\n\n                if (!axis.axisTitle) {\n                    textAlign = axisTitleOptions.textAlign;\n                    if (!textAlign) {\n                        textAlign = (horiz ? {\n                            low: 'left',\n                            middle: 'center',\n                            high: 'right'\n                        } : {\n                            low: opposite ? 'right' : 'left',\n                            middle: 'center',\n                            high: opposite ? 'left' : 'right'\n                        })[axisTitleOptions.align];\n                    }\n                    axis.axisTitle = renderer.text(\n                            axisTitleOptions.text,\n                            0,\n                            0,\n                            axisTitleOptions.useHTML\n                        )\n                        .attr({\n                            zIndex: 7,\n                            rotation: axisTitleOptions.rotation || 0,\n                            align: textAlign\n                        })\n                        .addClass('highcharts-axis-title')\n\n                        .css(axisTitleOptions.style)\n\n                        .add(axis.axisGroup);\n                    axis.axisTitle.isNew = true;\n                }\n\n                // hide or show the title depending on whether showEmpty is set\n                axis.axisTitle[display ? 'show' : 'hide'](true);\n            },\n\n            /**\n             * Generates a tick for initial positioning.\n             *\n             * @private\n             * @param  {number} pos\n             *         The tick position in axis values.\n             * @param  {number} i\n             *         The index of the tick in {@link Axis.tickPositions}.\n             */\n            generateTick: function(pos) {\n                var ticks = this.ticks;\n\n                if (!ticks[pos]) {\n                    ticks[pos] = new Tick(this, pos);\n                } else {\n                    ticks[pos].addLabel(); // update labels depending on tick interval\n                }\n            },\n\n            /**\n             * Render the tick labels to a preliminary position to get their sizes\n             */\n            getOffset: function() {\n                var axis = this,\n                    chart = axis.chart,\n                    renderer = chart.renderer,\n                    options = axis.options,\n                    tickPositions = axis.tickPositions,\n                    ticks = axis.ticks,\n                    horiz = axis.horiz,\n                    side = axis.side,\n                    invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n                    hasData,\n                    showAxis,\n                    titleOffset = 0,\n                    titleOffsetOption,\n                    titleMargin = 0,\n                    axisTitleOptions = options.title,\n                    labelOptions = options.labels,\n                    labelOffset = 0, // reset\n                    labelOffsetPadded,\n                    axisOffset = chart.axisOffset,\n                    clipOffset = chart.clipOffset,\n                    clip,\n                    directionFactor = [-1, 1, 1, -1][side],\n                    className = options.className,\n                    axisParent = axis.axisParent, // Used in color axis\n                    lineHeightCorrection,\n                    tickSize = this.tickSize('tick');\n\n                // For reuse in Axis.render\n                hasData = axis.hasData();\n                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n                // Set/reset staggerLines\n                axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n                // Create the axisGroup and gridGroup elements on first iteration\n                if (!axis.axisGroup) {\n                    axis.gridGroup = renderer.g('grid')\n                        .attr({\n                            zIndex: options.gridZIndex || 1\n                        })\n                        .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || ''))\n                        .add(axisParent);\n                    axis.axisGroup = renderer.g('axis')\n                        .attr({\n                            zIndex: options.zIndex || 2\n                        })\n                        .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || ''))\n                        .add(axisParent);\n                    axis.labelGroup = renderer.g('axis-labels')\n                        .attr({\n                            zIndex: labelOptions.zIndex || 7\n                        })\n                        .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))\n                        .add(axisParent);\n                }\n\n                if (hasData || axis.isLinked) {\n\n                    // Generate ticks\n                    each(tickPositions, function(pos, i) {\n                        // i is not used here, but may be used in overrides\n                        axis.generateTick(pos, i);\n                    });\n\n                    axis.renderUnsquish();\n\n\n                    // Left side must be align: right and right side must have align: left for labels\n                    if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 || {\n                            1: 'left',\n                            3: 'right'\n                        }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                        each(tickPositions, function(pos) {\n\n                            // get the highest offset\n                            labelOffset = Math.max(\n                                ticks[pos].getLabelSize(),\n                                labelOffset\n                            );\n                        });\n                    }\n\n                    if (axis.staggerLines) {\n                        labelOffset *= axis.staggerLines;\n                        axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n                    }\n\n\n                } else { // doesn't have data\n                    objectEach(ticks, function(tick, n) {\n                        tick.destroy();\n                        delete ticks[n];\n                    });\n                }\n\n                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n                    axis.addTitle(showAxis);\n\n                    if (showAxis && axisTitleOptions.reserveSpace !== false) {\n                        axis.titleOffset = titleOffset =\n                            axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                        titleOffsetOption = axisTitleOptions.offset;\n                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n                    }\n                }\n\n                // Render the axis line\n                axis.renderLine();\n\n                // handle automatic or user set offset\n                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n                axis.tickRotCorr = axis.tickRotCorr || {\n                    x: 0,\n                    y: 0\n                }; // polar\n                if (side === 0) {\n                    lineHeightCorrection = -axis.labelMetrics().h;\n                } else if (side === 2) {\n                    lineHeightCorrection = axis.tickRotCorr.y;\n                } else {\n                    lineHeightCorrection = 0;\n                }\n\n                // Find the padded label offset\n                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n                if (labelOffset) {\n                    labelOffsetPadded -= lineHeightCorrection;\n                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n                }\n                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n                axisOffset[side] = Math.max(\n                    axisOffset[side],\n                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n                    labelOffsetPadded, // #3027\n                    hasData && tickPositions.length && tickSize ?\n                    tickSize[0] + directionFactor * axis.offset :\n                    0 // #4866\n                );\n\n                // Decide the clipping needed to keep the graph inside the plot area and\n                // axis lines\n                clip = Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n                if (options.offset > 0) {\n                    clip -= options.offset * 2;\n                }\n                clipOffset[invertedSide] = Math.max(\n                    clipOffset[invertedSide] || clip,\n                    clip\n                );\n            },\n\n            /**\n             * Internal function to get the path for the axis line. Extended for polar\n             * charts.\n             *\n             * @param  {Number} lineWidth\n             *         The line width in pixels.\n             * @return {Array}\n             *         The SVG path definition in array form.\n             */\n            getLinePath: function(lineWidth) {\n                var chart = this.chart,\n                    opposite = this.opposite,\n                    offset = this.offset,\n                    horiz = this.horiz,\n                    lineLeft = this.left + (opposite ? this.width : 0) + offset,\n                    lineTop = chart.chartHeight - this.bottom -\n                    (opposite ? this.height : 0) + offset;\n\n                if (opposite) {\n                    lineWidth *= -1; // crispify the other way - #1480, #1687\n                }\n\n                return chart.renderer\n                    .crispLine([\n                        'M',\n                        horiz ?\n                        this.left :\n                        lineLeft,\n                        horiz ?\n                        lineTop :\n                        this.top,\n                        'L',\n                        horiz ?\n                        chart.chartWidth - this.right :\n                        lineLeft,\n                        horiz ?\n                        lineTop :\n                        chart.chartHeight - this.bottom\n                    ], lineWidth);\n            },\n\n            /**\n             * Render the axis line\n             */\n            renderLine: function() {\n                if (!this.axisLine) {\n                    this.axisLine = this.chart.renderer.path()\n                        .addClass('highcharts-axis-line')\n                        .add(this.axisGroup);\n\n\n                    this.axisLine.attr({\n                        stroke: this.options.lineColor,\n                        'stroke-width': this.options.lineWidth,\n                        zIndex: 7\n                    });\n\n                }\n            },\n\n            /**\n             * Position the title\n             */\n            getTitlePosition: function() {\n                // compute anchor points for each of the title align options\n                var horiz = this.horiz,\n                    axisLeft = this.left,\n                    axisTop = this.top,\n                    axisLength = this.len,\n                    axisTitleOptions = this.options.title,\n                    margin = horiz ? axisLeft : axisTop,\n                    opposite = this.opposite,\n                    offset = this.offset,\n                    xOption = axisTitleOptions.x || 0,\n                    yOption = axisTitleOptions.y || 0,\n                    fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, this.axisTitle).f,\n\n                    // the position in the length direction of the axis\n                    alongAxis = {\n                        low: margin + (horiz ? 0 : axisLength),\n                        middle: margin + axisLength / 2,\n                        high: margin + (horiz ? axisLength : 0)\n                    }[axisTitleOptions.align],\n\n                    // the position in the perpendicular direction of the axis\n                    offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                    (opposite ? -1 : 1) * // so does opposite axes\n                    this.axisTitleMargin +\n                    (this.side === 2 ? fontSize : 0);\n\n                return {\n                    x: horiz ?\n                        alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,\n                    y: horiz ?\n                        offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption\n                };\n            },\n\n            /**\n             * Render a minor tick into the given position. If a minor tick already \n             * exists in this position, move it.\n             * @param  {number} pos - The position in axis values.\n             */\n            renderMinorTick: function(pos) {\n                var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),\n                    minorTicks = this.minorTicks;\n\n                if (!minorTicks[pos]) {\n                    minorTicks[pos] = new Tick(this, pos, 'minor');\n                }\n\n                // Render new ticks in old position\n                if (slideInTicks && minorTicks[pos].isNew) {\n                    minorTicks[pos].render(null, true);\n                }\n\n                minorTicks[pos].render(null, false, 1);\n            },\n\n            /**\n             * Render a major tick into the given position. If a tick already exists\n             * in this position, move it.\n             * @param  {number} pos - The position in axis values\n             * @param  {number} i - The tick index\n             */\n            renderTick: function(pos, i) {\n                var isLinked = this.isLinked,\n                    ticks = this.ticks,\n                    slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);\n\n                // Linked axes need an extra check to find out if\n                if (!isLinked || (pos >= this.min && pos <= this.max)) {\n\n                    if (!ticks[pos]) {\n                        ticks[pos] = new Tick(this, pos);\n                    }\n\n                    // render new ticks in old position\n                    if (slideInTicks && ticks[pos].isNew) {\n                        ticks[pos].render(i, true, 0.1);\n                    }\n\n                    ticks[pos].render(i);\n                }\n            },\n\n            /**\n             * Render the axis\n             */\n            render: function() {\n                var axis = this,\n                    chart = axis.chart,\n                    renderer = chart.renderer,\n                    options = axis.options,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log,\n                    isLinked = axis.isLinked,\n                    tickPositions = axis.tickPositions,\n                    axisTitle = axis.axisTitle,\n                    ticks = axis.ticks,\n                    minorTicks = axis.minorTicks,\n                    alternateBands = axis.alternateBands,\n                    stackLabelOptions = options.stackLabels,\n                    alternateGridColor = options.alternateGridColor,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    axisLine = axis.axisLine,\n                    showAxis = axis.showAxis,\n                    animation = animObject(renderer.globalAnimation),\n                    from,\n                    to;\n\n                // Reset\n                axis.labelEdge.length = 0;\n                //axis.justifyToPlot = overflow === 'justify';\n                axis.overlap = false;\n\n                // Mark all elements inActive before we go over and mark the active ones\n                each([ticks, minorTicks, alternateBands], function(coll) {\n                    objectEach(coll, function(tick) {\n                        tick.isActive = false;\n                    });\n                });\n\n                // If the series has data draw the ticks. Else only the line and title\n                if (axis.hasData() || isLinked) {\n\n                    // minor ticks\n                    if (axis.minorTickInterval && !axis.categories) {\n                        each(axis.getMinorTickPositions(), function(pos) {\n                            axis.renderMinorTick(pos);\n                        });\n                    }\n\n                    // Major ticks. Pull out the first item and render it last so that\n                    // we can get the position of the neighbour label. #808.\n                    if (tickPositions.length) { // #1300\n                        each(tickPositions, function(pos, i) {\n                            axis.renderTick(pos, i);\n                        });\n                        // In a categorized axis, the tick marks are displayed between labels. So\n                        // we need to add a tick mark and grid line at the left edge of the X axis.\n                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                            if (!ticks[-1]) {\n                                ticks[-1] = new Tick(axis, -1, null, true);\n                            }\n                            ticks[-1].render(-1);\n                        }\n\n                    }\n\n                    // alternate grid color\n                    if (alternateGridColor) {\n                        each(tickPositions, function(pos, i) {\n                            to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;\n                            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                                if (!alternateBands[pos]) {\n                                    alternateBands[pos] = new H.PlotLineOrBand(axis);\n                                }\n                                from = pos + tickmarkOffset; // #949\n                                alternateBands[pos].options = {\n                                    from: isLog ? lin2log(from) : from,\n                                    to: isLog ? lin2log(to) : to,\n                                    color: alternateGridColor\n                                };\n                                alternateBands[pos].render();\n                                alternateBands[pos].isActive = true;\n                            }\n                        });\n                    }\n\n                    // custom plot lines and bands\n                    if (!axis._addedPlotLB) { // only first time\n                        each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {\n                            axis.addPlotBandOrLine(plotLineOptions);\n                        });\n                        axis._addedPlotLB = true;\n                    }\n\n                } // end if hasData\n\n                // Remove inactive ticks\n                each([ticks, minorTicks, alternateBands], function(coll) {\n                    var i,\n                        forDestruction = [],\n                        delay = animation.duration,\n                        destroyInactiveItems = function() {\n                            i = forDestruction.length;\n                            while (i--) {\n                                // When resizing rapidly, the same items may be destroyed in different timeouts,\n                                // or the may be reactivated\n                                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                                    coll[forDestruction[i]].destroy();\n                                    delete coll[forDestruction[i]];\n                                }\n                            }\n\n                        };\n\n                    objectEach(coll, function(tick, pos) {\n                        if (!tick.isActive) {\n                            // Render to zero opacity\n                            tick.render(pos, false, 0);\n                            tick.isActive = false;\n                            forDestruction.push(pos);\n                        }\n                    });\n\n                    // When the objects are finished fading out, destroy them\n                    syncTimeout(\n                        destroyInactiveItems,\n                        coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n                    );\n                });\n\n                // Set the axis line path\n                if (axisLine) {\n                    axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n                        d: this.getLinePath(axisLine.strokeWidth())\n                    });\n                    axisLine.isPlaced = true;\n\n                    // Show or hide the line depending on options.showEmpty\n                    axisLine[showAxis ? 'show' : 'hide'](true);\n                }\n\n                if (axisTitle && showAxis) {\n                    var titleXy = axis.getTitlePosition();\n                    if (isNumber(titleXy.y)) {\n                        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);\n                        axisTitle.isNew = false;\n                    } else {\n                        axisTitle.attr('y', -9999);\n                        axisTitle.isNew = true;\n                    }\n                }\n\n                // Stacked totals:\n                if (stackLabelOptions && stackLabelOptions.enabled) {\n                    axis.renderStackTotals();\n                }\n                // End stacked totals\n\n                axis.isDirty = false;\n            },\n\n            /**\n             * Redraw the axis to reflect changes in the data or axis extremes\n             */\n            redraw: function() {\n\n                if (this.visible) {\n                    // render the axis\n                    this.render();\n\n                    // move plot lines and bands\n                    each(this.plotLinesAndBands, function(plotLine) {\n                        plotLine.render();\n                    });\n                }\n\n                // mark associated series as dirty and ready for redraw\n                each(this.series, function(series) {\n                    series.isDirty = true;\n                });\n\n            },\n\n            // Properties to survive after destroy, needed for Axis.update (#4317,\n            // #5773, #5881).\n            keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],\n\n            /**\n             * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n             * to fully remove the axis.\n             *\n             * @private\n             * @param  {Boolean} keepEvents\n             *         Whether to preserve events, used internally in Axis.update.\n             */\n            destroy: function(keepEvents) {\n                var axis = this,\n                    stacks = axis.stacks,\n                    plotLinesAndBands = axis.plotLinesAndBands,\n                    plotGroup,\n                    i;\n\n                // Remove the events\n                if (!keepEvents) {\n                    removeEvent(axis);\n                }\n\n                // Destroy each stack total\n                objectEach(stacks, function(stack, stackKey) {\n                    destroyObjectProperties(stack);\n\n                    stacks[stackKey] = null;\n                });\n\n                // Destroy collections\n                each([axis.ticks, axis.minorTicks, axis.alternateBands], function(coll) {\n                    destroyObjectProperties(coll);\n                });\n                if (plotLinesAndBands) {\n                    i = plotLinesAndBands.length;\n                    while (i--) { // #1975\n                        plotLinesAndBands[i].destroy();\n                    }\n                }\n\n                // Destroy local variables\n                each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function(prop) {\n                    if (axis[prop]) {\n                        axis[prop] = axis[prop].destroy();\n                    }\n                });\n\n                // Destroy each generated group for plotlines and plotbands\n                for (plotGroup in axis.plotLinesAndBandsGroups) {\n                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();\n                }\n\n                // Delete all properties and fall back to the prototype.\n                objectEach(axis, function(val, key) {\n                    if (inArray(key, axis.keepProps) === -1) {\n                        delete axis[key];\n                    }\n                });\n            },\n\n            /**\n             * Internal function to draw a crosshair.\n             *\n             * @param  {PointerEvent} [e]\n             *         The event arguments from the modified pointer event, extended \n             *         with `chartX` and `chartY`\n             * @param  {Point} [point]\n             *         The Point object if the crosshair snaps to points.\n             */\n            drawCrosshair: function(e, point) {\n\n                var path,\n                    options = this.crosshair,\n                    snap = pick(options.snap, true),\n                    pos,\n                    categorized,\n                    graphic = this.cross;\n\n                // Use last available event when updating non-snapped crosshairs without\n                // mouse interaction (#5287)\n                if (!e) {\n                    e = this.cross && this.cross.e;\n                }\n\n                if (\n                    // Disabled in options\n                    !this.crosshair ||\n                    // Snap\n                    ((defined(point) || !snap) === false)\n                ) {\n                    this.hideCrosshair();\n                } else {\n\n                    // Get the path\n                    if (!snap) {\n                        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n                    } else if (defined(point)) {\n                        pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n                    }\n\n                    if (defined(pos)) {\n                        path = this.getPlotLinePath(\n                            // First argument, value, only used on radial\n                            point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),\n                            null,\n                            null,\n                            null,\n                            pos // Translated position\n                        ) || null; // #3189\n                    }\n\n                    if (!defined(path)) {\n                        this.hideCrosshair();\n                        return;\n                    }\n\n                    categorized = this.categories && !this.isRadial;\n\n                    // Draw the cross\n                    if (!graphic) {\n                        this.cross = graphic = this.chart.renderer\n                            .path()\n                            .addClass('highcharts-crosshair highcharts-crosshair-' +\n                                (categorized ? 'category ' : 'thin ') + options.className)\n                            .attr({\n                                zIndex: pick(options.zIndex, 2)\n                            })\n                            .add();\n\n\n                        // Presentational attributes\n                        graphic.attr({\n                            'stroke': options.color || (categorized ? color('#ccd6eb').setOpacity(0.25).get() : '#cccccc'),\n                            'stroke-width': pick(options.width, 1)\n                        });\n                        if (options.dashStyle) {\n                            graphic.attr({\n                                dashstyle: options.dashStyle\n                            });\n                        }\n\n\n                    }\n\n                    graphic.show().attr({\n                        d: path\n                    });\n\n                    if (categorized && !options.width) {\n                        graphic.attr({\n                            'stroke-width': this.transA\n                        });\n                    }\n                    this.cross.e = e;\n                }\n            },\n\n            /**\n             *\tHide the crosshair.\n             */\n            hideCrosshair: function() {\n                if (this.cross) {\n                    this.cross.hide();\n                }\n            }\n        }); // end Axis\n\n        H.Axis = Axis;\n        return Axis;\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            Date = H.Date,\n            dateFormat = H.dateFormat,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            getMagnitude = H.getMagnitude,\n            getTZOffset = H.getTZOffset,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick,\n            timeUnits = H.timeUnits;\n        /**\n         * Set the tick positions to a time unit that makes sense, for example\n         * on the first of each month or on every Monday. Return an array\n         * with the time positions. Used in datetime axes as well as for grouping\n         * data on a datetime axis.\n         *\n         * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n         * @param {Number} min The minimum in axis values\n         * @param {Number} max The maximum in axis values\n         * @param {Number} startOfWeek\n         */\n        Axis.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {\n            var tickPositions = [],\n                i,\n                higherRanks = {},\n                useUTC = defaultOptions.global.useUTC,\n                minYear, // used in months and years as a basis for Date.UTC()\n                // When crossing DST, use the max. Resolves #6278.\n                minDate = new Date(min - Math.max(getTZOffset(min), getTZOffset(max))),\n                makeTime = Date.hcMakeTime,\n                interval = normalizedInterval.unitRange,\n                count = normalizedInterval.count,\n                variableDayLength;\n\n            if (defined(min)) { // #1300\n                minDate[Date.hcSetMilliseconds](interval >= timeUnits.second ? 0 : // #3935\n                    count * Math.floor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n                if (interval >= timeUnits.second) { // second\n                    minDate[Date.hcSetSeconds](interval >= timeUnits.minute ? 0 : // #3935\n                        count * Math.floor(minDate.getSeconds() / count));\n                }\n\n                if (interval >= timeUnits.minute) { // minute\n                    minDate[Date.hcSetMinutes](interval >= timeUnits.hour ? 0 :\n                        count * Math.floor(minDate[Date.hcGetMinutes]() / count));\n                }\n\n                if (interval >= timeUnits.hour) { // hour\n                    minDate[Date.hcSetHours](interval >= timeUnits.day ? 0 :\n                        count * Math.floor(minDate[Date.hcGetHours]() / count));\n                }\n\n                if (interval >= timeUnits.day) { // day\n                    minDate[Date.hcSetDate](interval >= timeUnits.month ? 1 :\n                        count * Math.floor(minDate[Date.hcGetDate]() / count));\n                }\n\n                if (interval >= timeUnits.month) { // month\n                    minDate[Date.hcSetMonth](interval >= timeUnits.year ? 0 :\n                        count * Math.floor(minDate[Date.hcGetMonth]() / count));\n                    minYear = minDate[Date.hcGetFullYear]();\n                }\n\n                if (interval >= timeUnits.year) { // year\n                    minYear -= minYear % count;\n                    minDate[Date.hcSetFullYear](minYear);\n                }\n\n                // week is a special case that runs outside the hierarchy\n                if (interval === timeUnits.week) {\n                    // get start of current week, independent of count\n                    minDate[Date.hcSetDate](minDate[Date.hcGetDate]() - minDate[Date.hcGetDay]() +\n                        pick(startOfWeek, 1));\n                }\n\n\n                // Get basics for variable time spans\n                minYear = minDate[Date.hcGetFullYear]();\n                var minMonth = minDate[Date.hcGetMonth](),\n                    minDateDate = minDate[Date.hcGetDate](),\n                    minHours = minDate[Date.hcGetHours]();\n\n\n                // Handle local timezone offset\n                if (Date.hcTimezoneOffset || Date.hcGetTimezoneOffset) {\n\n                    // Detect whether we need to take the DST crossover into\n                    // consideration. If we're crossing over DST, the day length may be\n                    // 23h or 25h and we need to compute the exact clock time for each\n                    // tick instead of just adding hours. This comes at a cost, so first\n                    // we found out if it is needed. #4951.\n                    variableDayLength =\n                        (!useUTC || !!Date.hcGetTimezoneOffset) &&\n                        (\n                            // Long range, assume we're crossing over.\n                            max - min > 4 * timeUnits.month ||\n                            // Short range, check if min and max are in different time \n                            // zones.\n                            getTZOffset(min) !== getTZOffset(max)\n                        );\n\n                    // Adjust minDate to the offset date\n                    minDate = minDate.getTime();\n                    minDate = new Date(minDate + getTZOffset(minDate));\n                }\n\n\n                // Iterate and add tick positions at appropriate values\n                var time = minDate.getTime();\n                i = 1;\n                while (time < max) {\n                    tickPositions.push(time);\n\n                    // if the interval is years, use Date.UTC to increase years\n                    if (interval === timeUnits.year) {\n                        time = makeTime(minYear + i * count, 0);\n\n                        // if the interval is months, use Date.UTC to increase months\n                    } else if (interval === timeUnits.month) {\n                        time = makeTime(minYear, minMonth + i * count);\n\n                        // if we're using global time, the interval is not fixed as it jumps\n                        // one hour at the DST crossover\n                    } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n                        time = makeTime(minYear, minMonth, minDateDate +\n                            i * count * (interval === timeUnits.day ? 1 : 7));\n\n                    } else if (variableDayLength && interval === timeUnits.hour) {\n                        time = makeTime(minYear, minMonth, minDateDate, minHours + i * count);\n\n                        // else, the interval is fixed and we use simple addition\n                    } else {\n                        time += interval * count;\n                    }\n\n                    i++;\n                }\n\n                // push the last time\n                tickPositions.push(time);\n\n\n                // Handle higher ranks. Mark new days if the time is on midnight\n                // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold to \n                // prevent looping over dense data grouping (#6156).\n                if (interval <= timeUnits.hour && tickPositions.length < 10000) {\n                    each(tickPositions, function(time) {\n                        if (\n                            // Speed optimization, no need to run dateFormat unless\n                            // we're on a full or half hour\n                            time % 1800000 === 0 &&\n                            // Check for local or global midnight\n                            dateFormat('%H%M%S%L', time) === '000000000'\n                        ) {\n                            higherRanks[time] = 'day';\n                        }\n                    });\n                }\n            }\n\n\n            // record information on the chosen unit - for dynamic label formatter\n            tickPositions.info = extend(normalizedInterval, {\n                higherRanks: higherRanks,\n                totalRange: interval * count\n            });\n\n            return tickPositions;\n        };\n\n        /**\n         * Get a normalized tick interval for dates. Returns a configuration object with\n         * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n         * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n         * of segments in stock charts, the normalizing logic was extracted in order to\n         * prevent it for running over again for each segment having the same interval.\n         * #662, #697.\n         */\n        Axis.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {\n            var units = unitsOption || [\n                    [\n                        'millisecond', // unit name\n                        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n                    ],\n                    [\n                        'second', [1, 2, 5, 10, 15, 30]\n                    ],\n                    [\n                        'minute', [1, 2, 5, 10, 15, 30]\n                    ],\n                    [\n                        'hour', [1, 2, 3, 4, 6, 8, 12]\n                    ],\n                    [\n                        'day', [1, 2]\n                    ],\n                    [\n                        'week', [1, 2]\n                    ],\n                    [\n                        'month', [1, 2, 3, 4, 6]\n                    ],\n                    [\n                        'year',\n                        null\n                    ]\n                ],\n                unit = units[units.length - 1], // default unit is years\n                interval = timeUnits[unit[0]],\n                multiples = unit[1],\n                count,\n                i;\n\n            // loop through the units to find the one that best fits the tickInterval\n            for (i = 0; i < units.length; i++) {\n                unit = units[i];\n                interval = timeUnits[unit[0]];\n                multiples = unit[1];\n\n\n                if (units[i + 1]) {\n                    // lessThan is in the middle between the highest multiple and the next unit.\n                    var lessThan = (interval * multiples[multiples.length - 1] +\n                        timeUnits[units[i + 1][0]]) / 2;\n\n                    // break and keep the current unit\n                    if (tickInterval <= lessThan) {\n                        break;\n                    }\n                }\n            }\n\n            // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n            if (interval === timeUnits.year && tickInterval < 5 * interval) {\n                multiples = [1, 2, 5];\n            }\n\n            // get the count\n            count = normalizeTickInterval(\n                tickInterval / interval,\n                multiples,\n                unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n            );\n\n            return {\n                unitRange: interval,\n                count: count,\n                unitName: unit[0]\n            };\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            getMagnitude = H.getMagnitude,\n            map = H.map,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick;\n        /**\n         * Methods defined on the Axis prototype\n         */\n\n        /**\n         * Set the tick positions of a logarithmic axis\n         */\n        Axis.prototype.getLogTickPositions = function(interval, min, max, minor) {\n            var axis = this,\n                options = axis.options,\n                axisLength = axis.len,\n                lin2log = axis.lin2log,\n                log2lin = axis.log2lin,\n                // Since we use this method for both major and minor ticks,\n                // use a local variable and return the result\n                positions = [];\n\n            // Reset\n            if (!minor) {\n                axis._minorAutoInterval = null;\n            }\n\n            // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n            if (interval >= 0.5) {\n                interval = Math.round(interval);\n                positions = axis.getLinearTickPositions(interval, min, max);\n\n                // Second case: We need intermediary ticks. For example\n                // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n            } else if (interval >= 0.08) {\n                var roundedMin = Math.floor(min),\n                    intermediate,\n                    i,\n                    j,\n                    len,\n                    pos,\n                    lastPos,\n                    break2;\n\n                if (interval > 0.3) {\n                    intermediate = [1, 2, 4];\n                } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n                    intermediate = [1, 2, 4, 6, 8];\n                } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n                    intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n                }\n\n                for (i = roundedMin; i < max + 1 && !break2; i++) {\n                    len = intermediate.length;\n                    for (j = 0; j < len && !break2; j++) {\n                        pos = log2lin(lin2log(i) * intermediate[j]);\n                        if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113\n                            positions.push(lastPos);\n                        }\n\n                        if (lastPos > max) {\n                            break2 = true;\n                        }\n                        lastPos = pos;\n                    }\n                }\n\n                // Third case: We are so deep in between whole logarithmic values that\n                // we might as well handle the tick positions like a linear axis. For\n                // example 1.01, 1.02, 1.03, 1.04.\n            } else {\n                var realMin = lin2log(min),\n                    realMax = lin2log(max),\n                    tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n                    filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n                interval = pick(\n                    filteredTickIntervalOption,\n                    axis._minorAutoInterval,\n                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n                );\n\n                interval = normalizeTickInterval(\n                    interval,\n                    null,\n                    getMagnitude(interval)\n                );\n\n                positions = map(axis.getLinearTickPositions(\n                    interval,\n                    realMin,\n                    realMax\n                ), log2lin);\n\n                if (!minor) {\n                    axis._minorAutoInterval = interval / 5;\n                }\n            }\n\n            // Set the axis-level tickInterval variable\n            if (!minor) {\n                axis.tickInterval = interval;\n            }\n            return positions;\n        };\n\n        Axis.prototype.log2lin = function(num) {\n            return Math.log(num) / Math.LN10;\n        };\n\n        Axis.prototype.lin2log = function(num) {\n            return Math.pow(10, num);\n        };\n\n    }(Highcharts));\n    (function(H, Axis) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            erase = H.erase,\n            merge = H.merge,\n            pick = H.pick;\n        /*\n         * The object wrapper for plot lines and plot bands\n         * @param {Object} options\n         */\n        H.PlotLineOrBand = function(axis, options) {\n            this.axis = axis;\n\n            if (options) {\n                this.options = options;\n                this.id = options.id;\n            }\n        };\n\n        H.PlotLineOrBand.prototype = {\n\n            /**\n             * Render the plot line or plot band. If it is already existing,\n             * move it.\n             */\n            render: function() {\n                var plotLine = this,\n                    axis = plotLine.axis,\n                    horiz = axis.horiz,\n                    options = plotLine.options,\n                    optionsLabel = options.label,\n                    label = plotLine.label,\n                    to = options.to,\n                    from = options.from,\n                    value = options.value,\n                    isBand = defined(from) && defined(to),\n                    isLine = defined(value),\n                    svgElem = plotLine.svgElem,\n                    isNew = !svgElem,\n                    path = [],\n                    color = options.color,\n                    zIndex = pick(options.zIndex, 0),\n                    events = options.events,\n                    attribs = {\n                        'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')\n                    },\n                    groupAttribs = {},\n                    renderer = axis.chart.renderer,\n                    groupName = isBand ? 'bands' : 'lines',\n                    group,\n                    log2lin = axis.log2lin;\n\n                // logarithmic conversion\n                if (axis.isLog) {\n                    from = log2lin(from);\n                    to = log2lin(to);\n                    value = log2lin(value);\n                }\n\n\n                // Set the presentational attributes\n                if (isLine) {\n                    attribs = {\n                        stroke: color,\n                        'stroke-width': options.width\n                    };\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n\n                } else if (isBand) { // plot band\n                    if (color) {\n                        attribs.fill = color;\n                    }\n                    if (options.borderWidth) {\n                        attribs.stroke = options.borderColor;\n                        attribs['stroke-width'] = options.borderWidth;\n                    }\n                }\n\n\n                // Grouping and zIndex\n                groupAttribs.zIndex = zIndex;\n                groupName += '-' + zIndex;\n\n                group = axis.plotLinesAndBandsGroups[groupName];\n                if (!group) {\n                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName)\n                        .attr(groupAttribs).add();\n                }\n\n                // Create the path\n                if (isNew) {\n                    plotLine.svgElem = svgElem =\n                        renderer\n                        .path()\n                        .attr(attribs).add(group);\n                }\n\n\n                // Set the path or return\n                if (isLine) {\n                    path = axis.getPlotLinePath(value, svgElem.strokeWidth());\n                } else if (isBand) { // plot band\n                    path = axis.getPlotBandPath(from, to, options);\n                } else {\n                    return;\n                }\n\n\n                // common for lines and bands\n                if (isNew && path && path.length) {\n                    svgElem.attr({\n                        d: path\n                    });\n\n                    // events\n                    if (events) {\n                        H.objectEach(events, function(event, eventType) {\n                            svgElem.on(eventType, function(e) {\n                                events[eventType].apply(plotLine, [e]);\n                            });\n                        });\n                    }\n                } else if (svgElem) {\n                    if (path) {\n                        svgElem.show();\n                        svgElem.animate({\n                            d: path\n                        });\n                    } else {\n                        svgElem.hide();\n                        if (label) {\n                            plotLine.label = label = label.destroy();\n                        }\n                    }\n                }\n\n                // the plot band/line label\n                if (optionsLabel && defined(optionsLabel.text) && path && path.length &&\n                    axis.width > 0 && axis.height > 0 && !path.flat) {\n                    // apply defaults\n                    optionsLabel = merge({\n                        align: horiz && isBand && 'center',\n                        x: horiz ? !isBand && 4 : 10,\n                        verticalAlign: !horiz && isBand && 'middle',\n                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                        rotation: horiz && !isBand && 90\n                    }, optionsLabel);\n\n                    this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n                } else if (label) { // move out of sight\n                    label.hide();\n                }\n\n                // chainable\n                return plotLine;\n            },\n\n            /**\n             * Render and align label for plot line or band.\n             */\n            renderLabel: function(optionsLabel, path, isBand, zIndex) {\n                var plotLine = this,\n                    label = plotLine.label,\n                    renderer = plotLine.axis.chart.renderer,\n                    attribs,\n                    xs,\n                    ys,\n                    x,\n                    y;\n\n                // add the SVG element\n                if (!label) {\n                    attribs = {\n                        align: optionsLabel.textAlign || optionsLabel.align,\n                        rotation: optionsLabel.rotation,\n                        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')\n                    };\n\n                    attribs.zIndex = zIndex;\n\n                    plotLine.label = label = renderer.text(\n                            optionsLabel.text,\n                            0,\n                            0,\n                            optionsLabel.useHTML\n                        )\n                        .attr(attribs)\n                        .add();\n\n\n                    label.css(optionsLabel.style);\n\n                }\n\n                // get the bounding box and align the label\n                // #3000 changed to better handle choice between plotband or plotline\n                xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n                ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n                x = arrayMin(xs);\n                y = arrayMin(ys);\n\n                label.align(optionsLabel, false, {\n                    x: x,\n                    y: y,\n                    width: arrayMax(xs) - x,\n                    height: arrayMax(ys) - y\n                });\n                label.show();\n            },\n\n            /**\n             * Remove the plot line or band\n             */\n            destroy: function() {\n                // remove it from the lookup\n                erase(this.axis.plotLinesAndBands, this);\n\n                delete this.axis;\n                destroyObjectProperties(this);\n            }\n        };\n\n        /**\n         * Object with members for extending the Axis prototype\n         * @todo Extend directly instead of adding object to Highcharts first\n         */\n\n        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Create the path for a plot band\n             */\n            getPlotBandPath: function(from, to) {\n                var toPath = this.getPlotLinePath(to, null, null, true),\n                    path = this.getPlotLinePath(from, null, null, true),\n                    // #4964 check if chart is inverted or plotband is on yAxis \n                    horiz = this.horiz,\n                    plus = 1,\n                    outside =\n                    (from < this.min && to < this.min) ||\n                    (from > this.max && to > this.max);\n\n                if (path && toPath) {\n\n                    // Flat paths don't need labels (#3836)\n                    if (outside) {\n                        path.flat = path.toString() === toPath.toString();\n                        plus = 0;\n                    }\n\n                    // Add 1 pixel, when coordinates are the same\n                    path.push(\n                        horiz && toPath[4] === path[4] ? toPath[4] + plus : toPath[4], !horiz && toPath[5] === path[5] ? toPath[5] + plus : toPath[5],\n                        horiz && toPath[1] === path[1] ? toPath[1] + plus : toPath[1], !horiz && toPath[2] === path[2] ? toPath[2] + plus : toPath[2]\n                    );\n                } else { // outside the axis area\n                    path = null;\n                }\n\n                return path;\n            },\n\n            /**\n             * Add a plot band after render time.\n             *\n             * @param  {AxisPlotBandsOptions} options\n             *         A configuration object for the plot band, as defined in {@link\n             *         https://api.highcharts.com/highcharts/xAxis.plotBands|\n             *         xAxis.plotBands}.\n             * @return {Object}\n             *         The added plot band.\n             * @sample highcharts/members/axis-addplotband/\n             *         Toggle the plot band from a button\n             */\n            addPlotBand: function(options) {\n                return this.addPlotBandOrLine(options, 'plotBands');\n            },\n\n            /**\n             * Add a plot line after render time.\n             * \n             * @param  {AxisPlotLinesOptions} options\n             *         A configuration object for the plot line, as defined in {@link\n             *         https://api.highcharts.com/highcharts/xAxis.plotLines|\n             *         xAxis.plotLines}.\n             * @return {Object}\n             *         The added plot line.\n             * @sample highcharts/members/axis-addplotline/\n             *         Toggle the plot line from a button\n             */\n            addPlotLine: function(options) {\n                return this.addPlotBandOrLine(options, 'plotLines');\n            },\n\n            /**\n             * Add a plot band or plot line after render time. Called from addPlotBand\n             * and addPlotLine internally.\n             *\n             * @private\n             * @param  options {AxisPlotLinesOptions|AxisPlotBandsOptions}\n             *         The plotBand or plotLine configuration object.\n             */\n            addPlotBandOrLine: function(options, coll) {\n                var obj = new H.PlotLineOrBand(this, options).render(),\n                    userOptions = this.userOptions;\n\n                if (obj) { // #2189\n                    // Add it to the user options for exporting and Axis.update\n                    if (coll) {\n                        userOptions[coll] = userOptions[coll] || [];\n                        userOptions[coll].push(options);\n                    }\n                    this.plotLinesAndBands.push(obj);\n                }\n\n                return obj;\n            },\n\n            /**\n             * Remove a plot band or plot line from the chart by id. Called internally\n             * from `removePlotBand` and `removePlotLine`.\n             *\n             * @private\n             * @param {String} id\n             */\n            removePlotBandOrLine: function(id) {\n                var plotLinesAndBands = this.plotLinesAndBands,\n                    options = this.options,\n                    userOptions = this.userOptions,\n                    i = plotLinesAndBands.length;\n                while (i--) {\n                    if (plotLinesAndBands[i].id === id) {\n                        plotLinesAndBands[i].destroy();\n                    }\n                }\n                each([\n                    options.plotLines || [],\n                    userOptions.plotLines || [],\n                    options.plotBands || [],\n                    userOptions.plotBands || []\n                ], function(arr) {\n                    i = arr.length;\n                    while (i--) {\n                        if (arr[i].id === id) {\n                            erase(arr, arr[i]);\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Remove a plot band by its id.\n             * \n             * @param  {String} id\n             *         The plot band's `id` as given in the original configuration\n             *         object or in the `addPlotBand` option.\n             * @sample highcharts/members/axis-removeplotband/\n             *         Remove plot band by id\n             * @sample highcharts/members/axis-addplotband/\n             *         Toggle the plot band from a button\n             */\n            removePlotBand: function(id) {\n                this.removePlotBandOrLine(id);\n            },\n\n            /**\n             * Remove a plot line by its id.\n             * @param  {String} id\n             *         The plot line's `id` as given in the original configuration\n             *         object or in the `addPlotLine` option.\n             * @sample highcharts/xaxis/plotlines-id/\n             *         Remove plot line by id\n             * @sample highcharts/members/axis-addplotline/\n             *         Toggle the plot line from a button\n             */\n            removePlotLine: function(id) {\n                this.removePlotBandOrLine(id);\n            }\n        });\n\n    }(Highcharts, Axis));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var dateFormat = H.dateFormat,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            isNumber = H.isNumber,\n            map = H.map,\n            merge = H.merge,\n            pick = H.pick,\n            splat = H.splat,\n            syncTimeout = H.syncTimeout,\n            timeUnits = H.timeUnits;\n        /**\n         * The tooltip object\n         * @param {Object} chart The chart instance\n         * @param {Object} options Tooltip options\n         */\n        H.Tooltip = function() {\n            this.init.apply(this, arguments);\n        };\n\n        H.Tooltip.prototype = {\n\n            init: function(chart, options) {\n\n                // Save the chart and options\n                this.chart = chart;\n                this.options = options;\n\n                // Keep track of the current series\n                //this.currentSeries = undefined;\n\n                // List of crosshairs\n                this.crosshairs = [];\n\n                // Current values of x and y when animating\n                this.now = {\n                    x: 0,\n                    y: 0\n                };\n\n                // The tooltip is initially hidden\n                this.isHidden = true;\n\n\n\n                // Public property for getting the shared state.\n                this.split = options.split && !chart.inverted;\n                this.shared = options.shared || this.split;\n\n            },\n\n            /**\n             * Destroy the single tooltips in a split tooltip.\n             * If the tooltip is active then it is not destroyed, unless forced to.\n             * @param  {boolean} force Force destroy all tooltips.\n             * @return {undefined}\n             */\n            cleanSplit: function(force) {\n                each(this.chart.series, function(series) {\n                    var tt = series && series.tt;\n                    if (tt) {\n                        if (!tt.isActive || force) {\n                            series.tt = tt.destroy();\n                        } else {\n                            tt.isActive = false;\n                        }\n                    }\n                });\n            },\n\n\n\n\n            /**\n             * Create the Tooltip label element if it doesn't exist, then return the\n             * label.\n             */\n            getLabel: function() {\n\n                var renderer = this.chart.renderer,\n                    options = this.options;\n\n                if (!this.label) {\n                    // Create the label\n                    if (this.split) {\n                        this.label = renderer.g('tooltip');\n                    } else {\n                        this.label = renderer.label(\n                                '',\n                                0,\n                                0,\n                                options.shape || 'callout',\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'tooltip'\n                            )\n                            .attr({\n                                padding: options.padding,\n                                r: options.borderRadius\n                            });\n\n\n                        this.label\n                            .attr({\n                                'fill': options.backgroundColor,\n                                'stroke-width': options.borderWidth\n                            })\n                            // #2301, #2657\n                            .css(options.style)\n                            .shadow(options.shadow);\n\n                    }\n\n\n\n                    this.label\n                        .attr({\n                            zIndex: 8\n                        })\n                        .add();\n                }\n                return this.label;\n            },\n\n            update: function(options) {\n                this.destroy();\n                // Update user options (#6218)\n                merge(true, this.chart.options.tooltip.userOptions, options);\n                this.init(this.chart, merge(true, this.options, options));\n            },\n\n            /**\n             * Destroy the tooltip and its elements.\n             */\n            destroy: function() {\n                // Destroy and clear local variables\n                if (this.label) {\n                    this.label = this.label.destroy();\n                }\n                if (this.split && this.tt) {\n                    this.cleanSplit(this.chart, true);\n                    this.tt = this.tt.destroy();\n                }\n                clearTimeout(this.hideTimer);\n                clearTimeout(this.tooltipTimeout);\n            },\n\n            /**\n             * Provide a soft movement for the tooltip\n             *\n             * @param {Number} x\n             * @param {Number} y\n             * @private\n             */\n            move: function(x, y, anchorX, anchorY) {\n                var tooltip = this,\n                    now = tooltip.now,\n                    animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                    // When we get close to the target position, abort animation and land on the right place (#3056)\n                    (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n                    skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n                // Get intermediate values for animation\n                extend(now, {\n                    x: animate ? (2 * now.x + x) / 3 : x,\n                    y: animate ? (now.y + y) / 2 : y,\n                    anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n                    anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n                });\n\n                // Move to the intermediate value\n                tooltip.getLabel().attr(now);\n\n\n                // Run on next tick of the mouse tracker\n                if (animate) {\n\n                    // Never allow two timeouts\n                    clearTimeout(this.tooltipTimeout);\n\n                    // Set the fixed interval ticking for the smooth tooltip\n                    this.tooltipTimeout = setTimeout(function() {\n                        // The interval function may still be running during destroy,\n                        // so check that the chart is really there before calling.\n                        if (tooltip) {\n                            tooltip.move(x, y, anchorX, anchorY);\n                        }\n                    }, 32);\n\n                }\n            },\n\n            /**\n             * Hide the tooltip\n             */\n            hide: function(delay) {\n                var tooltip = this;\n                clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n                delay = pick(delay, this.options.hideDelay, 500);\n                if (!this.isHidden) {\n                    this.hideTimer = syncTimeout(function() {\n                        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();\n                        tooltip.isHidden = true;\n                    }, delay);\n                }\n            },\n\n            /**\n             * Extendable method to get the anchor position of the tooltip\n             * from a point or set of points\n             */\n            getAnchor: function(points, mouseEvent) {\n                var ret,\n                    chart = this.chart,\n                    inverted = chart.inverted,\n                    plotTop = chart.plotTop,\n                    plotLeft = chart.plotLeft,\n                    plotX = 0,\n                    plotY = 0,\n                    yAxis,\n                    xAxis;\n\n                points = splat(points);\n\n                // Pie uses a special tooltipPos\n                ret = points[0].tooltipPos;\n\n                // When tooltip follows mouse, relate the position to the mouse\n                if (this.followPointer && mouseEvent) {\n                    if (mouseEvent.chartX === undefined) {\n                        mouseEvent = chart.pointer.normalize(mouseEvent);\n                    }\n                    ret = [\n                        mouseEvent.chartX - chart.plotLeft,\n                        mouseEvent.chartY - plotTop\n                    ];\n                }\n                // When shared, use the average position\n                if (!ret) {\n                    each(points, function(point) {\n                        yAxis = point.series.yAxis;\n                        xAxis = point.series.xAxis;\n                        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                            (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n                    });\n\n                    plotX /= points.length;\n                    plotY /= points.length;\n\n                    ret = [\n                        inverted ? chart.plotWidth - plotY : plotX,\n                        this.shared && !inverted && points.length > 1 && mouseEvent ?\n                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                        inverted ? chart.plotHeight - plotX : plotY\n                    ];\n                }\n\n                return map(ret, Math.round);\n            },\n\n            /**\n             * Place the tooltip in a chart without spilling over\n             * and not covering the point it self.\n             */\n            getPosition: function(boxWidth, boxHeight, point) {\n\n                var chart = this.chart,\n                    distance = this.distance,\n                    ret = {},\n                    h = point.h || 0, // #4117\n                    swapped,\n                    first = ['y', chart.chartHeight, boxHeight,\n                        point.plotY + chart.plotTop, chart.plotTop,\n                        chart.plotTop + chart.plotHeight\n                    ],\n                    second = ['x', chart.chartWidth, boxWidth,\n                        point.plotX + chart.plotLeft, chart.plotLeft,\n                        chart.plotLeft + chart.plotWidth\n                    ],\n                    // The far side is right or bottom\n                    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984\n                    /**\n                     * Handle the preferred dimension. When the preferred dimension is tooltip\n                     * on top or bottom of the point, it will look for space there.\n                     */\n                    firstDimension = function(dim, outerSize, innerSize, point, min, max) {\n                        var roomLeft = innerSize < point - distance,\n                            roomRight = point + distance + innerSize < outerSize,\n                            alignedLeft = point - distance - innerSize,\n                            alignedRight = point + distance;\n\n                        if (preferFarSide && roomRight) {\n                            ret[dim] = alignedRight;\n                        } else if (!preferFarSide && roomLeft) {\n                            ret[dim] = alignedLeft;\n                        } else if (roomLeft) {\n                            ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                        } else if (roomRight) {\n                            ret[dim] = Math.max(\n                                min,\n                                alignedRight + h + innerSize > outerSize ?\n                                alignedRight :\n                                alignedRight + h\n                            );\n                        } else {\n                            return false;\n                        }\n                    },\n                    /**\n                     * Handle the secondary dimension. If the preferred dimension is tooltip\n                     * on top or bottom of the point, the second dimension is to align the tooltip\n                     * above the point, trying to align center but allowing left or right\n                     * align within the chart box.\n                     */\n                    secondDimension = function(dim, outerSize, innerSize, point) {\n                        var retVal;\n\n                        // Too close to the edge, return false and swap dimensions\n                        if (point < distance || point > outerSize - distance) {\n                            retVal = false;\n                            // Align left/top\n                        } else if (point < innerSize / 2) {\n                            ret[dim] = 1;\n                            // Align right/bottom\n                        } else if (point > outerSize - innerSize / 2) {\n                            ret[dim] = outerSize - innerSize - 2;\n                            // Align center\n                        } else {\n                            ret[dim] = point - innerSize / 2;\n                        }\n                        return retVal;\n                    },\n                    /**\n                     * Swap the dimensions\n                     */\n                    swap = function(count) {\n                        var temp = first;\n                        first = second;\n                        second = temp;\n                        swapped = count;\n                    },\n                    run = function() {\n                        if (firstDimension.apply(0, first) !== false) {\n                            if (secondDimension.apply(0, second) === false && !swapped) {\n                                swap(true);\n                                run();\n                            }\n                        } else if (!swapped) {\n                            swap(true);\n                            run();\n                        } else {\n                            ret.x = ret.y = 0;\n                        }\n                    };\n\n                // Under these conditions, prefer the tooltip on the side of the point\n                if (chart.inverted || this.len > 1) {\n                    swap();\n                }\n                run();\n\n                return ret;\n\n            },\n\n            /**\n             * In case no user defined formatter is given, this will be used. Note that the context\n             * here is an object holding point, series, x, y etc.\n             *\n             * @returns {String|Array<String>}\n             */\n            defaultFormatter: function(tooltip) {\n                var items = this.points || splat(this),\n                    s;\n\n                // Build the header\n                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n\n                // build the values\n                s = s.concat(tooltip.bodyFormatter(items));\n\n                // footer\n                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n\n                return s;\n            },\n\n            /**\n             * Refresh the tooltip's text and position.\n             * @param {Object|Array} pointOrPoints Rither a point or an array of points\n             */\n            refresh: function(pointOrPoints, mouseEvent) {\n                var tooltip = this,\n                    label,\n                    options = tooltip.options,\n                    x,\n                    y,\n                    point = pointOrPoints,\n                    anchor,\n                    textConfig = {},\n                    text,\n                    pointConfig = [],\n                    formatter = options.formatter || tooltip.defaultFormatter,\n                    shared = tooltip.shared,\n                    currentSeries;\n\n                clearTimeout(this.hideTimer);\n\n                // get the reference point coordinates (pie charts use tooltipPos)\n                tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n                anchor = tooltip.getAnchor(point, mouseEvent);\n                x = anchor[0];\n                y = anchor[1];\n\n                // shared tooltip, array is sent over\n                if (shared && !(point.series && point.series.noSharedTooltip)) {\n                    each(point, function(item) {\n                        item.setState('hover');\n\n                        pointConfig.push(item.getLabelConfig());\n                    });\n\n                    textConfig = {\n                        x: point[0].category,\n                        y: point[0].y\n                    };\n                    textConfig.points = pointConfig;\n                    point = point[0];\n\n                    // single point tooltip\n                } else {\n                    textConfig = point.getLabelConfig();\n                }\n                this.len = pointConfig.length; // #6128\n                text = formatter.call(textConfig, tooltip);\n\n                // register the current series\n                currentSeries = point.series;\n                this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n                // update the inner HTML\n                if (text === false) {\n                    this.hide();\n                } else {\n\n                    label = tooltip.getLabel();\n\n                    // show it\n                    if (tooltip.isHidden) {\n                        label.attr({\n                            opacity: 1\n                        }).show();\n                    }\n\n                    // update text\n                    if (tooltip.split) {\n                        this.renderSplit(text, pointOrPoints);\n                    } else {\n\n                        // Prevent the tooltip from flowing over the chart box (#6659)\n\n                        if (!options.style.width) {\n\n                            label.css({\n                                width: this.chart.spacingBox.width\n                            });\n\n                        }\n\n\n                        label.attr({\n                            text: text && text.join ? text.join('') : text\n                        });\n\n                        // Set the stroke color of the box to reflect the point\n                        label.removeClass(/highcharts-color-[\\d]+/g)\n                            .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));\n\n\n                        label.attr({\n                            stroke: options.borderColor || point.color || currentSeries.color || '#666666'\n                        });\n\n\n                        tooltip.updatePosition({\n                            plotX: x,\n                            plotY: y,\n                            negative: point.negative,\n                            ttBelow: point.ttBelow,\n                            h: anchor[2] || 0\n                        });\n                    }\n\n                    this.isHidden = false;\n                }\n            },\n\n            /**\n             * Render the split tooltip. Loops over each point's text and adds\n             * a label next to the point, then uses the distribute function to \n             * find best non-overlapping positions.\n             */\n            renderSplit: function(labels, points) {\n                var tooltip = this,\n                    boxes = [],\n                    chart = this.chart,\n                    ren = chart.renderer,\n                    rightAligned = true,\n                    options = this.options,\n                    headerHeight,\n                    tooltipLabel = this.getLabel();\n\n                // Create the individual labels for header and points, ignore footer\n                each(labels.slice(0, points.length + 1), function(str, i) {\n                    var point = points[i - 1] ||\n                        // Item 0 is the header. Instead of this, we could also use the crosshair label\n                        {\n                            isHeader: true,\n                            plotX: points[0].plotX\n                        },\n                        owner = point.series || tooltip,\n                        tt = owner.tt,\n                        series = point.series || {},\n                        colorClass = 'highcharts-color-' + pick(point.colorIndex, series.colorIndex, 'none'),\n                        target,\n                        x,\n                        bBox,\n                        boxWidth;\n\n                    // Store the tooltip referance on the series\n                    if (!tt) {\n                        owner.tt = tt = ren.label(null, null, null, 'callout')\n                            .addClass('highcharts-tooltip-box ' + colorClass)\n                            .attr({\n                                'padding': options.padding,\n                                'r': options.borderRadius,\n\n                                'fill': options.backgroundColor,\n                                'stroke': point.color || series.color || '#333333',\n                                'stroke-width': options.borderWidth\n\n                            })\n                            .add(tooltipLabel);\n                    }\n\n                    tt.isActive = true;\n                    tt.attr({\n                        text: str\n                    });\n\n                    tt.css(options.style);\n\n\n                    // Get X position now, so we can move all to the other side in case of overflow\n                    bBox = tt.getBBox();\n                    boxWidth = bBox.width + tt.strokeWidth();\n                    if (point.isHeader) {\n                        headerHeight = bBox.height;\n                        x = Math.max(\n                            0, // No left overflow\n                            Math.min(\n                                point.plotX + chart.plotLeft - boxWidth / 2,\n                                chart.chartWidth - boxWidth // No right overflow (#5794)\n                            )\n                        );\n                    } else {\n                        x = point.plotX + chart.plotLeft - pick(options.distance, 16) -\n                            boxWidth;\n                    }\n\n\n                    // If overflow left, we don't use this x in the next loop\n                    if (x < 0) {\n                        rightAligned = false;\n                    }\n\n                    // Prepare for distribution\n                    target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);\n                    target -= chart.plotTop;\n                    boxes.push({\n                        target: point.isHeader ? chart.plotHeight + headerHeight : target,\n                        rank: point.isHeader ? 1 : 0,\n                        size: owner.tt.getBBox().height + 1,\n                        point: point,\n                        x: x,\n                        tt: tt\n                    });\n                });\n\n                // Clean previous run (for missing points)\n                this.cleanSplit();\n\n                // Distribute and put in place\n                H.distribute(boxes, chart.plotHeight + headerHeight);\n                each(boxes, function(box) {\n                    var point = box.point,\n                        series = point.series;\n\n                    // Put the label in place\n                    box.tt.attr({\n                        visibility: box.pos === undefined ? 'hidden' : 'inherit',\n                        x: (rightAligned || point.isHeader ?\n                            box.x :\n                            point.plotX + chart.plotLeft + pick(options.distance, 16)),\n                        y: box.pos + chart.plotTop,\n                        anchorX: point.isHeader ?\n                            point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,\n                        anchorY: point.isHeader ?\n                            box.pos + chart.plotTop - 15 : point.plotY + series.yAxis.pos\n                    });\n                });\n            },\n\n            /**\n             * Find the new position and perform the move\n             */\n            updatePosition: function(point) {\n                var chart = this.chart,\n                    label = this.getLabel(),\n                    pos = (this.options.positioner || this.getPosition).call(\n                        this,\n                        label.width,\n                        label.height,\n                        point\n                    );\n\n                // do the move\n                this.move(\n                    Math.round(pos.x),\n                    Math.round(pos.y || 0), // can be undefined (#3977) \n                    point.plotX + chart.plotLeft,\n                    point.plotY + chart.plotTop\n                );\n            },\n\n            /**\n             * Get the optimal date format for a point, based on a range.\n             * @param  {number} range - The time range\n             * @param  {number|Date} date - The date of the point in question\n             * @param  {number} startOfWeek - An integer representing the first day of\n             * the week, where 0 is Sunday\n             * @param  {Object} dateTimeLabelFormats - A map of time units to formats\n             * @return {string} - the optimal date format for a point\n             */\n            getDateFormat: function(range, date, startOfWeek, dateTimeLabelFormats) {\n                var dateStr = dateFormat('%m-%d %H:%M:%S.%L', date),\n                    format,\n                    n,\n                    blank = '01-01 00:00:00.000',\n                    strpos = {\n                        millisecond: 15,\n                        second: 12,\n                        minute: 9,\n                        hour: 6,\n                        day: 3\n                    },\n                    lastN = 'millisecond'; // for sub-millisecond data, #4223\n                for (n in timeUnits) {\n\n                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                    if (range === timeUnits.week && +dateFormat('%w', date) === startOfWeek &&\n                        dateStr.substr(6) === blank.substr(6)) {\n                        n = 'week';\n                        break;\n                    }\n\n                    // The first format that is too great for the range\n                    if (timeUnits[n] > range) {\n                        n = lastN;\n                        break;\n                    }\n\n                    // If the point is placed every day at 23:59, we need to show\n                    // the minutes as well. #2637.\n                    if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                        break;\n                    }\n\n                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                    if (n !== 'week') {\n                        lastN = n;\n                    }\n                }\n\n                if (n) {\n                    format = dateTimeLabelFormats[n];\n                }\n\n                return format;\n            },\n\n            /**\n             * Get the best X date format based on the closest point range on the axis.\n             */\n            getXDateFormat: function(point, options, xAxis) {\n                var xDateFormat,\n                    dateTimeLabelFormats = options.dateTimeLabelFormats,\n                    closestPointRange = xAxis && xAxis.closestPointRange;\n\n                if (closestPointRange) {\n                    xDateFormat = this.getDateFormat(\n                        closestPointRange,\n                        point.x,\n                        xAxis.options.startOfWeek,\n                        dateTimeLabelFormats\n                    );\n                } else {\n                    xDateFormat = dateTimeLabelFormats.day;\n                }\n\n                return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n            },\n\n            /**\n             * Format the footer/header of the tooltip\n             * #3397: abstraction to enable formatting of footer and header\n             */\n            tooltipFooterHeaderFormatter: function(labelConfig, isFooter) {\n                var footOrHead = isFooter ? 'footer' : 'header',\n                    series = labelConfig.series,\n                    tooltipOptions = series.tooltipOptions,\n                    xDateFormat = tooltipOptions.xDateFormat,\n                    xAxis = series.xAxis,\n                    isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),\n                    formatString = tooltipOptions[footOrHead + 'Format'];\n\n                // Guess the best date format based on the closest point distance (#568, #3418)\n                if (isDateTime && !xDateFormat) {\n                    xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n                }\n\n                // Insert the footer date format if any\n                if (isDateTime && xDateFormat) {\n                    formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n                }\n\n                return format(formatString, {\n                    point: labelConfig,\n                    series: series\n                });\n            },\n\n            /**\n             * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n             * abstracting this functionality allows to easily overwrite and extend it.\n             */\n            bodyFormatter: function(items) {\n                return map(items, function(item) {\n                    var tooltipOptions = item.series.tooltipOptions;\n                    return (tooltipOptions.pointFormatter || item.point.tooltipFormatter)\n                        .call(item.point, tooltipOptions.pointFormat);\n                });\n            }\n\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            attr = H.attr,\n            charts = H.charts,\n            color = H.color,\n            css = H.css,\n            defined = H.defined,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            offset = H.offset,\n            pick = H.pick,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            Tooltip = H.Tooltip,\n            win = H.win;\n\n        /**\n         * The mouse tracker object. All methods starting with \"on\" are primary DOM\n         * event handlers. Subsequent methods should be named differently from what they\n         * are doing.\n         *\n         * @constructor Pointer\n         * @param {Object} chart The Chart instance\n         * @param {Object} options The root options object\n         */\n        H.Pointer = function(chart, options) {\n            this.init(chart, options);\n        };\n\n        H.Pointer.prototype = {\n            /**\n             * Initialize Pointer\n             */\n            init: function(chart, options) {\n\n                // Store references\n                this.options = options;\n                this.chart = chart;\n\n                // Do we need to handle click on a touch device?\n                this.runChartClick = options.chart.events && !!options.chart.events.click;\n\n                this.pinchDown = [];\n                this.lastValidTouch = {};\n\n                if (Tooltip && options.tooltip.enabled) {\n                    chart.tooltip = new Tooltip(chart, options.tooltip);\n                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n                }\n\n                this.setDOMEvents();\n            },\n\n            /**\n             * Resolve the zoomType option, this is reset on all touch start and mouse\n             * down events.\n             */\n            zoomOption: function(e) {\n                var chart = this.chart,\n                    options = chart.options.chart,\n                    zoomType = options.zoomType || '',\n                    inverted = chart.inverted,\n                    zoomX,\n                    zoomY;\n\n                // Look for the pinchType option\n                if (/touch/.test(e.type)) {\n                    zoomType = pick(options.pinchType, zoomType);\n                }\n\n                this.zoomX = zoomX = /x/.test(zoomType);\n                this.zoomY = zoomY = /y/.test(zoomType);\n                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n                this.hasZoom = zoomX || zoomY;\n            },\n\n            /**\n             * @typedef  {Object} PointerEvent\n             *           A native browser mouse or touch event, extended with position\n             *           information relative to the {@link Chart.container}.\n             * @property {Number} chartX\n             *           The X coordinate of the pointer interaction relative to the\n             *           chart.\n             * @property {Number} chartY\n             *           The Y coordinate of the pointer interaction relative to the \n             *           chart.\n             * \n             */\n            /**\n             * Add crossbrowser support for chartX and chartY.\n             * \n             * @param  {Object} e\n             *         The event object in standard browsers.\n             *\n             * @return {PointerEvent}\n             *         A browser event with extended properties `chartX` and `chartY`\n             */\n            normalize: function(e, chartPosition) {\n                var chartX,\n                    chartY,\n                    ePos;\n\n                // IE normalizing\n                e = e || win.event;\n                if (!e.target) {\n                    e.target = e.srcElement;\n                }\n\n                // iOS (#2757)\n                ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n                // Get mouse position\n                if (!chartPosition) {\n                    this.chartPosition = chartPosition = offset(this.chart.container);\n                }\n\n                // chartX and chartY\n                if (ePos.pageX === undefined) { // IE < 9. #886.\n                    chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n                    // for IE10 quirks mode within framesets\n                    chartY = e.y;\n                } else {\n                    chartX = ePos.pageX - chartPosition.left;\n                    chartY = ePos.pageY - chartPosition.top;\n                }\n\n                return extend(e, {\n                    chartX: Math.round(chartX),\n                    chartY: Math.round(chartY)\n                });\n            },\n\n            /**\n             * Get the click position in terms of axis values.\n             *\n             * @param {Object} e A pointer event\n             */\n            getCoordinates: function(e) {\n                var coordinates = {\n                    xAxis: [],\n                    yAxis: []\n                };\n\n                each(this.chart.axes, function(axis) {\n                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n                    });\n                });\n                return coordinates;\n            },\n            /**\n             * Collects the points closest to a mouseEvent\n             * @param  {Array} series Array of series to gather points from\n             * @param  {Boolean} shared True if shared tooltip, otherwise false\n             * @param  {Object} e Mouse event which possess a position to compare against\n             * @return {Array} KDPoints sorted by distance\n             */\n            getKDPoints: function(series, shared, e) {\n                var kdpoints = [],\n                    noSharedTooltip,\n                    directTouch,\n                    kdpointT,\n                    i;\n\n                // Find nearest points on all series\n                each(series, function(s) {\n                    // Skip hidden series\n                    noSharedTooltip = s.noSharedTooltip && shared;\n                    directTouch = !shared && s.directTouch;\n                    if (s.visible && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                        // #3828\n                        kdpointT = s.searchPoint(\n                            e, !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0\n                        );\n                        if (kdpointT && kdpointT.series) { // Point.series becomes null when reset and before redraw (#5197)\n                            kdpoints.push(kdpointT);\n                        }\n                    }\n                });\n\n                // Sort kdpoints by distance to mouse pointer\n                kdpoints.sort(function(p1, p2) {\n                    var isCloserX = p1.distX - p2.distX,\n                        isCloser = p1.dist - p2.dist,\n                        isAbove =\n                        (p2.series.group && p2.series.group.zIndex) -\n                        (p1.series.group && p1.series.group.zIndex),\n                        result;\n\n                    // We have two points which are not in the same place on xAxis and shared tooltip:\n                    if (isCloserX !== 0 && shared) { // #5721\n                        result = isCloserX;\n                        // Points are not exactly in the same place on x/yAxis:\n                    } else if (isCloser !== 0) {\n                        result = isCloser;\n                        // The same xAxis and yAxis position, sort by z-index:\n                    } else if (isAbove !== 0) {\n                        result = isAbove;\n                        // The same zIndex, sort by array index:\n                    } else {\n                        result = p1.series.index > p2.series.index ? -1 : 1;\n                    }\n                    return result;\n                });\n\n                // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):\n                if (shared && kdpoints[0] && !kdpoints[0].series.noSharedTooltip) {\n                    i = kdpoints.length;\n                    while (i--) {\n                        if (kdpoints[i].x !== kdpoints[0].x || kdpoints[i].series.noSharedTooltip) {\n                            kdpoints.splice(i, 1);\n                        }\n                    }\n                }\n                return kdpoints;\n            },\n            getPointFromEvent: function(e) {\n                var target = e.target,\n                    point;\n\n                while (target && !point) {\n                    point = target.point;\n                    target = target.parentNode;\n                }\n                return point;\n            },\n\n            getChartCoordinatesFromPoint: function(point, inverted) {\n                var series = point.series,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis;\n\n                if (xAxis && yAxis) {\n                    return inverted ? {\n                        chartX: xAxis.len + xAxis.pos - point.clientX,\n                        chartY: yAxis.len + yAxis.pos - point.plotY\n                    } : {\n                        chartX: point.clientX + xAxis.pos,\n                        chartY: point.plotY + yAxis.pos\n                    };\n                }\n            },\n\n            /**\n             * Calculates what is the current hovered point/points and series.\n             *\n             * @private\n             *\n             * @param  {undefined|Point} existingHoverPoint\n             *         The point currrently beeing hovered.\n             * @param  {undefined|Series} existingHoverSeries\n             *         The series currently beeing hovered.\n             * @param  {Array<.Series>} series\n             *         All the series in the chart.\n             * @param  {boolean} isDirectTouch\n             *         Is the pointer directly hovering the point.\n             * @param  {boolean} shared\n             *         Whether it is a shared tooltip or not.\n             * @param  {object} coordinates\n             *         Chart coordinates of the pointer.\n             * @param  {number} coordinates.chartX\n             * @param  {number} coordinates.chartY\n             * \n             * @return {object}\n             *         Object containing resulting hover data.\n             */\n            getHoverData: function(\n                existingHoverPoint,\n                existingHoverSeries,\n                series,\n                isDirectTouch,\n                shared,\n                coordinates\n            ) {\n                var hoverPoint = existingHoverPoint,\n                    hoverSeries = existingHoverSeries,\n                    searchSeries = shared ? series : [hoverSeries],\n                    useExisting = !!(isDirectTouch && existingHoverPoint),\n                    notSticky = hoverSeries && !hoverSeries.stickyTracking,\n                    isHoverPoint = function(point, i) {\n                        return i === 0;\n                    },\n                    hoverPoints;\n\n                // If there is a hoverPoint and its series requires direct touch (like\n                // columns, #3899), or we're on a noSharedTooltip series among shared\n                // tooltip series (#4546), use the existing hoverPoint.\n                if (useExisting) {\n                    isHoverPoint = function(p) {\n                        return p === existingHoverPoint;\n                    };\n                } else if (notSticky) {\n                    isHoverPoint = function(p) {\n                        return p.series === hoverSeries;\n                    };\n                } else {\n                    // Avoid series with stickyTracking false\n                    searchSeries = H.grep(series, function(s) {\n                        return s.stickyTracking;\n                    });\n                }\n                hoverPoints = (useExisting && !shared) ?\n                    // Non-shared tooltips with directTouch don't use the k-d-tree\n                    [existingHoverPoint] :\n                    this.getKDPoints(searchSeries, shared, coordinates);\n                hoverPoint = H.find(hoverPoints, isHoverPoint);\n                hoverSeries = hoverPoint && hoverPoint.series;\n\n                // In this case we could only look for the hoverPoint in series with\n                // stickyTracking, but we should still include all series in the shared\n                // tooltip.\n                if (!useExisting && !notSticky && shared) {\n                    hoverPoints = this.getKDPoints(series, shared, coordinates);\n                }\n                // Keep the order of series in tooltip\n                // Must be done after assigning of hoverPoint\n                hoverPoints.sort(function(p1, p2) {\n                    return p1.series.index - p2.series.index;\n                });\n\n                return {\n                    hoverPoint: hoverPoint,\n                    hoverSeries: hoverSeries,\n                    hoverPoints: hoverPoints\n                };\n            },\n            /**\n             * With line type charts with a single tracker, get the point closest to the mouse.\n             * Run Point.onMouseOver and display tooltip for the point or points.\n             */\n            runPointActions: function(e, p) {\n                var pointer = this,\n                    chart = pointer.chart,\n                    series = chart.series,\n                    tooltip = chart.tooltip,\n                    shared = tooltip ? tooltip.shared : false,\n                    hoverPoint = p || chart.hoverPoint,\n                    hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,\n                    // onMouseOver or already hovering a series with directTouch\n                    isDirectTouch = !!p || (\n                        (hoverSeries && hoverSeries.directTouch) &&\n                        pointer.isDirectTouch\n                    ),\n                    hoverData = this.getHoverData(\n                        hoverPoint,\n                        hoverSeries,\n                        series,\n                        isDirectTouch,\n                        shared,\n                        e\n                    ),\n                    useSharedTooltip,\n                    followPointer,\n                    anchor,\n                    points;\n                // Update variables from hoverData.\n                hoverPoint = hoverData.hoverPoint;\n                hoverSeries = hoverData.hoverSeries;\n                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n                useSharedTooltip = (\n                    shared &&\n                    hoverPoint &&\n                    !hoverPoint.series.noSharedTooltip\n                );\n                points = (useSharedTooltip ?\n                    hoverData.hoverPoints :\n                    (hoverPoint ? [hoverPoint] : [])\n                );\n                // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n                // #3926, #4200\n                if (\n                    hoverPoint &&\n                    // !(hoverSeries && hoverSeries.directTouch) &&\n                    (hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))\n                ) {\n                    each(chart.hoverPoints || [], function(p) {\n                        if (H.inArray(p, points) === -1) {\n                            p.setState();\n                        }\n                    });\n                    // Do mouseover on all points (#3919, #3985, #4410, #5622)\n                    each(points || [], function(p) {\n                        p.setState('hover');\n                    });\n                    // set normal state to previous series\n                    if (chart.hoverSeries !== hoverSeries) {\n                        hoverSeries.onMouseOver();\n                    }\n\n                    // If tracking is on series in stead of on each point, \n                    // fire mouseOver on hover point. // #4448\n                    if (chart.hoverPoint) {\n                        chart.hoverPoint.firePointEvent('mouseOut');\n                    }\n                    hoverPoint.firePointEvent('mouseOver');\n                    chart.hoverPoints = points;\n                    chart.hoverPoint = hoverPoint;\n                    // Draw tooltip if necessary\n                    if (tooltip) {\n                        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n                    }\n                    // Update positions (regardless of kdpoint or hoverPoint)\n                } else if (followPointer && tooltip && !tooltip.isHidden) {\n                    anchor = tooltip.getAnchor([{}], e);\n                    tooltip.updatePosition({\n                        plotX: anchor[0],\n                        plotY: anchor[1]\n                    });\n                }\n\n                // Start the event listener to pick up the tooltip and crosshairs\n                if (!pointer.unDocMouseMove) {\n                    pointer.unDocMouseMove = addEvent(doc, 'mousemove', function(e) {\n                        var chart = charts[H.hoverChartIndex];\n                        if (chart) {\n                            chart.pointer.onDocumentMouseMove(e);\n                        }\n                    });\n                }\n\n                // Issues related to crosshair #4927, #5269 #5066, #5658\n                each(chart.axes, function drawAxisCrosshair(axis) {\n                    var snap = pick(axis.crosshair.snap, true);\n                    if (!snap) {\n                        axis.drawCrosshair(e);\n\n                        // Axis has snapping crosshairs, and one of the hover points belongs\n                        // to axis\n                    } else if (H.find(points, function(p) {\n                            return p.series[axis.coll] === axis;\n                        })) {\n                        axis.drawCrosshair(e, hoverPoint);\n                        // Axis has snapping crosshairs, but no hover point belongs to axis\n                    } else {\n                        axis.hideCrosshair();\n                    }\n                });\n            },\n\n            /**\n             * Reset the tracking by hiding the tooltip, the hover series state and the\n             * hover point\n             *\n             * @param allowMove {Boolean}\n             *        Instead of destroying the tooltip altogether, allow moving it if\n             *        possible\n             */\n            reset: function(allowMove, delay) {\n                var pointer = this,\n                    chart = pointer.chart,\n                    hoverSeries = chart.hoverSeries,\n                    hoverPoint = chart.hoverPoint,\n                    hoverPoints = chart.hoverPoints,\n                    tooltip = chart.tooltip,\n                    tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n                // Check if the points have moved outside the plot area (#1003, #4736, #5101)\n                if (allowMove && tooltipPoints) {\n                    each(splat(tooltipPoints), function(point) {\n                        if (point.series.isCartesian && point.plotX === undefined) {\n                            allowMove = false;\n                        }\n                    });\n                }\n\n                // Just move the tooltip, #349\n                if (allowMove) {\n                    if (tooltip && tooltipPoints) {\n                        tooltip.refresh(tooltipPoints);\n                        if (hoverPoint) { // #2500\n                            hoverPoint.setState(hoverPoint.state, true);\n                            each(chart.axes, function(axis) {\n                                if (axis.crosshair) {\n                                    axis.drawCrosshair(null, hoverPoint);\n                                }\n                            });\n                        }\n                    }\n\n                    // Full reset\n                } else {\n\n                    if (hoverPoint) {\n                        hoverPoint.onMouseOut();\n                    }\n\n                    if (hoverPoints) {\n                        each(hoverPoints, function(point) {\n                            point.setState();\n                        });\n                    }\n\n                    if (hoverSeries) {\n                        hoverSeries.onMouseOut();\n                    }\n\n                    if (tooltip) {\n                        tooltip.hide(delay);\n                    }\n\n                    if (pointer.unDocMouseMove) {\n                        pointer.unDocMouseMove = pointer.unDocMouseMove();\n                    }\n\n                    // Remove crosshairs\n                    each(chart.axes, function(axis) {\n                        axis.hideCrosshair();\n                    });\n\n                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n                }\n            },\n\n            /**\n             * Scale series groups to a certain scale and translation\n             */\n            scaleGroups: function(attribs, clip) {\n\n                var chart = this.chart,\n                    seriesAttribs;\n\n                // Scale each series\n                each(chart.series, function(series) {\n                    seriesAttribs = attribs || series.getPlotBox(); // #1701\n                    if (series.xAxis && series.xAxis.zoomEnabled && series.group) {\n                        series.group.attr(seriesAttribs);\n                        if (series.markerGroup) {\n                            series.markerGroup.attr(seriesAttribs);\n                            series.markerGroup.clip(clip ? chart.clipRect : null);\n                        }\n                        if (series.dataLabelsGroup) {\n                            series.dataLabelsGroup.attr(seriesAttribs);\n                        }\n                    }\n                });\n\n                // Clip\n                chart.clipRect.attr(clip || chart.clipBox);\n            },\n\n            /**\n             * Start a drag operation\n             */\n            dragStart: function(e) {\n                var chart = this.chart;\n\n                // Record the start position\n                chart.mouseIsDown = e.type;\n                chart.cancelClick = false;\n                chart.mouseDownX = this.mouseDownX = e.chartX;\n                chart.mouseDownY = this.mouseDownY = e.chartY;\n            },\n\n            /**\n             * Perform a drag operation in response to a mousemove event while the mouse is down\n             */\n            drag: function(e) {\n\n                var chart = this.chart,\n                    chartOptions = chart.options.chart,\n                    chartX = e.chartX,\n                    chartY = e.chartY,\n                    zoomHor = this.zoomHor,\n                    zoomVert = this.zoomVert,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    clickedInside,\n                    size,\n                    selectionMarker = this.selectionMarker,\n                    mouseDownX = this.mouseDownX,\n                    mouseDownY = this.mouseDownY,\n                    panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n                // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n                // inside the plot area, don't handle the mouse event. #4339.\n                if (selectionMarker && selectionMarker.touch) {\n                    return;\n                }\n\n                // If the mouse is outside the plot area, adjust to cooordinates\n                // inside to prevent the selection marker from going outside\n                if (chartX < plotLeft) {\n                    chartX = plotLeft;\n                } else if (chartX > plotLeft + plotWidth) {\n                    chartX = plotLeft + plotWidth;\n                }\n\n                if (chartY < plotTop) {\n                    chartY = plotTop;\n                } else if (chartY > plotTop + plotHeight) {\n                    chartY = plotTop + plotHeight;\n                }\n\n                // determine if the mouse has moved more than 10px\n                this.hasDragged = Math.sqrt(\n                    Math.pow(mouseDownX - chartX, 2) +\n                    Math.pow(mouseDownY - chartY, 2)\n                );\n\n                if (this.hasDragged > 10) {\n                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n                    // make a selection\n                    if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                        if (!selectionMarker) {\n                            this.selectionMarker = selectionMarker = chart.renderer.rect(\n                                    plotLeft,\n                                    plotTop,\n                                    zoomHor ? 1 : plotWidth,\n                                    zoomVert ? 1 : plotHeight,\n                                    0\n                                )\n                                .attr({\n\n                                    fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),\n\n                                    'class': 'highcharts-selection-marker',\n                                    'zIndex': 7\n                                })\n                                .add();\n                        }\n                    }\n\n                    // adjust the width of the selection marker\n                    if (selectionMarker && zoomHor) {\n                        size = chartX - mouseDownX;\n                        selectionMarker.attr({\n                            width: Math.abs(size),\n                            x: (size > 0 ? 0 : size) + mouseDownX\n                        });\n                    }\n                    // adjust the height of the selection marker\n                    if (selectionMarker && zoomVert) {\n                        size = chartY - mouseDownY;\n                        selectionMarker.attr({\n                            height: Math.abs(size),\n                            y: (size > 0 ? 0 : size) + mouseDownY\n                        });\n                    }\n\n                    // panning\n                    if (clickedInside && !selectionMarker && chartOptions.panning) {\n                        chart.pan(e, chartOptions.panning);\n                    }\n                }\n            },\n\n            /**\n             * On mouse up or touch end across the entire document, drop the selection.\n             */\n            drop: function(e) {\n                var pointer = this,\n                    chart = this.chart,\n                    hasPinched = this.hasPinched;\n\n                if (this.selectionMarker) {\n                    var selectionData = {\n                            originalEvent: e, // #4890\n                            xAxis: [],\n                            yAxis: []\n                        },\n                        selectionBox = this.selectionMarker,\n                        selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                        selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                        selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                        selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                        runZoom;\n\n                    // a selection has been made\n                    if (this.hasDragged || hasPinched) {\n\n                        // record each axis' min and max\n                        each(chart.axes, function(axis) {\n                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{\n                                    xAxis: 'zoomX',\n                                    yAxis: 'zoomY'\n                                }[axis.coll]])) { // #859, #3569\n                                var horiz = axis.horiz,\n                                    minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                                selectionData[axis.coll].push({\n                                    axis: axis,\n                                    min: Math.min(selectionMin, selectionMax), // for reversed axes\n                                    max: Math.max(selectionMin, selectionMax)\n                                });\n                                runZoom = true;\n                            }\n                        });\n                        if (runZoom) {\n                            fireEvent(chart, 'selection', selectionData, function(args) {\n                                chart.zoom(extend(args, hasPinched ? {\n                                    animation: false\n                                } : null));\n                            });\n                        }\n\n                    }\n                    this.selectionMarker = this.selectionMarker.destroy();\n\n                    // Reset scaling preview\n                    if (hasPinched) {\n                        this.scaleGroups();\n                    }\n                }\n\n                // Reset all\n                if (chart) { // it may be destroyed on mouse up - #877\n                    css(chart.container, {\n                        cursor: chart._cursor\n                    });\n                    chart.cancelClick = this.hasDragged > 10; // #370\n                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n                    this.pinchDown = [];\n                }\n            },\n\n            onContainerMouseDown: function(e) {\n\n                e = this.normalize(e);\n\n                this.zoomOption(e);\n\n                // issue #295, dragging not always working in Firefox\n                if (e.preventDefault) {\n                    e.preventDefault();\n                }\n\n                this.dragStart(e);\n            },\n\n\n\n            onDocumentMouseUp: function(e) {\n                if (charts[H.hoverChartIndex]) {\n                    charts[H.hoverChartIndex].pointer.drop(e);\n                }\n            },\n\n            /**\n             * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n             * Issue #149 workaround. The mouseleave event does not always fire.\n             */\n            onDocumentMouseMove: function(e) {\n                var chart = this.chart,\n                    chartPosition = this.chartPosition;\n\n                e = this.normalize(e, chartPosition);\n\n                // If we're outside, hide the tooltip\n                if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                    this.reset();\n                }\n            },\n\n            /**\n             * When mouse leaves the container, hide the tooltip.\n             */\n            onContainerMouseLeave: function(e) {\n                var chart = charts[H.hoverChartIndex];\n                if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target\n                    chart.pointer.reset();\n                    chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n                }\n            },\n\n            // The mousemove, touchmove and touchstart event handler\n            onContainerMouseMove: function(e) {\n\n                var chart = this.chart;\n\n                if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {\n                    H.hoverChartIndex = chart.index;\n                }\n\n                e = this.normalize(e);\n                e.returnValue = false; // #2251, #3224\n\n                if (chart.mouseIsDown === 'mousedown') {\n                    this.drag(e);\n                }\n\n                // Show the tooltip and run mouse over events (#977)\n                if ((this.inClass(e.target, 'highcharts-tracker') ||\n                        chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n                    this.runPointActions(e);\n                }\n            },\n\n            /**\n             * Utility to detect whether an element has, or has a parent with, a specific\n             * class name. Used on detection of tracker objects and on deciding whether\n             * hovering the tooltip should cause the active series to mouse out.\n             */\n            inClass: function(element, className) {\n                var elemClassName;\n                while (element) {\n                    elemClassName = attr(element, 'class');\n                    if (elemClassName) {\n                        if (elemClassName.indexOf(className) !== -1) {\n                            return true;\n                        }\n                        if (elemClassName.indexOf('highcharts-container') !== -1) {\n                            return false;\n                        }\n                    }\n                    element = element.parentNode;\n                }\n            },\n\n            onTrackerMouseOut: function(e) {\n                var series = this.chart.hoverSeries,\n                    relatedTarget = e.relatedTarget || e.toElement;\n                this.isDirectTouch = false;\n                if (series && relatedTarget && !series.stickyTracking &&\n                    !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n                    (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465\n                        !this.inClass(relatedTarget, 'highcharts-tracker') // #5553\n                    )\n                ) {\n                    series.onMouseOut();\n                }\n            },\n\n            onContainerClick: function(e) {\n                var chart = this.chart,\n                    hoverPoint = chart.hoverPoint,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop;\n\n                e = this.normalize(e);\n\n                if (!chart.cancelClick) {\n\n                    // On tracker click, fire the series and point events. #783, #1583\n                    if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n\n                        // the series click event\n                        fireEvent(hoverPoint.series, 'click', extend(e, {\n                            point: hoverPoint\n                        }));\n\n                        // the point click event\n                        if (chart.hoverPoint) { // it may be destroyed (#1844)\n                            hoverPoint.firePointEvent('click', e);\n                        }\n\n                        // When clicking outside a tracker, fire a chart event\n                    } else {\n                        extend(e, this.getCoordinates(e));\n\n                        // fire a click event in the chart\n                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                            fireEvent(chart, 'click', e);\n                        }\n                    }\n\n\n                }\n            },\n\n            /**\n             * Set the JS DOM events on the container and document. This method should contain\n             * a one-to-one assignment between methods and their handlers. Any advanced logic should\n             * be moved to the handler reflecting the event's name.\n             */\n            setDOMEvents: function() {\n\n                var pointer = this,\n                    container = pointer.chart.container;\n\n                container.onmousedown = function(e) {\n                    pointer.onContainerMouseDown(e);\n                };\n                container.onmousemove = function(e) {\n                    pointer.onContainerMouseMove(e);\n                };\n                container.onclick = function(e) {\n                    pointer.onContainerClick(e);\n                };\n                addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n                if (H.chartCount === 1) {\n                    addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n                }\n                if (H.hasTouch) {\n                    container.ontouchstart = function(e) {\n                        pointer.onContainerTouchStart(e);\n                    };\n                    container.ontouchmove = function(e) {\n                        pointer.onContainerTouchMove(e);\n                    };\n                    if (H.chartCount === 1) {\n                        addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                    }\n                }\n\n            },\n\n            /**\n             * Destroys the Pointer object and disconnects DOM events.\n             */\n            destroy: function() {\n                var pointer = this;\n\n                if (pointer.unDocMouseMove) {\n                    pointer.unDocMouseMove();\n                }\n\n                removeEvent(\n                    pointer.chart.container,\n                    'mouseleave',\n                    pointer.onContainerMouseLeave\n                );\n                if (!H.chartCount) {\n                    removeEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n                    removeEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                }\n\n                // memory and CPU leak\n                clearInterval(pointer.tooltipTimeout);\n\n                H.objectEach(pointer, function(val, prop) {\n                    pointer[prop] = null;\n                });\n            }\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var charts = H.charts,\n            each = H.each,\n            extend = H.extend,\n            map = H.map,\n            noop = H.noop,\n            pick = H.pick,\n            Pointer = H.Pointer;\n\n        /* Support for touch devices */\n        extend(Pointer.prototype, /** @lends Pointer.prototype */ {\n\n            /**\n             * Run translation operations\n             */\n            pinchTranslate: function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n                if (this.zoomHor) {\n                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n                }\n                if (this.zoomVert) {\n                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n                }\n            },\n\n            /**\n             * Run translation operations for each direction (horizontal and vertical) independently\n             */\n            pinchTranslateDirection: function(horiz, pinchDown, touches, transform,\n                selectionMarker, clip, lastValidTouch, forcedScale) {\n                var chart = this.chart,\n                    xy = horiz ? 'x' : 'y',\n                    XY = horiz ? 'X' : 'Y',\n                    sChartXY = 'chart' + XY,\n                    wh = horiz ? 'width' : 'height',\n                    plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n                    selectionWH,\n                    selectionXY,\n                    clipXY,\n                    scale = forcedScale || 1,\n                    inverted = chart.inverted,\n                    bounds = chart.bounds[horiz ? 'h' : 'v'],\n                    singleTouch = pinchDown.length === 1,\n                    touch0Start = pinchDown[0][sChartXY],\n                    touch0Now = touches[0][sChartXY],\n                    touch1Start = !singleTouch && pinchDown[1][sChartXY],\n                    touch1Now = !singleTouch && touches[1][sChartXY],\n                    outOfBounds,\n                    transformScale,\n                    scaleKey,\n                    setScale = function() {\n                        // Don't zoom if fingers are too close on this axis\n                        if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {\n                            scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);\n                        }\n\n                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n                    };\n\n                // Set the scale, first pass\n                setScale();\n\n                selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n                // Out of bounds\n                if (selectionXY < bounds.min) {\n                    selectionXY = bounds.min;\n                    outOfBounds = true;\n                } else if (selectionXY + selectionWH > bounds.max) {\n                    selectionXY = bounds.max - selectionWH;\n                    outOfBounds = true;\n                }\n\n                // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n                if (outOfBounds) {\n\n                    // Modify the touchNow position in order to create an elastic drag movement. This indicates\n                    // to the user that the chart is responsive but can't be dragged further.\n                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n                    if (!singleTouch) {\n                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n                    }\n\n                    // Set the scale, second pass to adapt to the modified touchNow positions\n                    setScale();\n\n                } else {\n                    lastValidTouch[xy] = [touch0Now, touch1Now];\n                }\n\n                // Set geometry for clipping, selection and transformation\n                if (!inverted) {\n                    clip[xy] = clipXY - plotLeftTop;\n                    clip[wh] = selectionWH;\n                }\n                scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n                transformScale = inverted ? 1 / scale : scale;\n\n                selectionMarker[wh] = selectionWH;\n                selectionMarker[xy] = selectionXY;\n                transform[scaleKey] = scale;\n                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n            },\n\n            /**\n             * Handle touch events with two touches\n             */\n            pinch: function(e) {\n\n                var self = this,\n                    chart = self.chart,\n                    pinchDown = self.pinchDown,\n                    touches = e.touches,\n                    touchesLength = touches.length,\n                    lastValidTouch = self.lastValidTouch,\n                    hasZoom = self.hasZoom,\n                    selectionMarker = self.selectionMarker,\n                    transform = {},\n                    fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&\n                        chart.runTrackerClick) || self.runChartClick),\n                    clip = {};\n\n                // Don't initiate panning until the user has pinched. This prevents us from\n                // blocking page scrolling as users scroll down a long page (#4210).\n                if (touchesLength > 1) {\n                    self.initiated = true;\n                }\n\n                // On touch devices, only proceed to trigger click if a handler is defined\n                if (hasZoom && self.initiated && !fireClickEvent) {\n                    e.preventDefault();\n                }\n\n                // Normalize each touch\n                map(touches, function(e) {\n                    return self.normalize(e);\n                });\n\n                // Register the touch start position\n                if (e.type === 'touchstart') {\n                    each(touches, function(e, i) {\n                        pinchDown[i] = {\n                            chartX: e.chartX,\n                            chartY: e.chartY\n                        };\n                    });\n                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n                    // Identify the data bounds in pixels\n                    each(chart.axes, function(axis) {\n                        if (axis.zoomEnabled) {\n                            var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                                minPixelPadding = axis.minPixelPadding,\n                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                                absMin = Math.min(min, max),\n                                absMax = Math.max(min, max);\n\n                            // Store the bounds for use in the touchmove handler\n                            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n                        }\n                    });\n                    self.res = true; // reset on next move\n\n                    // Optionally move the tooltip on touchmove\n                } else if (self.followTouchMove && touchesLength === 1) {\n                    this.runPointActions(self.normalize(e));\n\n                    // Event type is touchmove, handle panning and pinching\n                } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n                    // Set the marker\n                    if (!selectionMarker) {\n                        self.selectionMarker = selectionMarker = extend({\n                            destroy: noop,\n                            touch: true\n                        }, chart.plotBox);\n                    }\n\n                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n                    self.hasPinched = hasZoom;\n\n                    // Scale and translate the groups to provide visual feedback during pinching\n                    self.scaleGroups(transform, clip);\n\n                    if (self.res) {\n                        self.res = false;\n                        this.reset(false, 0);\n                    }\n                }\n            },\n\n            /**\n             * General touch handler shared by touchstart and touchmove.\n             */\n            touch: function(e, start) {\n                var chart = this.chart,\n                    hasMoved,\n                    pinchDown,\n                    isInside;\n\n                if (chart.index !== H.hoverChartIndex) {\n                    this.onContainerMouseLeave({\n                        relatedTarget: true\n                    });\n                }\n                H.hoverChartIndex = chart.index;\n\n                if (e.touches.length === 1) {\n\n                    e = this.normalize(e);\n\n                    isInside = chart.isInsidePlot(\n                        e.chartX - chart.plotLeft,\n                        e.chartY - chart.plotTop\n                    );\n                    if (isInside && !chart.openMenu) {\n\n                        // Run mouse events and display tooltip etc\n                        if (start) {\n                            this.runPointActions(e);\n                        }\n\n                        // Android fires touchmove events after the touchstart even if the\n                        // finger hasn't moved, or moved only a pixel or two. In iOS however,\n                        // the touchmove doesn't fire unless the finger moves more than ~4px.\n                        // So we emulate this behaviour in Android by checking how much it\n                        // moved, and cancelling on small distances. #3450.\n                        if (e.type === 'touchmove') {\n                            pinchDown = this.pinchDown;\n                            hasMoved = pinchDown[0] ? Math.sqrt( // #5266\n                                Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                                Math.pow(pinchDown[0].chartY - e.chartY, 2)\n                            ) >= 4 : false;\n                        }\n\n                        if (pick(hasMoved, true)) {\n                            this.pinch(e);\n                        }\n\n                    } else if (start) {\n                        // Hide the tooltip on touching outside the plot area (#1203)\n                        this.reset();\n                    }\n\n                } else if (e.touches.length === 2) {\n                    this.pinch(e);\n                }\n            },\n\n            onContainerTouchStart: function(e) {\n                this.zoomOption(e);\n                this.touch(e, true);\n            },\n\n            onContainerTouchMove: function(e) {\n                this.touch(e);\n            },\n\n            onDocumentTouchEnd: function(e) {\n                if (charts[H.hoverChartIndex]) {\n                    charts[H.hoverChartIndex].pointer.drop(e);\n                }\n            }\n\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            charts = H.charts,\n            css = H.css,\n            doc = H.doc,\n            extend = H.extend,\n            hasTouch = H.hasTouch,\n            noop = H.noop,\n            Pointer = H.Pointer,\n            removeEvent = H.removeEvent,\n            win = H.win,\n            wrap = H.wrap;\n\n        if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {\n\n            // The touches object keeps track of the points being touched at all times\n            var touches = {},\n                hasPointerEvent = !!win.PointerEvent,\n                getWebkitTouches = function() {\n                    var fake = [];\n                    fake.item = function(i) {\n                        return this[i];\n                    };\n                    H.objectEach(touches, function(touch) {\n                        fake.push({\n                            pageX: touch.pageX,\n                            pageY: touch.pageY,\n                            target: touch.target\n                        });\n                    });\n                    return fake;\n                },\n                translateMSPointer = function(e, method, wktype, func) {\n                    var p;\n                    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {\n                        func(e);\n                        p = charts[H.hoverChartIndex].pointer;\n                        p[method]({\n                            type: wktype,\n                            target: e.currentTarget,\n                            preventDefault: noop,\n                            touches: getWebkitTouches()\n                        });\n                    }\n                };\n\n            /**\n             * Extend the Pointer prototype with methods for each event handler and more\n             */\n            extend(Pointer.prototype, /** @lends Pointer.prototype */ {\n                onContainerPointerDown: function(e) {\n                    translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function(e) {\n                        touches[e.pointerId] = {\n                            pageX: e.pageX,\n                            pageY: e.pageY,\n                            target: e.currentTarget\n                        };\n                    });\n                },\n                onContainerPointerMove: function(e) {\n                    translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function(e) {\n                        touches[e.pointerId] = {\n                            pageX: e.pageX,\n                            pageY: e.pageY\n                        };\n                        if (!touches[e.pointerId].target) {\n                            touches[e.pointerId].target = e.currentTarget;\n                        }\n                    });\n                },\n                onDocumentPointerUp: function(e) {\n                    translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function(e) {\n                        delete touches[e.pointerId];\n                    });\n                },\n\n                /**\n                 * Add or remove the MS Pointer specific events\n                 */\n                batchMSEvents: function(fn) {\n                    fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n                    fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n                    fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n                }\n            });\n\n            // Disable default IE actions for pinch and such on chart element\n            wrap(Pointer.prototype, 'init', function(proceed, chart, options) {\n                proceed.call(this, chart, options);\n                if (this.hasZoom) { // #4014\n                    css(chart.container, {\n                        '-ms-touch-action': 'none',\n                        'touch-action': 'none'\n                    });\n                }\n            });\n\n            // Add IE specific touch events to chart\n            wrap(Pointer.prototype, 'setDOMEvents', function(proceed) {\n                proceed.apply(this);\n                if (this.hasZoom || this.followTouchMove) {\n                    this.batchMSEvents(addEvent);\n                }\n            });\n            // Destroy MS events also\n            wrap(Pointer.prototype, 'destroy', function(proceed) {\n                this.batchMSEvents(removeEvent);\n                proceed.call(this);\n            });\n        }\n\n    }(Highcharts));\n    (function(Highcharts) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var H = Highcharts,\n\n            addEvent = H.addEvent,\n            css = H.css,\n            discardElement = H.discardElement,\n            defined = H.defined,\n            each = H.each,\n            isFirefox = H.isFirefox,\n            marginNames = H.marginNames,\n            merge = H.merge,\n            pick = H.pick,\n            setAnimation = H.setAnimation,\n            stableSort = H.stableSort,\n            win = H.win,\n            wrap = H.wrap;\n\n        /**\n         * The overview of the chart's series. The legend object is instanciated\n         * internally in the chart constructor, and available from `chart.legend`. Each\n         * chart has only one legend.\n         * \n         * @class\n         */\n        Highcharts.Legend = function(chart, options) {\n            this.init(chart, options);\n        };\n\n        Highcharts.Legend.prototype = {\n\n            /**\n             * Initialize the legend\n             */\n            init: function(chart, options) {\n\n                this.chart = chart;\n\n                this.setOptions(options);\n\n                if (options.enabled) {\n\n                    // Render it\n                    this.render();\n\n                    // move checkboxes\n                    addEvent(this.chart, 'endResize', function() {\n                        this.legend.positionCheckboxes();\n                    });\n                }\n            },\n\n            setOptions: function(options) {\n\n                var padding = pick(options.padding, 8);\n\n                this.options = options;\n\n\n                this.itemStyle = options.itemStyle;\n                this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);\n\n                this.itemMarginTop = options.itemMarginTop || 0;\n                this.padding = padding;\n                this.initialItemY = padding - 5; // 5 is pixels above the text\n                this.maxItemWidth = 0;\n                this.itemHeight = 0;\n                this.symbolWidth = pick(options.symbolWidth, 16);\n                this.pages = [];\n\n            },\n\n            /**\n             * Update the legend with new options. Equivalent to running `chart.update`\n             * with a legend configuration option.\n             * @param  {LegendOptions} options\n             *         Legend options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart.\n             *\n             * @sample highcharts/legend/legend-update/\n             *         Legend update\n             */\n            update: function(options, redraw) {\n                var chart = this.chart;\n\n                this.setOptions(merge(true, this.options, options));\n                this.destroy();\n                chart.isDirtyLegend = chart.isDirtyBox = true;\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Set the colors for the legend item\n             * @param {Object} item A Series or Point instance\n             * @param {Object} visible Dimmed or colored\n             */\n            colorizeItem: function(item, visible) {\n                item.legendGroup[visible ? 'removeClass' : 'addClass'](\n                    'highcharts-legend-item-hidden'\n                );\n\n\n                var legend = this,\n                    options = legend.options,\n                    legendItem = item.legendItem,\n                    legendLine = item.legendLine,\n                    legendSymbol = item.legendSymbol,\n                    hiddenColor = legend.itemHiddenStyle.color,\n                    textColor = visible ? options.itemStyle.color : hiddenColor,\n                    symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,\n                    markerOptions = item.options && item.options.marker,\n                    symbolAttr = {\n                        fill: symbolColor\n                    };\n\n                if (legendItem) {\n                    legendItem.css({\n                        fill: textColor,\n                        color: textColor // #1553, oldIE\n                    });\n                }\n                if (legendLine) {\n                    legendLine.attr({\n                        stroke: symbolColor\n                    });\n                }\n\n                if (legendSymbol) {\n\n                    // Apply marker options\n                    if (markerOptions && legendSymbol.isMarker) { // #585\n                        //symbolAttr.stroke = symbolColor;\n                        symbolAttr = item.pointAttribs();\n                        if (!visible) {\n                            H.objectEach(symbolAttr, function(val, key) {\n                                symbolAttr[key] = hiddenColor;\n                            });\n                        }\n                    }\n\n                    legendSymbol.attr(symbolAttr);\n                }\n\n            },\n\n            /**\n             * Position the legend item\n             * @param {Object} item A Series or Point instance\n             */\n            positionItem: function(item) {\n                var legend = this,\n                    options = legend.options,\n                    symbolPadding = options.symbolPadding,\n                    ltr = !options.rtl,\n                    legendItemPos = item._legendItemPos,\n                    itemX = legendItemPos[0],\n                    itemY = legendItemPos[1],\n                    checkbox = item.checkbox,\n                    legendGroup = item.legendGroup;\n\n                if (legendGroup && legendGroup.element) {\n                    legendGroup.translate(\n                        ltr ?\n                        itemX :\n                        legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                        itemY\n                    );\n                }\n\n                if (checkbox) {\n                    checkbox.x = itemX;\n                    checkbox.y = itemY;\n                }\n            },\n\n            /**\n             * Destroy a single legend item\n             * @param {Object} item The series or point\n             */\n            destroyItem: function(item) {\n                var checkbox = item.checkbox;\n\n                // destroy SVG elements\n                each(\n                    ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],\n                    function(key) {\n                        if (item[key]) {\n                            item[key] = item[key].destroy();\n                        }\n                    }\n                );\n\n                if (checkbox) {\n                    discardElement(item.checkbox);\n                }\n            },\n\n            /**\n             * Destroys the legend.\n             */\n            destroy: function() {\n                function destroyItems(key) {\n                    if (this[key]) {\n                        this[key] = this[key].destroy();\n                    }\n                }\n\n                // Destroy items\n                each(this.getAllItems(), function(item) {\n                    each(['legendItem', 'legendGroup'], destroyItems, item);\n                });\n\n                // Destroy legend elements\n                each([\n                    'clipRect',\n                    'up',\n                    'down',\n                    'pager',\n                    'nav',\n                    'box',\n                    'title',\n                    'group'\n                ], destroyItems, this);\n                this.display = null; // Reset in .render on update.\n            },\n\n            /**\n             * Position the checkboxes after the width is determined\n             */\n            positionCheckboxes: function(scrollOffset) {\n                var alignAttr = this.group && this.group.alignAttr,\n                    translateY,\n                    clipHeight = this.clipHeight || this.legendHeight,\n                    titleHeight = this.titleHeight;\n\n                if (alignAttr) {\n                    translateY = alignAttr.translateY;\n                    each(this.allItems, function(item) {\n                        var checkbox = item.checkbox,\n                            top;\n\n                        if (checkbox) {\n                            top = translateY + titleHeight + checkbox.y +\n                                (scrollOffset || 0) + 3;\n                            css(checkbox, {\n                                left: (alignAttr.translateX + item.checkboxOffset +\n                                    checkbox.x - 20) + 'px',\n                                top: top + 'px',\n                                display: top > translateY - 6 && top < translateY +\n                                    clipHeight - 6 ? '' : 'none'\n                            });\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Render the legend title on top of the legend\n             */\n            renderTitle: function() {\n                var options = this.options,\n                    padding = this.padding,\n                    titleOptions = options.title,\n                    titleHeight = 0,\n                    bBox;\n\n                if (titleOptions.text) {\n                    if (!this.title) {\n                        this.title = this.chart.renderer.label(\n                                titleOptions.text,\n                                padding - 3,\n                                padding - 4,\n                                null,\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'legend-title'\n                            )\n                            .attr({\n                                zIndex: 1\n                            })\n\n                            .css(titleOptions.style)\n\n                            .add(this.group);\n                    }\n                    bBox = this.title.getBBox();\n                    titleHeight = bBox.height;\n                    this.offsetWidth = bBox.width; // #1717\n                    this.contentGroup.attr({\n                        translateY: titleHeight\n                    });\n                }\n                this.titleHeight = titleHeight;\n            },\n\n            /**\n             * Set the legend item text\n             */\n            setText: function(item) {\n                var options = this.options;\n                item.legendItem.attr({\n                    text: options.labelFormat ?\n                        H.format(options.labelFormat, item) : options.labelFormatter.call(item)\n                });\n            },\n\n            /**\n             * Render a single specific legend item\n             * @param {Object} item A series or point\n             */\n            renderItem: function(item) {\n                var legend = this,\n                    chart = legend.chart,\n                    renderer = chart.renderer,\n                    options = legend.options,\n                    horizontal = options.layout === 'horizontal',\n                    symbolWidth = legend.symbolWidth,\n                    symbolPadding = options.symbolPadding,\n\n                    itemStyle = legend.itemStyle,\n                    itemHiddenStyle = legend.itemHiddenStyle,\n\n                    padding = legend.padding,\n                    itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n                    ltr = !options.rtl,\n                    itemHeight,\n                    widthOption = options.width,\n                    itemMarginBottom = options.itemMarginBottom || 0,\n                    itemMarginTop = legend.itemMarginTop,\n                    bBox,\n                    itemWidth,\n                    li = item.legendItem,\n                    isSeries = !item.series,\n                    series = !isSeries && item.series.drawLegendSymbol ?\n                    item.series :\n                    item,\n                    seriesOptions = series.options,\n                    showCheckbox = legend.createCheckboxForItem &&\n                    seriesOptions &&\n                    seriesOptions.showCheckbox,\n                    // full width minus text width\n                    itemExtraWidth = symbolWidth + symbolPadding + itemDistance +\n                    (showCheckbox ? 20 : 0),\n                    useHTML = options.useHTML,\n                    fontSize = 12,\n                    itemClassName = item.options.className;\n\n                if (!li) { // generate it once, later move it\n\n                    // Generate the group box, a group to hold the symbol and text. Text\n                    // is to be appended in Legend class.\n                    item.legendGroup = renderer.g('legend-item')\n                        .addClass(\n                            'highcharts-' + series.type + '-series ' +\n                            'highcharts-color-' + item.colorIndex +\n                            (itemClassName ? ' ' + itemClassName : '') +\n                            (isSeries ? ' highcharts-series-' + item.index : '')\n                        )\n                        .attr({\n                            zIndex: 1\n                        })\n                        .add(legend.scrollGroup);\n\n                    // Generate the list item text and add it to the group\n                    item.legendItem = li = renderer.text(\n                            '',\n                            ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                            legend.baseline || 0,\n                            useHTML\n                        )\n\n                        // merge to prevent modifying original (#1021)\n                        .css(merge(item.visible ? itemStyle : itemHiddenStyle))\n\n                        .attr({\n                            align: ltr ? 'left' : 'right',\n                            zIndex: 2\n                        })\n                        .add(item.legendGroup);\n\n                    // Get the baseline for the first item - the font size is equal for\n                    // all\n                    if (!legend.baseline) {\n\n                        fontSize = itemStyle.fontSize;\n\n                        legend.fontMetrics = renderer.fontMetrics(\n                            fontSize,\n                            li\n                        );\n                        legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                        li.attr('y', legend.baseline);\n                    }\n\n                    // Draw the legend symbol inside the group box\n                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;\n                    series.drawLegendSymbol(legend, item);\n\n                    if (legend.setItemEvents) {\n                        legend.setItemEvents(item, li, useHTML);\n                    }\n\n                    // add the HTML checkbox on top\n                    if (showCheckbox) {\n                        legend.createCheckboxForItem(item);\n                    }\n                }\n\n                // Colorize the items\n                legend.colorizeItem(item, item.visible);\n\n                // Take care of max width and text overflow (#6659)\n\n                if (!itemStyle.width) {\n\n                    li.css({\n                        width: (options.itemWidth || chart.spacingBox.width) -\n                            itemExtraWidth\n                    });\n\n                }\n\n\n                // Always update the text\n                legend.setText(item);\n\n                // calculate the positions for the next line\n                bBox = li.getBBox();\n\n                itemWidth = item.checkboxOffset =\n                    options.itemWidth ||\n                    item.legendItemWidth ||\n                    bBox.width + itemExtraWidth;\n                legend.itemHeight = itemHeight = Math.round(\n                    item.legendItemHeight || bBox.height || legend.symbolHeight\n                );\n\n                // If the item exceeds the width, start a new line\n                if (\n                    horizontal &&\n                    legend.itemX - padding + itemWidth > (\n                        widthOption || (\n                            chart.spacingBox.width - 2 * padding - options.x\n                        )\n                    )\n                ) {\n                    legend.itemX = padding;\n                    legend.itemY += itemMarginTop + legend.lastLineHeight +\n                        itemMarginBottom;\n                    legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n                }\n\n                // If the item exceeds the height, start a new column\n                /*if (!horizontal && legend.itemY + options.y +\n                \t\titemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n                \tlegend.itemY = legend.initialItemY;\n                \tlegend.itemX += legend.maxItemWidth;\n                \tlegend.maxItemWidth = 0;\n                }*/\n\n                // Set the edge positions\n                legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);\n                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n                legend.lastLineHeight = Math.max( // #915\n                    itemHeight,\n                    legend.lastLineHeight\n                );\n\n                // cache the position of the newly generated or reordered items\n                item._legendItemPos = [legend.itemX, legend.itemY];\n\n                // advance\n                if (horizontal) {\n                    legend.itemX += itemWidth;\n\n                } else {\n                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n                    legend.lastLineHeight = itemHeight;\n                }\n\n                // the width of the widest item\n                legend.offsetWidth = widthOption || Math.max(\n                    (horizontal ? legend.itemX - padding - itemDistance : itemWidth) +\n                    padding,\n                    legend.offsetWidth\n                );\n            },\n\n            /**\n             * Get all items, which is one item per series for normal series and one\n             * item per point for pie series.\n             */\n            getAllItems: function() {\n                var allItems = [];\n                each(this.chart.series, function(series) {\n                    var seriesOptions = series && series.options;\n\n                    // Handle showInLegend. If the series is linked to another series,\n                    // defaults to false.\n                    if (series && pick(\n                            seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true\n                        )) {\n\n                        // Use points or series for the legend item depending on\n                        // legendType\n                        allItems = allItems.concat(\n                            series.legendItems ||\n                            (\n                                seriesOptions.legendType === 'point' ?\n                                series.data :\n                                series\n                            )\n                        );\n                    }\n                });\n                return allItems;\n            },\n\n            /**\n             * Adjust the chart margins by reserving space for the legend on only one\n             * side of the chart. If the position is set to a corner, top or bottom is\n             * reserved for horizontal legends and left or right for vertical ones.\n             */\n            adjustMargins: function(margin, spacing) {\n                var chart = this.chart,\n                    options = this.options,\n                    // Use the first letter of each alignment option in order to detect\n                    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n                    alignment = options.align.charAt(0) +\n                    options.verticalAlign.charAt(0) +\n                    options.layout.charAt(0);\n\n                if (!options.floating) {\n\n                    each([\n                        /(lth|ct|rth)/,\n                        /(rtv|rm|rbv)/,\n                        /(rbh|cb|lbh)/,\n                        /(lbv|lm|ltv)/\n                    ], function(alignments, side) {\n                        if (alignments.test(alignment) && !defined(margin[side])) {\n                            // Now we have detected on which side of the chart we should\n                            // reserve space for the legend\n                            chart[marginNames[side]] = Math.max(\n                                chart[marginNames[side]],\n                                (\n                                    chart.legend[\n                                        (side + 1) % 2 ? 'legendHeight' : 'legendWidth'\n                                    ] + [1, -1, -1, 1][side] * options[\n                                        (side % 2) ? 'x' : 'y'\n                                    ] +\n                                    pick(options.margin, 12) +\n                                    spacing[side]\n                                )\n                            );\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Render the legend. This method can be called both before and after\n             * chart.render. If called after, it will only rearrange items instead\n             * of creating new ones.\n             */\n            render: function() {\n                var legend = this,\n                    chart = legend.chart,\n                    renderer = chart.renderer,\n                    legendGroup = legend.group,\n                    allItems,\n                    display,\n                    legendWidth,\n                    legendHeight,\n                    box = legend.box,\n                    options = legend.options,\n                    padding = legend.padding;\n\n                legend.itemX = padding;\n                legend.itemY = legend.initialItemY;\n                legend.offsetWidth = 0;\n                legend.lastItemY = 0;\n\n                if (!legendGroup) {\n                    legend.group = legendGroup = renderer.g('legend')\n                        .attr({\n                            zIndex: 7\n                        })\n                        .add();\n                    legend.contentGroup = renderer.g()\n                        .attr({\n                            zIndex: 1\n                        }) // above background\n                        .add(legendGroup);\n                    legend.scrollGroup = renderer.g()\n                        .add(legend.contentGroup);\n                }\n\n                legend.renderTitle();\n\n                // add each series or point\n                allItems = legend.getAllItems();\n\n                // sort by legendIndex\n                stableSort(allItems, function(a, b) {\n                    return ((a.options && a.options.legendIndex) || 0) -\n                        ((b.options && b.options.legendIndex) || 0);\n                });\n\n                // reversed legend\n                if (options.reversed) {\n                    allItems.reverse();\n                }\n\n                legend.allItems = allItems;\n                legend.display = display = !!allItems.length;\n\n                // render the items\n                legend.lastLineHeight = 0;\n                each(allItems, function(item) {\n                    legend.renderItem(item);\n                });\n\n                // Get the box\n                legendWidth = (options.width || legend.offsetWidth) + padding;\n                legendHeight = legend.lastItemY + legend.lastLineHeight +\n                    legend.titleHeight;\n                legendHeight = legend.handleOverflow(legendHeight);\n                legendHeight += padding;\n\n                // Draw the border and/or background\n                if (!box) {\n                    legend.box = box = renderer.rect()\n                        .addClass('highcharts-legend-box')\n                        .attr({\n                            r: options.borderRadius\n                        })\n                        .add(legendGroup);\n                    box.isNew = true;\n                }\n\n\n                // Presentational\n                box\n                    .attr({\n                        stroke: options.borderColor,\n                        'stroke-width': options.borderWidth || 0,\n                        fill: options.backgroundColor || 'none'\n                    })\n                    .shadow(options.shadow);\n\n\n                if (legendWidth > 0 && legendHeight > 0) {\n                    box[box.isNew ? 'attr' : 'animate'](\n                        box.crisp({\n                            x: 0,\n                            y: 0,\n                            width: legendWidth,\n                            height: legendHeight\n                        }, box.strokeWidth())\n                    );\n                    box.isNew = false;\n                }\n\n                // hide the border if no items\n                box[display ? 'show' : 'hide']();\n\n\n\n                legend.legendWidth = legendWidth;\n                legend.legendHeight = legendHeight;\n\n                // Now that the legend width and height are established, put the items\n                // in the final position\n                each(allItems, function(item) {\n                    legend.positionItem(item);\n                });\n\n                // 1.x compatibility: positioning based on style\n                /*var props = ['left', 'right', 'top', 'bottom'],\n                \tprop,\n                \ti = 4;\n                while (i--) {\n                \tprop = props[i];\n                \tif (options.style[prop] && options.style[prop] !== 'auto') {\n                \t\toptions[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                \t\toptions[i < 2 ? 'x' : 'y'] = \n                \t\t\tpInt(options.style[prop]) * (i % 2 ? -1 : 1);\n                \t}\n                }*/\n\n                if (display) {\n                    legendGroup.align(merge(options, {\n                        width: legendWidth,\n                        height: legendHeight\n                    }), true, 'spacingBox');\n                }\n\n                if (!chart.isResizing) {\n                    this.positionCheckboxes();\n                }\n            },\n\n            /**\n             * Set up the overflow handling by adding navigation with up and down arrows\n             * below the legend.\n             */\n            handleOverflow: function(legendHeight) {\n                var legend = this,\n                    chart = this.chart,\n                    renderer = chart.renderer,\n                    options = this.options,\n                    optionsY = options.y,\n                    alignTop = options.verticalAlign === 'top',\n                    padding = this.padding,\n                    spaceHeight = chart.spacingBox.height +\n                    (alignTop ? -optionsY : optionsY) - padding,\n                    maxHeight = options.maxHeight,\n                    clipHeight,\n                    clipRect = this.clipRect,\n                    navOptions = options.navigation,\n                    animation = pick(navOptions.animation, true),\n                    arrowSize = navOptions.arrowSize || 12,\n                    nav = this.nav,\n                    pages = this.pages,\n                    lastY,\n                    allItems = this.allItems,\n                    clipToHeight = function(height) {\n                        if (typeof height === 'number') {\n                            clipRect.attr({\n                                height: height\n                            });\n                        } else if (clipRect) { // Reset (#5912)\n                            legend.clipRect = clipRect.destroy();\n                            legend.contentGroup.clip();\n                        }\n\n                        // useHTML\n                        if (legend.contentGroup.div) {\n                            legend.contentGroup.div.style.clip = height ?\n                                'rect(' + padding + 'px,9999px,' +\n                                (padding + height) + 'px,0)' :\n                                'auto';\n                        }\n                    };\n\n\n                // Adjust the height\n                if (\n                    options.layout === 'horizontal' &&\n                    options.verticalAlign !== 'middle' &&\n                    !options.floating\n                ) {\n                    spaceHeight /= 2;\n                }\n                if (maxHeight) {\n                    spaceHeight = Math.min(spaceHeight, maxHeight);\n                }\n\n                // Reset the legend height and adjust the clipping rectangle\n                pages.length = 0;\n                if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n\n                    this.clipHeight = clipHeight =\n                        Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n                    this.currentPage = pick(this.currentPage, 1);\n                    this.fullHeight = legendHeight;\n\n                    // Fill pages with Y positions so that the top of each a legend item\n                    // defines the scroll top for each page (#2098)\n                    each(allItems, function(item, i) {\n                        var y = item._legendItemPos[1],\n                            h = Math.round(item.legendItem.getBBox().height),\n                            len = pages.length;\n\n                        if (!len || (y - pages[len - 1] > clipHeight &&\n                                (lastY || y) !== pages[len - 1])) {\n                            pages.push(lastY || y);\n                            len++;\n                        }\n\n                        if (i === allItems.length - 1 &&\n                            y + h - pages[len - 1] > clipHeight) {\n                            pages.push(y);\n                        }\n                        if (y !== lastY) {\n                            lastY = y;\n                        }\n                    });\n\n                    // Only apply clipping if needed. Clipping causes blurred legend in\n                    // PDF export (#1787)\n                    if (!clipRect) {\n                        clipRect = legend.clipRect =\n                            renderer.clipRect(0, padding, 9999, 0);\n                        legend.contentGroup.clip(clipRect);\n                    }\n\n                    clipToHeight(clipHeight);\n\n                    // Add navigation elements\n                    if (!nav) {\n                        this.nav = nav = renderer.g()\n                            .attr({\n                                zIndex: 1\n                            })\n                            .add(this.group);\n\n                        this.up = renderer\n                            .symbol(\n                                'triangle',\n                                0,\n                                0,\n                                arrowSize,\n                                arrowSize\n                            )\n                            .on('click', function() {\n                                legend.scroll(-1, animation);\n                            })\n                            .add(nav);\n\n                        this.pager = renderer.text('', 15, 10)\n                            .addClass('highcharts-legend-navigation')\n\n                            .css(navOptions.style)\n\n                            .add(nav);\n\n                        this.down = renderer\n                            .symbol(\n                                'triangle-down',\n                                0,\n                                0,\n                                arrowSize,\n                                arrowSize\n                            )\n                            .on('click', function() {\n                                legend.scroll(1, animation);\n                            })\n                            .add(nav);\n                    }\n\n                    // Set initial position\n                    legend.scroll(0);\n\n                    legendHeight = spaceHeight;\n\n                    // Reset\n                } else if (nav) {\n                    clipToHeight();\n                    this.nav = nav.destroy(); // #6322\n                    this.scrollGroup.attr({\n                        translateY: 1\n                    });\n                    this.clipHeight = 0; // #1379\n                }\n\n                return legendHeight;\n            },\n\n            /**\n             * Scroll the legend by a number of pages\n             * @param {Object} scrollBy\n             * @param {Object} animation\n             */\n            scroll: function(scrollBy, animation) {\n                var pages = this.pages,\n                    pageCount = pages.length,\n                    currentPage = this.currentPage + scrollBy,\n                    clipHeight = this.clipHeight,\n                    navOptions = this.options.navigation,\n                    pager = this.pager,\n                    padding = this.padding,\n                    scrollOffset;\n\n                // When resizing while looking at the last page\n                if (currentPage > pageCount) {\n                    currentPage = pageCount;\n                }\n\n                if (currentPage > 0) {\n\n                    if (animation !== undefined) {\n                        setAnimation(animation, this.chart);\n                    }\n\n                    this.nav.attr({\n                        translateX: padding,\n                        translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                        visibility: 'visible'\n                    });\n                    this.up.attr({\n                        'class': currentPage === 1 ?\n                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                    });\n                    pager.attr({\n                        text: currentPage + '/' + pageCount\n                    });\n                    this.down.attr({\n                        'x': 18 + this.pager.getBBox().width, // adjust to text width\n                        'class': currentPage === pageCount ?\n                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                    });\n\n\n                    this.up\n                        .attr({\n                            fill: currentPage === 1 ?\n                                navOptions.inactiveColor : navOptions.activeColor\n                        })\n                        .css({\n                            cursor: currentPage === 1 ? 'default' : 'pointer'\n                        });\n                    this.down\n                        .attr({\n                            fill: currentPage === pageCount ?\n                                navOptions.inactiveColor : navOptions.activeColor\n                        })\n                        .css({\n                            cursor: currentPage === pageCount ? 'default' : 'pointer'\n                        });\n\n\n                    scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n                    this.scrollGroup.animate({\n                        translateY: scrollOffset\n                    });\n\n                    this.currentPage = currentPage;\n                    this.positionCheckboxes(scrollOffset);\n                }\n\n            }\n\n        };\n\n        /*\n         * LegendSymbolMixin\n         */\n\n        H.LegendSymbolMixin = {\n\n            /**\n             * Get the series' symbol in the legend\n             *\n             * @param {Object} legend The legend object\n             * @param {Object} item The series (this) or point\n             */\n            drawRectangle: function(legend, item) {\n                var options = legend.options,\n                    symbolHeight = legend.symbolHeight,\n                    square = options.squareSymbol,\n                    symbolWidth = square ? symbolHeight : legend.symbolWidth;\n\n                item.legendSymbol = this.chart.renderer.rect(\n                        square ? (legend.symbolWidth - symbolHeight) / 2 : 0,\n                        legend.baseline - symbolHeight + 1, // #3988\n                        symbolWidth,\n                        symbolHeight,\n                        pick(legend.options.symbolRadius, symbolHeight / 2)\n                    )\n                    .addClass('highcharts-point')\n                    .attr({\n                        zIndex: 3\n                    }).add(item.legendGroup);\n\n            },\n\n            /**\n             * Get the series' symbol in the legend. This method should be overridable\n             * to create custom symbols through\n             * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n             *\n             * @param {Object} legend The legend object\n             */\n            drawLineMarker: function(legend) {\n\n                var options = this.options,\n                    markerOptions = options.marker,\n                    radius,\n                    legendSymbol,\n                    symbolWidth = legend.symbolWidth,\n                    symbolHeight = legend.symbolHeight,\n                    generalRadius = symbolHeight / 2,\n                    renderer = this.chart.renderer,\n                    legendItemGroup = this.legendGroup,\n                    verticalCenter = legend.baseline -\n                    Math.round(legend.fontMetrics.b * 0.3),\n                    attr = {};\n\n                // Draw the line\n\n                attr = {\n                    'stroke-width': options.lineWidth || 0\n                };\n                if (options.dashStyle) {\n                    attr.dashstyle = options.dashStyle;\n                }\n\n\n                this.legendLine = renderer.path([\n                        'M',\n                        0,\n                        verticalCenter,\n                        'L',\n                        symbolWidth,\n                        verticalCenter\n                    ])\n                    .addClass('highcharts-graph')\n                    .attr(attr)\n                    .add(legendItemGroup);\n\n                // Draw the marker\n                if (markerOptions && markerOptions.enabled !== false) {\n\n                    // Do not allow the marker to be larger than the symbolHeight\n                    radius = Math.min(\n                        pick(markerOptions.radius, generalRadius),\n                        generalRadius\n                    );\n\n                    // Restrict symbol markers size\n                    if (this.symbol.indexOf('url') === 0) {\n                        markerOptions = merge(markerOptions, {\n                            width: symbolHeight,\n                            height: symbolHeight\n                        });\n                        radius = 0;\n                    }\n\n                    this.legendSymbol = legendSymbol = renderer.symbol(\n                            this.symbol,\n                            (symbolWidth / 2) - radius,\n                            verticalCenter - radius,\n                            2 * radius,\n                            2 * radius,\n                            markerOptions\n                        )\n                        .addClass('highcharts-point')\n                        .add(legendItemGroup);\n                    legendSymbol.isMarker = true;\n                }\n            }\n        };\n\n        // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n        // and for #2580, a similar drawing flaw in Firefox 26.\n        // Explore if there's a general cause for this. The problem may be related\n        // to nested group elements, as the legend item texts are within 4 group\n        // elements.\n        if (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n            wrap(Highcharts.Legend.prototype, 'positionItem', function(proceed, item) {\n                var legend = this,\n                    // If chart destroyed in sync, this is undefined (#2030)\n                    runPositionItem = function() {\n                        if (item._legendItemPos) {\n                            proceed.call(legend, item);\n                        }\n                    };\n\n                // Do it now, for export and to get checkbox placement\n                runPositionItem();\n\n                // Do it after to work around the core issue\n                setTimeout(runPositionItem);\n            });\n        }\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            animObject = H.animObject,\n            attr = H.attr,\n            doc = H.doc,\n            Axis = H.Axis, // @todo add as requirement\n            createElement = H.createElement,\n            defaultOptions = H.defaultOptions,\n            discardElement = H.discardElement,\n            charts = H.charts,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            find = H.find,\n            fireEvent = H.fireEvent,\n            getStyle = H.getStyle,\n            grep = H.grep,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            isString = H.isString,\n            Legend = H.Legend, // @todo add as requirement\n            marginNames = H.marginNames,\n            merge = H.merge,\n            objectEach = H.objectEach,\n            Pointer = H.Pointer, // @todo add as requirement\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            seriesTypes = H.seriesTypes,\n            splat = H.splat,\n            svg = H.svg,\n            syncTimeout = H.syncTimeout,\n            win = H.win,\n            Renderer = H.Renderer;\n        /**\n         * The Chart class. The recommended constructor is {@link Highcharts#chart}.\n         * @class Highcharts.Chart\n         * @param  {String|HTMLDOMElement} renderTo\n         *         The DOM element to render to, or its id.\n         * @param  {Options} options\n         *         The chart options structure.\n         * @param  {Function} [callback]\n         *         Function to run when the chart has loaded and and all external images\n         *         are loaded. Defining a {@link\n         *         https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n         *         handler is equivalent.\n         *\n         * @example\n         * var chart = new Highcharts.Chart('container', {\n         * \t   title: {\n         * \t   \t   text: 'My chart'\n         * \t   },\n         * \t   series: [{\n         * \t       data: [1, 3, 2, 4]\n         * \t   }]\n         * })\n         */\n        var Chart = H.Chart = function() {\n            this.getArgs.apply(this, arguments);\n        };\n\n        /**\n         * Factory function for basic charts. \n         *\n         * @function #chart\n         * @memberOf Highcharts\n         * @param  {String|HTMLDOMElement} renderTo - The DOM element to render to, or\n         * its id.\n         * @param  {Options} options - The chart options structure.\n         * @param  {Function} [callback] - Function to run when the chart has loaded and\n         * and all external images are loaded. Defining a {@link\n         * https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n         * handler is equivalent.\n         * @return {Highcharts.Chart} - Returns the Chart object.\n         *\n         * @example\n         * // Render a chart in to div#container\n         * var chart = Highcharts.chart('container', {\n         *     title: {\n         *         text: 'My chart'\n         *     },\n         *     series: [{\n         *         data: [1, 3, 2, 4]\n         *     }]\n         * });\n         */\n        H.chart = function(a, b, c) {\n            return new Chart(a, b, c);\n        };\n\n        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n            /**\n             * Hook for modules\n             */\n            callbacks: [],\n\n            /**\n             * Handle the arguments passed to the constructor\n             * @returns {Array} Arguments without renderTo\n             */\n            getArgs: function() {\n                var args = [].slice.call(arguments);\n\n                // Remove the optional first argument, renderTo, and\n                // set it on this.\n                if (isString(args[0]) || args[0].nodeName) {\n                    this.renderTo = args.shift();\n                }\n                this.init(args[0], args[1]);\n            },\n\n            /**\n             * Initialize the chart\n             */\n            init: function(userOptions, callback) {\n\n                // Handle regular options\n                var options,\n                    type,\n                    seriesOptions = userOptions.series, // skip merging data points to increase performance\n                    userPlotOptions = userOptions.plotOptions || {};\n\n                userOptions.series = null;\n                options = merge(defaultOptions, userOptions); // do the merge\n\n                // Override (by copy of user options) or clear tooltip options\n                // in chart.options.plotOptions (#6218)\n                for (type in options.plotOptions) {\n                    options.plotOptions[type].tooltip = (\n                        userPlotOptions[type] &&\n                        merge(userPlotOptions[type].tooltip) // override by copy\n                    ) || undefined; // or clear\n                }\n                // User options have higher priority than default options (#6218).\n                // In case of exporting: path is changed\n                options.tooltip.userOptions = (userOptions.chart &&\n                        userOptions.chart.forExport && userOptions.tooltip.userOptions) ||\n                    userOptions.tooltip;\n\n                options.series = userOptions.series = seriesOptions; // set back the series data\n                this.userOptions = userOptions;\n\n                var optionsChart = options.chart;\n\n                var chartEvents = optionsChart.events;\n\n                this.margin = [];\n                this.spacing = [];\n\n                //this.runChartClick = chartEvents && !!chartEvents.click;\n                this.bounds = {\n                    h: {},\n                    v: {}\n                }; // Pixel data bounds for touch zoom\n\n                this.callback = callback;\n                this.isResizing = 0;\n\n                /**\n                 * The options structure for the chart. It contains members for the sub\n                 * elements like series, legend, tooltip etc.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name options\n                 * @type {Options}\n                 */\n                this.options = options;\n                /**\n                 * All the axes in the chart.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name axes\n                 * @see  Highcharts.Chart.xAxis\n                 * @see  Highcharts.Chart.yAxis\n                 * @type {Array.<Highcharts.Axis>}\n                 */\n                this.axes = [];\n\n                /**\n                 * All the current series in the chart.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name series\n                 * @type {Array.<Highcharts.Series>}\n                 */\n                this.series = [];\n\n                /**\n                 * The chart title. The title has an `update` method that allows\n                 * modifying the options directly or indirectly via `chart.update`.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name title\n                 * @type Object\n                 *\n                 * @sample highcharts/members/title-update/\n                 *         Updating titles\n                 */\n\n                /**\n                 * The chart subtitle. The subtitle has an `update` method that allows\n                 * modifying the options directly or indirectly via `chart.update`.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name subtitle\n                 * @type Object\n                 */\n\n\n\n                this.hasCartesianSeries = optionsChart.showAxes;\n                //this.axisOffset = undefined;\n                //this.inverted = undefined;\n                //this.loadingShown = undefined;\n                //this.container = undefined;\n                //this.chartWidth = undefined;\n                //this.chartHeight = undefined;\n                //this.marginRight = undefined;\n                //this.marginBottom = undefined;\n                //this.containerWidth = undefined;\n                //this.containerHeight = undefined;\n                //this.oldChartWidth = undefined;\n                //this.oldChartHeight = undefined;\n\n                //this.renderTo = undefined;\n\n                //this.spacingBox = undefined\n\n                //this.legend = undefined;\n\n                // Elements\n                //this.chartBackground = undefined;\n                //this.plotBackground = undefined;\n                //this.plotBGImage = undefined;\n                //this.plotBorder = undefined;\n                //this.loadingDiv = undefined;\n                //this.loadingSpan = undefined;\n\n                var chart = this;\n\n                // Add the chart to the global lookup\n                chart.index = charts.length;\n\n                charts.push(chart);\n                H.chartCount++;\n\n                // Chart event handlers\n                if (chartEvents) {\n                    objectEach(chartEvents, function(event, eventType) {\n                        addEvent(chart, eventType, event);\n                    });\n                }\n\n                /**\n                 * A collection of the X axes in the chart.\n                 * @type {Array.<Highcharts.Axis>}\n                 * @name xAxis\n                 * @memberOf Highcharts.Chart\n                 */\n                chart.xAxis = [];\n                /**\n                 * A collection of the Y axes in the chart.\n                 * @type {Array.<Highcharts.Axis>}\n                 * @name yAxis\n                 * @memberOf Highcharts.Chart\n                 */\n                chart.yAxis = [];\n\n                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n                chart.firstRender();\n            },\n\n            /**\n             * Initialize an individual series, called internally before render time\n             */\n            initSeries: function(options) {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n                    series,\n                    Constr = seriesTypes[type];\n\n                // No such series type\n                if (!Constr) {\n                    H.error(17, true);\n                }\n\n                series = new Constr();\n                series.init(this, options);\n                return series;\n            },\n\n            /**\n             * Order all series above a given index. When series are added and ordered\n             * by configuration, only the last series is handled (#248, #1123, #2456,\n             * #6112). This function is called on series initialization and destroy.\n             *\n             * @param {number} fromIndex - If this is given, only the series above this\n             *\t index are handled.\n             */\n            orderSeries: function(fromIndex) {\n                var series = this.series,\n                    i = fromIndex || 0;\n                for (; i < series.length; i++) {\n                    if (series[i]) {\n                        series[i].index = i;\n                        series[i].name = series[i].name ||\n                            'Series ' + (series[i].index + 1);\n                    }\n                }\n            },\n\n            /**\n             * Check whether a given point is within the plot area\n             *\n             * @param {Number} plotX Pixel x relative to the plot area\n             * @param {Number} plotY Pixel y relative to the plot area\n             * @param {Boolean} inverted Whether the chart is inverted\n             */\n            isInsidePlot: function(plotX, plotY, inverted) {\n                var x = inverted ? plotY : plotX,\n                    y = inverted ? plotX : plotY;\n\n                return x >= 0 &&\n                    x <= this.plotWidth &&\n                    y >= 0 &&\n                    y <= this.plotHeight;\n            },\n\n            /**\n             * Redraw the chart after changes have been done to the data, axis extremes\n             * chart size or chart elements. All methods for updating axes, series or\n             * points have a parameter for redrawing the chart. This is `true` by\n             * default. But in many cases you want to do more than one operation on the\n             * chart before redrawing, for example add a number of points. In those\n             * cases it is a waste of resources to redraw the chart for each new point\n             * added. So you add the points and call `chart.redraw()` after.\n             *\n             * @param  {AnimationOptions} animation\n             *         If or how to apply animation to the redraw.\n             */\n            redraw: function(animation) {\n                var chart = this,\n                    axes = chart.axes,\n                    series = chart.series,\n                    pointer = chart.pointer,\n                    legend = chart.legend,\n                    redrawLegend = chart.isDirtyLegend,\n                    hasStackedSeries,\n                    hasDirtyStacks,\n                    hasCartesianSeries = chart.hasCartesianSeries,\n                    isDirtyBox = chart.isDirtyBox,\n                    i,\n                    serie,\n                    renderer = chart.renderer,\n                    isHiddenChart = renderer.isHidden(),\n                    afterRedraw = [];\n\n                // Handle responsive rules, not only on resize (#6130)\n                if (chart.setResponsive) {\n                    chart.setResponsive(false);\n                }\n\n                H.setAnimation(animation, chart);\n\n                if (isHiddenChart) {\n                    chart.temporaryDisplay();\n                }\n\n                // Adjust title layout (reflow multiline text)\n                chart.layOutTitles();\n\n                // link stacked series\n                i = series.length;\n                while (i--) {\n                    serie = series[i];\n\n                    if (serie.options.stacking) {\n                        hasStackedSeries = true;\n\n                        if (serie.isDirty) {\n                            hasDirtyStacks = true;\n                            break;\n                        }\n                    }\n                }\n                if (hasDirtyStacks) { // mark others as dirty\n                    i = series.length;\n                    while (i--) {\n                        serie = series[i];\n                        if (serie.options.stacking) {\n                            serie.isDirty = true;\n                        }\n                    }\n                }\n\n                // Handle updated data in the series\n                each(series, function(serie) {\n                    if (serie.isDirty) {\n                        if (serie.options.legendType === 'point') {\n                            if (serie.updateTotals) {\n                                serie.updateTotals();\n                            }\n                            redrawLegend = true;\n                        }\n                    }\n                    if (serie.isDirtyData) {\n                        fireEvent(serie, 'updatedData');\n                    }\n                });\n\n                // handle added or removed series\n                if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n                    // draw legend graphics\n                    legend.render();\n\n                    chart.isDirtyLegend = false;\n                }\n\n                // reset stacks\n                if (hasStackedSeries) {\n                    chart.getStacks();\n                }\n\n\n                if (hasCartesianSeries) {\n                    // set axes scales\n                    each(axes, function(axis) {\n                        axis.updateNames();\n                        axis.setScale();\n                    });\n                }\n\n                chart.getMargins(); // #3098\n\n                if (hasCartesianSeries) {\n                    // If one axis is dirty, all axes must be redrawn (#792, #2169)\n                    each(axes, function(axis) {\n                        if (axis.isDirty) {\n                            isDirtyBox = true;\n                        }\n                    });\n\n                    // redraw axes\n                    each(axes, function(axis) {\n\n                        // Fire 'afterSetExtremes' only if extremes are set\n                        var key = axis.min + ',' + axis.max;\n                        if (axis.extKey !== key) { // #821, #4452\n                            axis.extKey = key;\n                            afterRedraw.push(function() { // prevent a recursive call to chart.redraw() (#1119)\n                                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                                delete axis.eventArgs;\n                            });\n                        }\n                        if (isDirtyBox || hasStackedSeries) {\n                            axis.redraw();\n                        }\n                    });\n                }\n\n                // the plot areas size has changed\n                if (isDirtyBox) {\n                    chart.drawChartBox();\n                }\n\n                // Fire an event before redrawing series, used by the boost module to\n                // clear previous series renderings.\n                fireEvent(chart, 'predraw');\n\n                // redraw affected series\n                each(series, function(serie) {\n                    if ((isDirtyBox || serie.isDirty) && serie.visible) {\n                        serie.redraw();\n                    }\n                    // Set it here, otherwise we will have unlimited 'updatedData' calls\n                    // for a hidden series after setData(). Fixes #6012\n                    serie.isDirtyData = false;\n                });\n\n                // move tooltip or reset\n                if (pointer) {\n                    pointer.reset(true);\n                }\n\n                // redraw if canvas\n                renderer.draw();\n\n                // Fire the events\n                fireEvent(chart, 'redraw');\n                fireEvent(chart, 'render');\n\n                if (isHiddenChart) {\n                    chart.temporaryDisplay(true);\n                }\n\n                // Fire callbacks that are put on hold until after the redraw\n                each(afterRedraw, function(callback) {\n                    callback.call();\n                });\n            },\n\n            /**\n             * Get an axis, series or point object by `id` as given in the configuration\n             * options. Returns `undefined` if no item is found.\n             * @param id {String} The id as given in the configuration options.\n             * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}\n             *         The retrieved item.\n             * @sample highcharts/plotoptions/series-id/\n             *         Get series by id\n             */\n            get: function(id) {\n\n                var ret,\n                    series = this.series,\n                    i;\n\n                function itemById(item) {\n                    return item.id === id || (item.options && item.options.id === id);\n                }\n\n                ret =\n                    // Search axes\n                    find(this.axes, itemById) ||\n\n                    // Search series\n                    find(this.series, itemById);\n\n                // Search points\n                for (i = 0; !ret && i < series.length; i++) {\n                    ret = find(series[i].points || [], itemById);\n                }\n\n                return ret;\n            },\n\n            /**\n             * Create the Axis instances based on the config options\n             */\n            getAxes: function() {\n                var chart = this,\n                    options = this.options,\n                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n                    optionsArray;\n\n                // make sure the options are arrays and add some members\n                each(xAxisOptions, function(axis, i) {\n                    axis.index = i;\n                    axis.isX = true;\n                });\n\n                each(yAxisOptions, function(axis, i) {\n                    axis.index = i;\n                });\n\n                // concatenate all axis options into one array\n                optionsArray = xAxisOptions.concat(yAxisOptions);\n\n                each(optionsArray, function(axisOptions) {\n                    new Axis(chart, axisOptions); // eslint-disable-line no-new\n                });\n            },\n\n\n            /**\n             * Returns an array of all currently selected points in the chart. Points\n             * can be selected by clicking or programmatically by the {@link\n             * Highcharts.Point#select} function.\n             *\n             * @return {Array.<Highcharts.Point>}\n             *         The currently selected points.\n             *\n             * @sample highcharts/plotoptions/series-allowpointselect-line/\n             *         Get selected points\n             */\n            getSelectedPoints: function() {\n                var points = [];\n                each(this.series, function(serie) {\n                    // series.data - for points outside of viewed range (#6445)\n                    points = points.concat(grep(serie.data || [], function(point) {\n                        return point.selected;\n                    }));\n                });\n                return points;\n            },\n\n            /**\n             * Returns an array of all currently selected series in the chart. Series\n             * can be selected either programmatically by the {@link\n             * Highcharts.Series#select} function or by checking the checkbox next to\n             * the legend item if {@link\n             * https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox|\n             * series.showCheckBox} is true.\n             * \n             * @return {Array.<Highcharts.Series>}\n             *         The currently selected series.\n             *\n             * @sample highcharts/members/chart-getselectedseries/\n             *         Get selected series\n             */\n            getSelectedSeries: function() {\n                return grep(this.series, function(serie) {\n                    return serie.selected;\n                });\n            },\n\n            /**\n             * Set a new title or subtitle for the chart.\n             *\n             * @param  titleOptions {TitleOptions}\n             *         New title options.\n             * @param  subtitleOptions {SubtitleOptions}\n             *         New subtitle options.\n             * @param  redraw {Boolean}\n             *         Whether to redraw the chart or wait for a later call to \n             *         `chart.redraw()`.\n             *\n             * @sample highcharts/members/chart-settitle/ Set title text and styles\n             *\n             */\n            setTitle: function(titleOptions, subtitleOptions, redraw) {\n                var chart = this,\n                    options = chart.options,\n                    chartTitleOptions,\n                    chartSubtitleOptions;\n\n                chartTitleOptions = options.title = merge(\n\n                    // Default styles\n                    {\n                        style: {\n                            color: '#333333',\n                            fontSize: options.isStock ? '16px' : '18px' // #2944\n                        }\n                    },\n\n                    options.title,\n                    titleOptions\n                );\n                chartSubtitleOptions = options.subtitle = merge(\n\n                    // Default styles\n                    {\n                        style: {\n                            color: '#666666'\n                        }\n                    },\n\n                    options.subtitle,\n                    subtitleOptions\n                );\n\n                // add title and subtitle\n                each([\n                    ['title', titleOptions, chartTitleOptions],\n                    ['subtitle', subtitleOptions, chartSubtitleOptions]\n                ], function(arr, i) {\n                    var name = arr[0],\n                        title = chart[name],\n                        titleOptions = arr[1],\n                        chartTitleOptions = arr[2];\n\n                    if (title && titleOptions) {\n                        chart[name] = title = title.destroy(); // remove old\n                    }\n\n                    if (chartTitleOptions && chartTitleOptions.text && !title) {\n                        chart[name] = chart.renderer.text(\n                                chartTitleOptions.text,\n                                0,\n                                0,\n                                chartTitleOptions.useHTML\n                            )\n                            .attr({\n                                align: chartTitleOptions.align,\n                                'class': 'highcharts-' + name,\n                                zIndex: chartTitleOptions.zIndex || 4\n                            })\n                            .add();\n\n                        // Update methods, shortcut to Chart.setTitle\n                        chart[name].update = function(o) {\n                            chart.setTitle(!i && o, i && o);\n                        };\n\n\n                        // Presentational\n                        chart[name].css(chartTitleOptions.style);\n\n\n                    }\n                });\n                chart.layOutTitles(redraw);\n            },\n\n            /**\n             * Lay out the chart titles and cache the full offset height for use\n             * in getMargins\n             */\n            layOutTitles: function(redraw) {\n                var titleOffset = 0,\n                    requiresDirtyBox,\n                    renderer = this.renderer,\n                    spacingBox = this.spacingBox;\n\n                // Lay out the title and the subtitle respectively\n                each(['title', 'subtitle'], function(key) {\n                    var title = this[key],\n                        titleOptions = this.options[key],\n                        offset = key === 'title' ? -3 :\n                        // Floating subtitle (#6574)\n                        titleOptions.verticalAlign ? 0 : titleOffset + 2,\n                        titleSize;\n\n                    if (title) {\n\n                        titleSize = titleOptions.style.fontSize;\n\n                        titleSize = renderer.fontMetrics(titleSize, title).b;\n\n                        title\n                            .css({\n                                width: (titleOptions.width ||\n                                    spacingBox.width + titleOptions.widthAdjust) + 'px'\n                            })\n                            .align(extend({\n                                y: offset + titleSize\n                            }, titleOptions), false, 'spacingBox');\n\n                        if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                            titleOffset = Math.ceil(\n                                titleOffset +\n                                // Skip the cache for HTML (#3481)\n                                title.getBBox(titleOptions.useHTML).height\n                            );\n                        }\n                    }\n                }, this);\n\n                requiresDirtyBox = this.titleOffset !== titleOffset;\n                this.titleOffset = titleOffset; // used in getMargins\n\n                if (!this.isDirtyBox && requiresDirtyBox) {\n                    this.isDirtyBox = requiresDirtyBox;\n                    // Redraw if necessary (#2719, #2744)\n                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                        this.redraw();\n                    }\n                }\n            },\n\n            /**\n             * Get chart width and height according to options and container size\n             */\n            getChartSize: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    widthOption = optionsChart.width,\n                    heightOption = optionsChart.height,\n                    renderTo = chart.renderTo;\n\n                // Get inner width and height\n                if (!defined(widthOption)) {\n                    chart.containerWidth = getStyle(renderTo, 'width');\n                }\n                if (!defined(heightOption)) {\n                    chart.containerHeight = getStyle(renderTo, 'height');\n                }\n\n                chart.chartWidth = Math.max( // #1393\n                    0,\n                    widthOption || chart.containerWidth || 600 // #1460\n                );\n                chart.chartHeight = Math.max(\n                    0,\n                    H.relativeLength(\n                        heightOption,\n                        chart.chartWidth\n                    ) || chart.containerHeight || 400\n                );\n            },\n\n            /**\n             * If the renderTo element has no offsetWidth, most likely one or more of\n             * its parents are hidden. Loop up the DOM tree to temporarily display the\n             * parents, then save the original display properties, and when the true\n             * size is retrieved, reset them. Used on first render and on redraws.\n             *\n             * @param {Boolean} revert - Revert to the saved original styles.\n             */\n            temporaryDisplay: function(revert) {\n                var node = this.renderTo,\n                    tempStyle;\n                if (!revert) {\n                    while (node && node.style) {\n                        if (getStyle(node, 'display', false) === 'none') {\n                            node.hcOrigStyle = {\n                                display: node.style.display,\n                                height: node.style.height,\n                                overflow: node.style.overflow\n                            };\n                            tempStyle = {\n                                display: 'block',\n                                overflow: 'hidden'\n                            };\n                            if (node !== this.renderTo) {\n                                tempStyle.height = 0;\n                            }\n\n                            H.css(node, tempStyle);\n                            if (node.style.setProperty) { // #2631\n                                node.style.setProperty('display', 'block', 'important');\n                            }\n                        }\n                        node = node.parentNode;\n                    }\n                } else {\n                    while (node && node.style) {\n                        if (node.hcOrigStyle) {\n                            H.css(node, node.hcOrigStyle);\n                            delete node.hcOrigStyle;\n                        }\n                        node = node.parentNode;\n                    }\n                }\n            },\n\n            /**\n             * Setter for the chart class name\n             */\n            setClassName: function(className) {\n                this.container.className = 'highcharts-container ' + (className || '');\n            },\n\n            /**\n             * Get the containing element, determine the size and create the inner\n             * container div to hold the chart\n             */\n            getContainer: function() {\n                var chart = this,\n                    container,\n                    options = chart.options,\n                    optionsChart = options.chart,\n                    chartWidth,\n                    chartHeight,\n                    renderTo = chart.renderTo,\n                    indexAttrName = 'data-highcharts-chart',\n                    oldChartIndex,\n                    Ren,\n                    containerId = H.uniqueKey(),\n                    containerStyle,\n                    key;\n\n                if (!renderTo) {\n                    chart.renderTo = renderTo = optionsChart.renderTo;\n                }\n\n                if (isString(renderTo)) {\n                    chart.renderTo = renderTo = doc.getElementById(renderTo);\n                }\n\n                // Display an error if the renderTo is wrong\n                if (!renderTo) {\n                    H.error(13, true);\n                }\n\n                // If the container already holds a chart, destroy it. The check for\n                // hasRendered is there because web pages that are saved to disk from\n                // the browser, will preserve the data-highcharts-chart attribute and\n                // the SVG contents, but not an interactive chart. So in this case,\n                // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n                oldChartIndex = pInt(attr(renderTo, indexAttrName));\n                if (\n                    isNumber(oldChartIndex) &&\n                    charts[oldChartIndex] &&\n                    charts[oldChartIndex].hasRendered\n                ) {\n                    charts[oldChartIndex].destroy();\n                }\n\n                // Make a reference to the chart from the div\n                attr(renderTo, indexAttrName, chart.index);\n\n                // remove previous chart\n                renderTo.innerHTML = '';\n\n                // If the container doesn't have an offsetWidth, it has or is a child of\n                // a node that has display:none. We need to temporarily move it out to a\n                // visible state to determine the size, else the legend and tooltips\n                // won't render properly. The skipClone option is used in sparklines as\n                // a micro optimization, saving about 1-2 ms each chart.\n                if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n                    chart.temporaryDisplay();\n                }\n\n                // get the width and height\n                chart.getChartSize();\n                chartWidth = chart.chartWidth;\n                chartHeight = chart.chartHeight;\n\n                // Create the inner container\n\n                containerStyle = extend({\n                    position: 'relative',\n                    overflow: 'hidden', // needed for context menu (avoid scrollbars)\n                    // and content overflow in IE\n                    width: chartWidth + 'px',\n                    height: chartHeight + 'px',\n                    textAlign: 'left',\n                    lineHeight: 'normal', // #427\n                    zIndex: 0, // #1072\n                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n                }, optionsChart.style);\n\n\n                /**\n                 * The containing HTML element of the chart. The container is\n                 * dynamically inserted into the element given as the `renderTo`\n                 * parameterin the {@link Highcharts#chart} constructor.\n                 *\n                 * @memberOf Highcharts.Chart\n                 * @type {HTMLDOMElement}\n                 */\n                container = createElement(\n                    'div', {\n                        id: containerId\n                    },\n                    containerStyle,\n                    renderTo\n                );\n                chart.container = container;\n\n                // cache the cursor (#1650)\n                chart._cursor = container.style.cursor;\n\n                // Initialize the renderer\n                Ren = H[optionsChart.renderer] || Renderer;\n                chart.renderer = new Ren(\n                    container,\n                    chartWidth,\n                    chartHeight,\n                    null,\n                    optionsChart.forExport,\n                    options.exporting && options.exporting.allowHTML\n                );\n\n\n                chart.setClassName(optionsChart.className);\n\n                chart.renderer.setStyle(optionsChart.style);\n\n\n                // Add a reference to the charts index\n                chart.renderer.chartIndex = chart.index;\n            },\n\n            /**\n             * Calculate margins by rendering axis labels in a preliminary position.\n             * Title, subtitle and legend have already been rendered at this stage, but\n             * will be moved into their final positions\n             */\n            getMargins: function(skipAxes) {\n                var chart = this,\n                    spacing = chart.spacing,\n                    margin = chart.margin,\n                    titleOffset = chart.titleOffset;\n\n                chart.resetMargins();\n\n                // Adjust for title and subtitle\n                if (titleOffset && !defined(margin[0])) {\n                    chart.plotTop = Math.max(\n                        chart.plotTop,\n                        titleOffset + chart.options.title.margin + spacing[0]\n                    );\n                }\n\n                // Adjust for legend\n                if (chart.legend.display) {\n                    chart.legend.adjustMargins(margin, spacing);\n                }\n\n                // adjust for scroller\n                if (chart.extraMargin) {\n                    chart[chart.extraMargin.type] =\n                        (chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;\n                }\n                if (chart.extraTopMargin) {\n                    chart.plotTop += chart.extraTopMargin;\n                }\n                if (!skipAxes) {\n                    this.getAxisMargins();\n                }\n            },\n\n            getAxisMargins: function() {\n\n                var chart = this,\n                    // [top, right, bottom, left]\n                    axisOffset = chart.axisOffset = [0, 0, 0, 0],\n                    margin = chart.margin;\n\n                // pre-render axes to get labels offset width\n                if (chart.hasCartesianSeries) {\n                    each(chart.axes, function(axis) {\n                        if (axis.visible) {\n                            axis.getOffset();\n                        }\n                    });\n                }\n\n                // Add the axis offsets\n                each(marginNames, function(m, side) {\n                    if (!defined(margin[side])) {\n                        chart[m] += axisOffset[side];\n                    }\n                });\n\n                chart.setChartSize();\n\n            },\n\n            /**\n             * Reflows the chart to its container. By default, the chart reflows\n             * automatically to its container following a `window.resize` event, as per\n             * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}\n             * option. However, there are no reliable events for div resize, so if the\n             * container is resized without a window resize event, this must be called\n             * explicitly.\n             *\n             * @param  {Object} e\n             *         Event arguments. Used primarily when the function is called\n             *         internally as a response to window resize.\n             *\n             * @sample highcharts/members/chart-reflow/\n             *         Resize div and reflow\n             * @sample highcharts/chart/events-container/\n             *         Pop up and reflow\n             */\n            reflow: function(e) {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    renderTo = chart.renderTo,\n                    hasUserWidth = defined(optionsChart.width),\n                    width = optionsChart.width || getStyle(renderTo, 'width'),\n                    height = optionsChart.height || getStyle(renderTo, 'height'),\n                    target = e ? e.target : win;\n\n                // Width and height checks for display:none. Target is doc in IE8 and\n                // Opera, win in Firefox, Chrome and IE9.\n                if (!hasUserWidth &&\n                    !chart.isPrinting &&\n                    width &&\n                    height &&\n                    (target === win || target === doc)\n                ) {\n                    if (\n                        width !== chart.containerWidth ||\n                        height !== chart.containerHeight\n                    ) {\n                        clearTimeout(chart.reflowTimeout);\n                        // When called from window.resize, e is set, else it's called\n                        // directly (#2224)\n                        chart.reflowTimeout = syncTimeout(function() {\n                            // Set size, it may have been destroyed in the meantime\n                            // (#1257)\n                            if (chart.container) {\n                                chart.setSize(undefined, undefined, false);\n                            }\n                        }, e ? 100 : 0);\n                    }\n                    chart.containerWidth = width;\n                    chart.containerHeight = height;\n                }\n            },\n\n            /**\n             * Add the event handlers necessary for auto resizing\n             */\n            initReflow: function() {\n                var chart = this,\n                    unbind;\n\n                unbind = addEvent(win, 'resize', function(e) {\n                    chart.reflow(e);\n                });\n                addEvent(chart, 'destroy', unbind);\n\n                // The following will add listeners to re-fit the chart before and after\n                // printing (#2284). However it only works in WebKit. Should have worked\n                // in Firefox, but not supported in IE.\n                /*\n                if (win.matchMedia) {\n                \twin.matchMedia('print').addListener(function reflow() {\n                \t\tchart.reflow();\n                \t});\n                }\n                */\n            },\n\n            /**\n             * Resize the chart to a given width and height. In order to set the width\n             * only, the height argument may be skipped. To set the height only, pass\n             * `undefined for the width.\n             * @param  {Number|undefined|null} [width]\n             *         The new pixel width of the chart. Since v4.2.6, the argument can\n             *         be `undefined` in order to preserve the current value (when\n             *         setting height only), or `null` to adapt to the width of the\n             *         containing element.\n             * @param  {Number|undefined|null} [height]\n             *         The new pixel height of the chart. Since v4.2.6, the argument can\n             *         be `undefined` in order to preserve the current value, or `null`\n             *         in order to adapt to the height of the containing element.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether and how to apply animation.\n             *\n             * @sample highcharts/members/chart-setsize-button/\n             *         Test resizing from buttons\n             * @sample highcharts/members/chart-setsize-jquery-resizable/\n             *         Add a jQuery UI resizable\n             * @sample stock/members/chart-setsize/\n             *         Highstock with UI resizable\n             */\n            setSize: function(width, height, animation) {\n                var chart = this,\n                    renderer = chart.renderer,\n                    globalAnimation;\n\n                // Handle the isResizing counter\n                chart.isResizing += 1;\n\n                // set the animation for the current process\n                H.setAnimation(animation, chart);\n\n                chart.oldChartHeight = chart.chartHeight;\n                chart.oldChartWidth = chart.chartWidth;\n                if (width !== undefined) {\n                    chart.options.chart.width = width;\n                }\n                if (height !== undefined) {\n                    chart.options.chart.height = height;\n                }\n                chart.getChartSize();\n\n                // Resize the container with the global animation applied if enabled\n                // (#2503)\n\n                globalAnimation = renderer.globalAnimation;\n                (globalAnimation ? animate : css)(chart.container, {\n                    width: chart.chartWidth + 'px',\n                    height: chart.chartHeight + 'px'\n                }, globalAnimation);\n\n\n                chart.setChartSize(true);\n                renderer.setSize(chart.chartWidth, chart.chartHeight, animation);\n\n                // handle axes\n                each(chart.axes, function(axis) {\n                    axis.isDirty = true;\n                    axis.setScale();\n                });\n\n                chart.isDirtyLegend = true; // force legend redraw\n                chart.isDirtyBox = true; // force redraw of plot and chart border\n\n                chart.layOutTitles(); // #2857\n                chart.getMargins();\n\n                chart.redraw(animation);\n\n\n                chart.oldChartHeight = null;\n                fireEvent(chart, 'resize');\n\n                // Fire endResize and set isResizing back. If animation is disabled,\n                // fire without delay\n                syncTimeout(function() {\n                    if (chart) {\n                        fireEvent(chart, 'endResize', null, function() {\n                            chart.isResizing -= 1;\n                        });\n                    }\n                }, animObject(globalAnimation).duration);\n            },\n\n            /**\n             * Set the public chart properties. This is done before and after the\n             * pre-render to determine margin sizes\n             */\n            setChartSize: function(skipAxes) {\n                var chart = this,\n                    inverted = chart.inverted,\n                    renderer = chart.renderer,\n                    chartWidth = chart.chartWidth,\n                    chartHeight = chart.chartHeight,\n                    optionsChart = chart.options.chart,\n                    spacing = chart.spacing,\n                    clipOffset = chart.clipOffset,\n                    clipX,\n                    clipY,\n                    plotLeft,\n                    plotTop,\n                    plotWidth,\n                    plotHeight,\n                    plotBorderWidth;\n\n                function clipOffsetSide(side) {\n                    var offset = clipOffset[side] || 0;\n                    return Math.max(plotBorderWidth || offset, offset) / 2;\n                }\n\n                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n                chart.plotTop = plotTop = Math.round(chart.plotTop);\n                chart.plotWidth = plotWidth = Math.max(\n                    0,\n                    Math.round(chartWidth - plotLeft - chart.marginRight)\n                );\n                chart.plotHeight = plotHeight = Math.max(\n                    0,\n                    Math.round(chartHeight - plotTop - chart.marginBottom)\n                );\n\n                chart.plotSizeX = inverted ? plotHeight : plotWidth;\n                chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n                // Set boxes used for alignment\n                chart.spacingBox = renderer.spacingBox = {\n                    x: spacing[3],\n                    y: spacing[0],\n                    width: chartWidth - spacing[3] - spacing[1],\n                    height: chartHeight - spacing[0] - spacing[2]\n                };\n                chart.plotBox = renderer.plotBox = {\n                    x: plotLeft,\n                    y: plotTop,\n                    width: plotWidth,\n                    height: plotHeight\n                };\n\n                plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n                clipX = Math.ceil(clipOffsetSide(3));\n                clipY = Math.ceil(clipOffsetSide(0));\n                chart.clipBox = {\n                    x: clipX,\n                    y: clipY,\n                    width: Math.floor(\n                        chart.plotSizeX -\n                        clipOffsetSide(1) -\n                        clipX\n                    ),\n                    height: Math.max(\n                        0,\n                        Math.floor(\n                            chart.plotSizeY -\n                            clipOffsetSide(2) -\n                            clipY\n                        )\n                    )\n                };\n\n                if (!skipAxes) {\n                    each(chart.axes, function(axis) {\n                        axis.setAxisSize();\n                        axis.setAxisTranslation();\n                    });\n                }\n            },\n\n            /**\n             * Initial margins before auto size margins are applied\n             */\n            resetMargins: function() {\n                var chart = this,\n                    chartOptions = chart.options.chart;\n\n                // Create margin and spacing array\n                each(['margin', 'spacing'], function splashArrays(target) {\n                    var value = chartOptions[target],\n                        values = isObject(value) ? value : [value, value, value, value];\n\n                    each(['Top', 'Right', 'Bottom', 'Left'], function(sideName, side) {\n                        chart[target][side] = pick(\n                            chartOptions[target + sideName],\n                            values[side]\n                        );\n                    });\n                });\n\n                // Set margin names like chart.plotTop, chart.plotLeft,\n                // chart.marginRight, chart.marginBottom.\n                each(marginNames, function(m, side) {\n                    chart[m] = pick(chart.margin[side], chart.spacing[side]);\n                });\n                chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n                chart.clipOffset = [];\n            },\n\n            /**\n             * Draw the borders and backgrounds for chart and plot area\n             */\n            drawChartBox: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    renderer = chart.renderer,\n                    chartWidth = chart.chartWidth,\n                    chartHeight = chart.chartHeight,\n                    chartBackground = chart.chartBackground,\n                    plotBackground = chart.plotBackground,\n                    plotBorder = chart.plotBorder,\n                    chartBorderWidth,\n\n                    plotBGImage = chart.plotBGImage,\n                    chartBackgroundColor = optionsChart.backgroundColor,\n                    plotBackgroundColor = optionsChart.plotBackgroundColor,\n                    plotBackgroundImage = optionsChart.plotBackgroundImage,\n\n                    mgn,\n                    bgAttr,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    plotBox = chart.plotBox,\n                    clipRect = chart.clipRect,\n                    clipBox = chart.clipBox,\n                    verb = 'animate';\n\n                // Chart area\n                if (!chartBackground) {\n                    chart.chartBackground = chartBackground = renderer.rect()\n                        .addClass('highcharts-background')\n                        .add();\n                    verb = 'attr';\n                }\n\n\n                // Presentational\n                chartBorderWidth = optionsChart.borderWidth || 0;\n                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n                bgAttr = {\n                    fill: chartBackgroundColor || 'none'\n                };\n\n                if (chartBorderWidth || chartBackground['stroke-width']) { // #980\n                    bgAttr.stroke = optionsChart.borderColor;\n                    bgAttr['stroke-width'] = chartBorderWidth;\n                }\n                chartBackground\n                    .attr(bgAttr)\n                    .shadow(optionsChart.shadow);\n\n                chartBackground[verb]({\n                    x: mgn / 2,\n                    y: mgn / 2,\n                    width: chartWidth - mgn - chartBorderWidth % 2,\n                    height: chartHeight - mgn - chartBorderWidth % 2,\n                    r: optionsChart.borderRadius\n                });\n\n                // Plot background\n                verb = 'animate';\n                if (!plotBackground) {\n                    verb = 'attr';\n                    chart.plotBackground = plotBackground = renderer.rect()\n                        .addClass('highcharts-plot-background')\n                        .add();\n                }\n                plotBackground[verb](plotBox);\n\n\n                // Presentational attributes for the background\n                plotBackground\n                    .attr({\n                        fill: plotBackgroundColor || 'none'\n                    })\n                    .shadow(optionsChart.plotShadow);\n\n                // Create the background image\n                if (plotBackgroundImage) {\n                    if (!plotBGImage) {\n                        chart.plotBGImage = renderer.image(\n                            plotBackgroundImage,\n                            plotLeft,\n                            plotTop,\n                            plotWidth,\n                            plotHeight\n                        ).add();\n                    } else {\n                        plotBGImage.animate(plotBox);\n                    }\n                }\n\n\n                // Plot clip\n                if (!clipRect) {\n                    chart.clipRect = renderer.clipRect(clipBox);\n                } else {\n                    clipRect.animate({\n                        width: clipBox.width,\n                        height: clipBox.height\n                    });\n                }\n\n                // Plot area border\n                verb = 'animate';\n                if (!plotBorder) {\n                    verb = 'attr';\n                    chart.plotBorder = plotBorder = renderer.rect()\n                        .addClass('highcharts-plot-border')\n                        .attr({\n                            zIndex: 1 // Above the grid\n                        })\n                        .add();\n                }\n\n\n                // Presentational\n                plotBorder.attr({\n                    stroke: optionsChart.plotBorderColor,\n                    'stroke-width': optionsChart.plotBorderWidth || 0,\n                    fill: 'none'\n                });\n\n\n                plotBorder[verb](plotBorder.crisp({\n                    x: plotLeft,\n                    y: plotTop,\n                    width: plotWidth,\n                    height: plotHeight\n                }, -plotBorder.strokeWidth())); //#3282 plotBorder should be negative;\n\n                // reset\n                chart.isDirtyBox = false;\n            },\n\n            /**\n             * Detect whether a certain chart property is needed based on inspecting its\n             * options and series. This mainly applies to the chart.inverted property,\n             * and in extensions to the chart.angular and chart.polar properties.\n             */\n            propFromSeries: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    klass,\n                    seriesOptions = chart.options.series,\n                    i,\n                    value;\n\n\n                each(['inverted', 'angular', 'polar'], function(key) {\n\n                    // The default series type's class\n                    klass = seriesTypes[optionsChart.type ||\n                        optionsChart.defaultSeriesType];\n\n                    // Get the value from available chart-wide properties\n                    value =\n                        optionsChart[key] || // It is set in the options\n                        (klass && klass.prototype[key]); // The default series class\n                    // requires it\n\n                    // 4. Check if any the chart's series require it\n                    i = seriesOptions && seriesOptions.length;\n                    while (!value && i--) {\n                        klass = seriesTypes[seriesOptions[i].type];\n                        if (klass && klass.prototype[key]) {\n                            value = true;\n                        }\n                    }\n\n                    // Set the chart property\n                    chart[key] = value;\n                });\n\n            },\n\n            /**\n             * Link two or more series together. This is done initially from\n             * Chart.render, and after Chart.addSeries and Series.remove.\n             */\n            linkSeries: function() {\n                var chart = this,\n                    chartSeries = chart.series;\n\n                // Reset links\n                each(chartSeries, function(series) {\n                    series.linkedSeries.length = 0;\n                });\n\n                // Apply new links\n                each(chartSeries, function(series) {\n                    var linkedTo = series.options.linkedTo;\n                    if (isString(linkedTo)) {\n                        if (linkedTo === ':previous') {\n                            linkedTo = chart.series[series.index - 1];\n                        } else {\n                            linkedTo = chart.get(linkedTo);\n                        }\n                        // #3341 avoid mutual linking\n                        if (linkedTo && linkedTo.linkedParent !== series) {\n                            linkedTo.linkedSeries.push(series);\n                            series.linkedParent = linkedTo;\n                            series.visible = pick(\n                                series.options.visible,\n                                linkedTo.options.visible,\n                                series.visible\n                            ); // #3879\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Render series for the chart\n             */\n            renderSeries: function() {\n                each(this.series, function(serie) {\n                    serie.translate();\n                    serie.render();\n                });\n            },\n\n            /**\n             * Render labels for the chart\n             */\n            renderLabels: function() {\n                var chart = this,\n                    labels = chart.options.labels;\n                if (labels.items) {\n                    each(labels.items, function(label) {\n                        var style = extend(labels.style, label.style),\n                            x = pInt(style.left) + chart.plotLeft,\n                            y = pInt(style.top) + chart.plotTop + 12;\n\n                        // delete to prevent rewriting in IE\n                        delete style.left;\n                        delete style.top;\n\n                        chart.renderer.text(\n                                label.html,\n                                x,\n                                y\n                            )\n                            .attr({\n                                zIndex: 2\n                            })\n                            .css(style)\n                            .add();\n\n                    });\n                }\n            },\n\n            /**\n             * Render all graphics for the chart\n             */\n            render: function() {\n                var chart = this,\n                    axes = chart.axes,\n                    renderer = chart.renderer,\n                    options = chart.options,\n                    tempWidth,\n                    tempHeight,\n                    redoHorizontal,\n                    redoVertical;\n\n                // Title\n                chart.setTitle();\n\n\n                // Legend\n                chart.legend = new Legend(chart, options.legend);\n\n                // Get stacks\n                if (chart.getStacks) {\n                    chart.getStacks();\n                }\n\n                // Get chart margins\n                chart.getMargins(true);\n                chart.setChartSize();\n\n                // Record preliminary dimensions for later comparison\n                tempWidth = chart.plotWidth;\n                tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n                // Get margins by pre-rendering axes\n                each(axes, function(axis) {\n                    axis.setScale();\n                });\n                chart.getAxisMargins();\n\n                // If the plot area size has changed significantly, calculate tick positions again\n                redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n                redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n                if (redoHorizontal || redoVertical) {\n\n                    each(axes, function(axis) {\n                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                            axis.setTickInterval(true); // update to reflect the new margins\n                        }\n                    });\n                    chart.getMargins(); // second pass to check for new labels\n                }\n\n                // Draw the borders and backgrounds\n                chart.drawChartBox();\n\n\n                // Axes\n                if (chart.hasCartesianSeries) {\n                    each(axes, function(axis) {\n                        if (axis.visible) {\n                            axis.render();\n                        }\n                    });\n                }\n\n                // The series\n                if (!chart.seriesGroup) {\n                    chart.seriesGroup = renderer.g('series-group')\n                        .attr({\n                            zIndex: 3\n                        })\n                        .add();\n                }\n                chart.renderSeries();\n\n                // Labels\n                chart.renderLabels();\n\n                // Credits\n                chart.addCredits();\n\n                // Handle responsiveness\n                if (chart.setResponsive) {\n                    chart.setResponsive();\n                }\n\n                // Set flag\n                chart.hasRendered = true;\n\n            },\n\n            /**\n             * Set a new credits label for the chart.\n             *\n             * @param  {CreditOptions} options\n             *         A configuration object for the new credits.\n             * @sample highcharts/credits/credits-update/ Add and update credits\n             */\n            addCredits: function(credits) {\n                var chart = this;\n\n                credits = merge(true, this.options.credits, credits);\n                if (credits.enabled && !this.credits) {\n\n                    /**\n                     * The chart's credits label. The label has an `update` method that\n                     * allows setting new options as per the {@link\n                     * https://api.highcharts.com/highcharts/credits|\n                     * credits options set}.\n                     *\n                     * @memberof Highcharts.Chart\n                     * @name credits\n                     * @type {Highcharts.SVGElement}\n                     */\n                    this.credits = this.renderer.text(\n                            credits.text + (this.mapCredits || ''),\n                            0,\n                            0\n                        )\n                        .addClass('highcharts-credits')\n                        .on('click', function() {\n                            if (credits.href) {\n                                win.location.href = credits.href;\n                            }\n                        })\n                        .attr({\n                            align: credits.position.align,\n                            zIndex: 8\n                        })\n\n                        .css(credits.style)\n\n                        .add()\n                        .align(credits.position);\n\n                    // Dynamically update\n                    this.credits.update = function(options) {\n                        chart.credits = chart.credits.destroy();\n                        chart.addCredits(options);\n                    };\n                }\n            },\n\n            /**\n             * Remove the chart and purge memory. This method is called internally\n             * before adding a second chart into the same container, as well as on\n             * window unload to prevent leaks.\n             *\n             * @sample highcharts/members/chart-destroy/\n             *         Destroy the chart from a button\n             * @sample stock/members/chart-destroy/\n             *         Destroy with Highstock\n             */\n            destroy: function() {\n                var chart = this,\n                    axes = chart.axes,\n                    series = chart.series,\n                    container = chart.container,\n                    i,\n                    parentNode = container && container.parentNode;\n\n                // fire the chart.destoy event\n                fireEvent(chart, 'destroy');\n\n                // Delete the chart from charts lookup array\n                if (chart.renderer.forExport) {\n                    H.erase(charts, chart); // #6569\n                } else {\n                    charts[chart.index] = undefined;\n                }\n                H.chartCount--;\n                chart.renderTo.removeAttribute('data-highcharts-chart');\n\n                // remove events\n                removeEvent(chart);\n\n                // ==== Destroy collections:\n                // Destroy axes\n                i = axes.length;\n                while (i--) {\n                    axes[i] = axes[i].destroy();\n                }\n\n                // Destroy scroller & scroller series before destroying base series\n                if (this.scroller && this.scroller.destroy) {\n                    this.scroller.destroy();\n                }\n\n                // Destroy each series\n                i = series.length;\n                while (i--) {\n                    series[i] = series[i].destroy();\n                }\n\n                // ==== Destroy chart properties:\n                each([\n                    'title', 'subtitle', 'chartBackground', 'plotBackground',\n                    'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',\n                    'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',\n                    'renderer'\n                ], function(name) {\n                    var prop = chart[name];\n\n                    if (prop && prop.destroy) {\n                        chart[name] = prop.destroy();\n                    }\n                });\n\n                // remove container and all SVG\n                if (container) { // can break in IE when destroyed before finished loading\n                    container.innerHTML = '';\n                    removeEvent(container);\n                    if (parentNode) {\n                        discardElement(container);\n                    }\n\n                }\n\n                // clean it all up\n                objectEach(chart, function(val, key) {\n                    delete chart[key];\n                });\n\n            },\n\n\n            /**\n             * VML namespaces can't be added until after complete. Listening\n             * for Perini's doScroll hack is not enough.\n             */\n            isReadyToRender: function() {\n                var chart = this;\n\n                // Note: win == win.top is required\n                if ((!svg && (win == win.top && doc.readyState !== 'complete'))) { // eslint-disable-line eqeqeq\n                    doc.attachEvent('onreadystatechange', function() {\n                        doc.detachEvent('onreadystatechange', chart.firstRender);\n                        if (doc.readyState === 'complete') {\n                            chart.firstRender();\n                        }\n                    });\n                    return false;\n                }\n                return true;\n            },\n\n            /**\n             * Prepare for first rendering after all data are loaded\n             */\n            firstRender: function() {\n                var chart = this,\n                    options = chart.options;\n\n                // Check whether the chart is ready to render\n                if (!chart.isReadyToRender()) {\n                    return;\n                }\n\n                // Create the container\n                chart.getContainer();\n\n                // Run an early event after the container and renderer are established\n                fireEvent(chart, 'init');\n\n\n                chart.resetMargins();\n                chart.setChartSize();\n\n                // Set the common chart properties (mainly invert) from the given series\n                chart.propFromSeries();\n\n                // get axes\n                chart.getAxes();\n\n                // Initialize the series\n                each(options.series || [], function(serieOptions) {\n                    chart.initSeries(serieOptions);\n                });\n\n                chart.linkSeries();\n\n                // Run an event after axes and series are initialized, but before render. At this stage,\n                // the series data is indexed and cached in the xData and yData arrays, so we can access\n                // those before rendering. Used in Highstock.\n                fireEvent(chart, 'beforeRender');\n\n                // depends on inverted and on margins being set\n                if (Pointer) {\n                    chart.pointer = new Pointer(chart, options);\n                }\n\n                chart.render();\n\n                // Fire the load event if there are no external images\n                if (!chart.renderer.imgCount && chart.onload) {\n                    chart.onload();\n                }\n\n                // If the chart was rendered outside the top container, put it back in (#3679)\n                chart.temporaryDisplay(true);\n\n            },\n\n            /** \n             * On chart load\n             */\n            onload: function() {\n\n                // Run callbacks\n                each([this.callback].concat(this.callbacks), function(fn) {\n                    if (fn && this.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                        fn.apply(this, [this]);\n                    }\n                }, this);\n\n                fireEvent(this, 'load');\n                fireEvent(this, 'render');\n\n\n                // Set up auto resize, check for not destroyed (#6068)\n                if (defined(this.index) && this.options.chart.reflow !== false) {\n                    this.initReflow();\n                }\n\n                // Don't run again\n                this.onload = null;\n            }\n\n        }); // end Chart\n\n    }(Highcharts));\n    (function(Highcharts) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Point,\n            H = Highcharts,\n\n            each = H.each,\n            extend = H.extend,\n            erase = H.erase,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            pick = H.pick,\n            removeEvent = H.removeEvent;\n\n        /**\n         * The Point object. The point objects are generated from the `series.data` \n         * configuration objects or raw numbers. They can be accessed from the\n         * `Series.points` array. Other ways to instaniate points are through {@link\n         * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n         *\n         * @class\n         */\n\n        Highcharts.Point = Point = function() {};\n        Highcharts.Point.prototype = {\n\n            /**\n             * Initialize the point. Called internally based on the series.data option.\n             * @param {Object} series The series object containing this point.\n             * @param {Object} options The data in either number, array or object\n             *        format.\n             * @param {Number} x Optionally, the X value of the.\n             * @returns {Object} The Point instance.\n             */\n            init: function(series, options, x) {\n\n                var point = this,\n                    colors,\n                    colorCount = series.chart.options.chart.colorCount,\n                    colorIndex;\n\n                /**\n                 * The series object associated with the point.\n                 *\n                 * @name series\n                 * @memberof Highcharts.Point\n                 * @type Highcharts.Series\n                 */\n                point.series = series;\n\n\n                /**\n                 * The point's current color.\n                 * @name color\n                 * @memberof Highcharts.Point\n                 * @type {Color}\n                 */\n                point.color = series.color; // #3445\n\n                point.applyOptions(options, x);\n\n                if (series.options.colorByPoint) {\n\n                    colors = series.options.colors || series.chart.options.colors;\n                    point.color = point.color || colors[series.colorCounter];\n                    colorCount = colors.length;\n\n                    colorIndex = series.colorCounter;\n                    series.colorCounter++;\n                    // loop back to zero\n                    if (series.colorCounter === colorCount) {\n                        series.colorCounter = 0;\n                    }\n                } else {\n                    colorIndex = series.colorIndex;\n                }\n                point.colorIndex = pick(point.colorIndex, colorIndex);\n\n                series.chart.pointCount++;\n                return point;\n            },\n            /**\n             * Apply the options containing the x and y data and possible some extra\n             * properties. Called on point init or from point.update.\n             *\n             * @param {Object} options The point options as defined in series.data.\n             * @param {Number} x Optionally, the X value.\n             * @returns {Object} The Point instance.\n             */\n            applyOptions: function(options, x) {\n                var point = this,\n                    series = point.series,\n                    pointValKey = series.options.pointValKey || series.pointValKey;\n\n                options = Point.prototype.optionsToObject.call(this, options);\n\n                // copy options directly to point\n                extend(point, options);\n                point.options = point.options ? extend(point.options, options) : options;\n\n                // Since options are copied into the Point instance, some accidental options must be shielded (#5681)\n                if (options.group) {\n                    delete point.group;\n                }\n\n                // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n                if (pointValKey) {\n                    point.y = point[pointValKey];\n                }\n                point.isNull = pick(\n                    point.isValid && !point.isValid(),\n                    point.x === null || !isNumber(point.y, true)\n                ); // #3571, check for NaN\n\n                // The point is initially selected by options (#5777)\n                if (point.selected) {\n                    point.state = 'select';\n                }\n\n                // If no x is set by now, get auto incremented value. All points must have an\n                // x value, however the y value can be null to create a gap in the series\n                if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {\n                    point.x = series.xAxis.nameToX(point);\n                }\n                if (point.x === undefined && series) {\n                    if (x === undefined) {\n                        point.x = series.autoIncrement(point);\n                    } else {\n                        point.x = x;\n                    }\n                }\n\n                return point;\n            },\n\n            /**\n             * Transform number or array configs into objects\n             */\n            optionsToObject: function(options) {\n                var ret = {},\n                    series = this.series,\n                    keys = series.options.keys,\n                    pointArrayMap = keys || series.pointArrayMap || ['y'],\n                    valueCount = pointArrayMap.length,\n                    firstItemType,\n                    i = 0,\n                    j = 0;\n\n                if (isNumber(options) || options === null) {\n                    ret[pointArrayMap[0]] = options;\n\n                } else if (isArray(options)) {\n                    // with leading x value\n                    if (!keys && options.length > valueCount) {\n                        firstItemType = typeof options[0];\n                        if (firstItemType === 'string') {\n                            ret.name = options[0];\n                        } else if (firstItemType === 'number') {\n                            ret.x = options[0];\n                        }\n                        i++;\n                    }\n                    while (j < valueCount) {\n                        if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                            ret[pointArrayMap[j]] = options[i];\n                        }\n                        i++;\n                        j++;\n                    }\n                } else if (typeof options === 'object') {\n                    ret = options;\n\n                    // This is the fastest way to detect if there are individual point dataLabels that need\n                    // to be considered in drawDataLabels. These can only occur in object configs.\n                    if (options.dataLabels) {\n                        series._hasPointLabels = true;\n                    }\n\n                    // Same approach as above for markers\n                    if (options.marker) {\n                        series._hasPointMarkers = true;\n                    }\n                }\n                return ret;\n            },\n\n            /**\n             * Get the CSS class names for individual points\n             * @returns {String} The class name\n             */\n            getClassName: function() {\n                return 'highcharts-point' +\n                    (this.selected ? ' highcharts-point-select' : '') +\n                    (this.negative ? ' highcharts-negative' : '') +\n                    (this.isNull ? ' highcharts-null-point' : '') +\n                    (this.colorIndex !== undefined ? ' highcharts-color-' +\n                        this.colorIndex : '') +\n                    (this.options.className ? ' ' + this.options.className : '') +\n                    (this.zone && this.zone.className ? ' ' +\n                        this.zone.className.replace('highcharts-negative', '') : '');\n            },\n\n            /**\n             * Return the zone that the point belongs to\n             */\n            getZone: function() {\n                var series = this.series,\n                    zones = series.zones,\n                    zoneAxis = series.zoneAxis || 'y',\n                    i = 0,\n                    zone;\n\n                zone = zones[i];\n                while (this[zoneAxis] >= zone.value) {\n                    zone = zones[++i];\n                }\n\n                if (zone && zone.color && !this.options.color) {\n                    this.color = zone.color;\n                }\n\n                return zone;\n            },\n\n            /**\n             * Destroy a point to clear memory. Its reference still stays in series.data.\n             */\n            destroy: function() {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    hoverPoints = chart.hoverPoints,\n                    prop;\n\n                chart.pointCount--;\n\n                if (hoverPoints) {\n                    point.setState();\n                    erase(hoverPoints, point);\n                    if (!hoverPoints.length) {\n                        chart.hoverPoints = null;\n                    }\n\n                }\n                if (point === chart.hoverPoint) {\n                    point.onMouseOut();\n                }\n\n                // remove all events\n                if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n                    removeEvent(point);\n                    point.destroyElements();\n                }\n\n                if (point.legendItem) { // pies have legend items\n                    chart.legend.destroyItem(point);\n                }\n\n                for (prop in point) {\n                    point[prop] = null;\n                }\n\n\n            },\n\n            /**\n             * Destroy SVG elements associated with the point\n             */\n            destroyElements: function() {\n                var point = this,\n                    props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n                    prop,\n                    i = 6;\n                while (i--) {\n                    prop = props[i];\n                    if (point[prop]) {\n                        point[prop] = point[prop].destroy();\n                    }\n                }\n            },\n\n            /**\n             * Return the configuration hash needed for the data label and tooltip formatters\n             */\n            getLabelConfig: function() {\n                return {\n                    x: this.category,\n                    y: this.y,\n                    color: this.color,\n                    colorIndex: this.colorIndex,\n                    key: this.name || this.category,\n                    series: this.series,\n                    point: this,\n                    percentage: this.percentage,\n                    total: this.total || this.stackTotal\n                };\n            },\n\n            /**\n             * Extendable method for formatting each point's tooltip line\n             *\n             * @return {String} A string to be concatenated in to the common tooltip text\n             */\n            tooltipFormatter: function(pointFormat) {\n\n                // Insert options for valueDecimals, valuePrefix, and valueSuffix\n                var series = this.series,\n                    seriesTooltipOptions = series.tooltipOptions,\n                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n                    valuePrefix = seriesTooltipOptions.valuePrefix || '',\n                    valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n                // Loop over the point array map and replace unformatted values with sprintf formatting markup\n                each(series.pointArrayMap || ['y'], function(key) {\n                    key = '{point.' + key; // without the closing bracket\n                    if (valuePrefix || valueSuffix) {\n                        pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n                    }\n                    pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n                });\n\n                return format(pointFormat, {\n                    point: this,\n                    series: this.series\n                });\n            },\n\n            /**\n             * Fire an event on the Point object.\n             * @param {String} eventType\n             * @param {Object} eventArgs Additional event arguments\n             * @param {Function} defaultFunction Default event handler\n             */\n            firePointEvent: function(eventType, eventArgs, defaultFunction) {\n                var point = this,\n                    series = this.series,\n                    seriesOptions = series.options;\n\n                // load event handlers on demand to save time on mouseover/out\n                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n                    this.importEvents();\n                }\n\n                // add default handler if in selection mode\n                if (eventType === 'click' && seriesOptions.allowPointSelect) {\n                    defaultFunction = function(event) {\n                        // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                        if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                        }\n                    };\n                }\n\n                fireEvent(this, eventType, eventArgs, defaultFunction);\n            },\n\n            /**\n             * For certain series types, like pie charts, where individual points can\n             * be shown or hidden. \n             *\n             * @name visible\n             * @memberOf Highcharts.Point\n             * @type {Boolean}\n             */\n            visible: true\n        };\n\n        /**\n         * For categorized axes this property holds the category name for the \n         * point. For other axes it holds the X value.\n         *\n         * @name category\n         * @memberOf Highcharts.Point\n         * @type {String|Number}\n         */\n\n        /**\n         * The percentage for points in a stacked series or pies.\n         *\n         * @name percentage\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The total of values in either a stack for stacked series, or a pie in a pie\n         * series.\n         *\n         * @name total\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The x value of the point.\n         *\n         * @name x\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The y value of the point.\n         *\n         * @name y\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animObject = H.animObject,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            correctFloat = H.correctFloat,\n            Date = H.Date,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defined = H.defined,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            grep = H.grep,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isString = H.isString,\n            LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement\n            merge = H.merge,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Point = H.Point, // @todo  add as a requirement\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            SVGElement = H.SVGElement,\n            syncTimeout = H.syncTimeout,\n            win = H.win;\n\n        /**\n         * This is the base series prototype that all other series types inherit from.\n         * A new series is initiated either through the {@link https://api.highcharts.com/highcharts/series|\n         * series} option structure, or after the chart is initiated, through {@link\n         * Highcharts.Chart#addSeries}.\n         *\n         * The object can be accessed in a number of ways. All series and point event\n         * handlers give a reference to the `series` object. The chart object has a\n         * {@link Highcharts.Chart.series|series} property that is a collection of all\n         * the chart's series. The point objects and axis objects also have the same\n         * reference.\n         * \n         * Another way to reference the series programmatically is by `id`. Add an id\n         * in the series configuration options, and get the series object by {@link\n         * Highcharts.Chart#get}.\n         *\n         * Configuration options for the series are given in three levels. Options for\n         * all series in a chart are given in the {@link https://api.highcharts.com/highcharts/plotOptions.series|\n         * plotOptions.series} object. Then options for all series of a specific type\n         * are given in the plotOptions of that type, for example `plotOptions.line`.\n         * Next, options for one single series are given in the series array, or as\n         * arguements to `chart.addSeries`. \n         * \n         * The data in the series is stored in various arrays.\n         *\n         * - First, `series.options.data` contains all the original config options for\n         * each point whether added by options or methods like `series.addPoint`.\n         * - Next, `series.data` contains those values converted to points, but in case\n         * the series data length exceeds the `cropThreshold`, or if the data is grouped,\n         * `series.data` doesn't contain all the points. It only contains the points that\n         * have been created on demand.\n         * - Then there's `series.points` that contains all currently visible point\n         * objects. In case of cropping, the cropped-away points are not part of this\n         * array. The `series.points` array starts at `series.cropStart` compared to\n         * `series.data` and `series.options.data`. If however the series data is grouped,\n         * these can't be correlated one to one.\n         * - `series.xData` and `series.processedXData` contain clean x values, equivalent\n         * to `series.data` and `series.points`.\n         * - `series.yData` and `series.processedYData` contain clean y values, equivalent\n         * to `series.data` and `series.points`.\n         *\n         * @class Highcharts.Series\n         * @param  {Highcharts.Chart} chart\n         *         The chart instance.\n         * @param  {Object} options\n         *         The series options.\n         */\n        H.Series = H.seriesType('line', null, { // base series options\n\n            //cursor: 'default',\n            //dashStyle: null,\n            //linecap: 'round',\n            lineWidth: 2,\n            //shadow: false,\n\n            allowPointSelect: false,\n            showCheckbox: false,\n            animation: {\n                duration: 1000\n            },\n            //clip: true,\n            //connectNulls: false,\n            //enableMouseTracking: true,\n            events: {},\n            //legendIndex: 0,\n            // stacking: null,\n            marker: {\n\n                lineWidth: 0,\n                lineColor: '#ffffff',\n                //fillColor: null,\n\n                //enabled: true,\n                //symbol: null,\n                radius: 4,\n                states: { // states for a single point\n                    hover: {\n                        animation: {\n                            duration: 50\n                        },\n                        enabled: true,\n                        radiusPlus: 2,\n\n                        lineWidthPlus: 1\n\n                    },\n\n                    select: {\n                        fillColor: '#cccccc',\n                        lineColor: '#000000',\n                        lineWidth: 2\n                    }\n\n                }\n            },\n            point: {\n                events: {}\n            },\n            dataLabels: {\n                align: 'center',\n                // defer: true,\n                // enabled: false,\n                formatter: function() {\n                    return this.y === null ? '' : H.numberFormat(this.y, -1);\n                },\n\n                style: {\n                    fontSize: '11px',\n                    fontWeight: 'bold',\n                    color: 'contrast',\n                    textOutline: '1px contrast'\n                },\n                // backgroundColor: undefined,\n                // borderColor: undefined,\n                // borderWidth: undefined,\n                // shadow: false\n\n                verticalAlign: 'bottom', // above singular point\n                x: 0,\n                y: 0,\n                // borderRadius: undefined,\n                padding: 5\n            },\n            // draw points outside the plot area when the number of points is less than\n            // this\n            cropThreshold: 300,\n            pointRange: 0,\n            //pointStart: 0,\n            //pointInterval: 1,\n            //showInLegend: null, // auto = false for linked series\n            softThreshold: true,\n            states: { // states for the entire series\n                hover: {\n                    //enabled: false,\n                    animation: {\n                        duration: 50\n                    },\n                    lineWidthPlus: 1,\n                    marker: {\n                        // lineWidth: base + 1,\n                        // radius: base + 1\n                    },\n                    halo: {\n                        size: 10,\n\n                        opacity: 0.25\n\n                    }\n                },\n                select: {\n                    marker: {}\n                }\n            },\n            stickyTracking: true,\n            //tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span>' +\n            // '{series.name}: <b>{point.y}</b>'\n            //valueDecimals: null,\n            //xDateFormat: '%A, %b %e, %Y',\n            //valuePrefix: '',\n            //ySuffix: ''\n            //}\n            turboThreshold: 1000,\n            // zIndex: null\n            findNearestPointBy: 'x'\n\n        }, /** @lends Highcharts.Series.prototype */ {\n            isCartesian: true,\n            pointClass: Point,\n            sorted: true, // requires the data to be sorted\n            requireSorting: true,\n            directTouch: false,\n            axisTypes: ['xAxis', 'yAxis'],\n            colorCounter: 0,\n            // each point's x and y values are stored in this.xData and this.yData\n            parallelArrays: ['x', 'y'],\n            coll: 'series',\n            init: function(chart, options) {\n                var series = this,\n                    events,\n                    chartSeries = chart.series,\n                    lastSeries;\n\n                /**\n                 * Read only. The chart that the series belongs to.\n                 *\n                 * @name chart\n                 * @memberOf Series\n                 * @type {Chart}\n                 */\n                series.chart = chart;\n\n                /**\n                 * Read only. The series' type, like \"line\", \"area\", \"column\" etc. The\n                 * type in the series options anc can be altered using {@link\n                 * Series#update}.\n                 *\n                 * @name type\n                 * @memberOf Series\n                 * @type String\n                 */\n\n                /**\n                 * Read only. The series' current options. To update, use {@link\n                 * Series#update}.\n                 *\n                 * @name options\n                 * @memberOf Series\n                 * @type SeriesOptions\n                 */\n                series.options = options = series.setOptions(options);\n                series.linkedSeries = [];\n\n                // bind the axes\n                series.bindAxes();\n\n                // set some variables\n                extend(series, {\n                    /**\n                     * The series name as given in the options. Defaults to\n                     * \"Series {n}\".\n                     *\n                     * @name name\n                     * @memberOf Series\n                     * @type {String}\n                     */\n                    name: options.name,\n                    state: '',\n                    /**\n                     * Read only. The series' visibility state as set by {@link\n                     * Series#show}, {@link Series#hide}, or in the initial\n                     * configuration.\n                     *\n                     * @name visible\n                     * @memberOf Series\n                     * @type {Boolean}\n                     */\n                    visible: options.visible !== false, // true by default\n                    /**\n                     * Read only. The series' selected state as set by {@link\n                     * Highcharts.Series#select}.\n                     * \n                     * @name selected\n                     * @memberOf Series\n                     * @type {Boolean}\n                     */\n                    selected: options.selected === true // false by default\n                });\n\n                // register event listeners\n                events = options.events;\n\n                objectEach(events, function(event, eventType) {\n                    addEvent(series, eventType, event);\n                });\n                if (\n                    (events && events.click) ||\n                    (\n                        options.point &&\n                        options.point.events &&\n                        options.point.events.click\n                    ) ||\n                    options.allowPointSelect\n                ) {\n                    chart.runTrackerClick = true;\n                }\n\n                series.getColor();\n                series.getSymbol();\n\n                // Set the data\n                each(series.parallelArrays, function(key) {\n                    series[key + 'Data'] = [];\n                });\n                series.setData(options.data, false);\n\n                // Mark cartesian\n                if (series.isCartesian) {\n                    chart.hasCartesianSeries = true;\n                }\n\n                // Get the index and register the series in the chart. The index is one\n                // more than the current latest series index (#5960).\n                if (chartSeries.length) {\n                    lastSeries = chartSeries[chartSeries.length - 1];\n                }\n                series._i = pick(lastSeries && lastSeries._i, -1) + 1;\n\n                // Insert the series and re-order all series above the insertion point.\n                chart.orderSeries(this.insert(chartSeries));\n            },\n\n            /**\n             * Insert the series in a collection with other series, either the chart\n             * series or yAxis series, in the correct order according to the index \n             * option.\n             * @param  {Array} collection A collection of series.\n             * @returns {Number} The index of the series in the collection.\n             */\n            insert: function(collection) {\n                var indexOption = this.options.index,\n                    i;\n\n                // Insert by index option\n                if (isNumber(indexOption)) {\n                    i = collection.length;\n                    while (i--) {\n                        // Loop down until the interted element has higher index\n                        if (indexOption >=\n                            pick(collection[i].options.index, collection[i]._i)) {\n                            collection.splice(i + 1, 0, this);\n                            break;\n                        }\n                    }\n                    if (i === -1) {\n                        collection.unshift(this);\n                    }\n                    i = i + 1;\n\n                    // Or just push it to the end\n                } else {\n                    collection.push(this);\n                }\n                return pick(i, collection.length - 1);\n            },\n\n            /**\n             * Set the xAxis and yAxis properties of cartesian series, and register the\n             * series in the `axis.series` array.\n             *\n             * @function #bindAxes\n             * @memberOf Series\n             * @returns {void}\n             */\n            bindAxes: function() {\n                var series = this,\n                    seriesOptions = series.options,\n                    chart = series.chart,\n                    axisOptions;\n\n                // repeat for xAxis and yAxis\n                each(series.axisTypes || [], function(AXIS) {\n\n                    // loop through the chart's axis objects\n                    each(chart[AXIS], function(axis) {\n                        axisOptions = axis.options;\n\n                        // apply if the series xAxis or yAxis option mathches the number\n                        // of the axis, or if undefined, use the first axis\n                        if (\n                            seriesOptions[AXIS] === axisOptions.index ||\n                            (\n                                seriesOptions[AXIS] !== undefined &&\n                                seriesOptions[AXIS] === axisOptions.id\n                            ) ||\n                            (\n                                seriesOptions[AXIS] === undefined &&\n                                axisOptions.index === 0\n                            )\n                        ) {\n\n                            // register this series in the axis.series lookup\n                            series.insert(axis.series);\n\n                            // set this series.xAxis or series.yAxis reference\n                            /**\n                             * Read only. The unique xAxis object associated with the\n                             * series.\n                             *\n                             * @name xAxis\n                             * @memberOf Series\n                             * @type Axis\n                             */\n                            /**\n                             * Read only. The unique yAxis object associated with the\n                             * series.\n                             *\n                             * @name yAxis\n                             * @memberOf Series\n                             * @type Axis\n                             */\n                            series[AXIS] = axis;\n\n                            // mark dirty for redraw\n                            axis.isDirty = true;\n                        }\n                    });\n\n                    // The series needs an X and an Y axis\n                    if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                        H.error(18, true);\n                    }\n\n                });\n            },\n\n            /**\n             * For simple series types like line and column, the data values are held in\n             * arrays like xData and yData for quick lookup to find extremes and more.\n             * For multidimensional series like bubble and map, this can be extended\n             * with arrays like zData and valueData by adding to the\n             * series.parallelArrays array.\n             */\n            updateParallelArrays: function(point, i) {\n                var series = point.series,\n                    args = arguments,\n                    fn = isNumber(i) ?\n                    // Insert the value in the given position\n                    function(key) {\n                        var val = key === 'y' && series.toYData ?\n                            series.toYData(point) :\n                            point[key];\n                        series[key + 'Data'][i] = val;\n                    } :\n                    // Apply the method specified in i with the following arguments\n                    // as arguments\n                    function(key) {\n                        Array.prototype[i].apply(\n                            series[key + 'Data'],\n                            Array.prototype.slice.call(args, 2)\n                        );\n                    };\n\n                each(series.parallelArrays, fn);\n            },\n\n            /**\n             * Return an auto incremented x value based on the pointStart and\n             * pointInterval options. This is only used if an x value is not given for\n             * the point that calls autoIncrement.\n             */\n            autoIncrement: function() {\n\n                var options = this.options,\n                    xIncrement = this.xIncrement,\n                    date,\n                    pointInterval,\n                    pointIntervalUnit = options.pointIntervalUnit;\n\n                xIncrement = pick(xIncrement, options.pointStart, 0);\n\n                this.pointInterval = pointInterval = pick(\n                    this.pointInterval,\n                    options.pointInterval,\n                    1\n                );\n\n                // Added code for pointInterval strings\n                if (pointIntervalUnit) {\n                    date = new Date(xIncrement);\n\n                    if (pointIntervalUnit === 'day') {\n                        date = +date[Date.hcSetDate](\n                            date[Date.hcGetDate]() + pointInterval\n                        );\n                    } else if (pointIntervalUnit === 'month') {\n                        date = +date[Date.hcSetMonth](\n                            date[Date.hcGetMonth]() + pointInterval\n                        );\n                    } else if (pointIntervalUnit === 'year') {\n                        date = +date[Date.hcSetFullYear](\n                            date[Date.hcGetFullYear]() + pointInterval\n                        );\n                    }\n                    pointInterval = date - xIncrement;\n\n                }\n\n                this.xIncrement = xIncrement + pointInterval;\n                return xIncrement;\n            },\n\n            /**\n             * Set the series options by merging from the options tree\n             * @param {Object} itemOptions\n             */\n            setOptions: function(itemOptions) {\n                var chart = this.chart,\n                    chartOptions = chart.options,\n                    plotOptions = chartOptions.plotOptions,\n                    userOptions = chart.userOptions || {},\n                    userPlotOptions = userOptions.plotOptions || {},\n                    typeOptions = plotOptions[this.type],\n                    options,\n                    zones;\n\n                this.userOptions = itemOptions;\n\n                // General series options take precedence over type options because\n                // otherwise, default type options like column.animation would be\n                // overwritten by the general option. But issues have been raised here\n                // (#3881), and the solution may be to distinguish between default\n                // option and userOptions like in the tooltip below.\n                options = merge(\n                    typeOptions,\n                    plotOptions.series,\n                    itemOptions\n                );\n\n                // The tooltip options are merged between global and series specific\n                // options. Importance order asscendingly:\n                // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]\n                // init userOptions with possible later updates: 4-6 like 1-3 and\n                // (7)this series options\n                this.tooltipOptions = merge(\n                    defaultOptions.tooltip, // 1\n                    defaultOptions.plotOptions.series &&\n                    defaultOptions.plotOptions.series.tooltip, // 2\n                    defaultOptions.plotOptions[this.type].tooltip, // 3\n                    chartOptions.tooltip.userOptions, // 4\n                    plotOptions.series && plotOptions.series.tooltip, // 5\n                    plotOptions[this.type].tooltip, // 6\n                    itemOptions.tooltip // 7\n                );\n\n                // When shared tooltip, stickyTracking is true by default,\n                // unless user says otherwise.\n                this.stickyTracking = pick(\n                    itemOptions.stickyTracking,\n                    userPlotOptions[this.type] &&\n                    userPlotOptions[this.type].stickyTracking,\n                    userPlotOptions.series && userPlotOptions.series.stickyTracking,\n                    (\n                        this.tooltipOptions.shared && !this.noSharedTooltip ?\n                        true :\n                        options.stickyTracking\n                    )\n                );\n\n                // Delete marker object if not allowed (#1125)\n                if (typeOptions.marker === null) {\n                    delete options.marker;\n                }\n\n                // Handle color zones\n                this.zoneAxis = options.zoneAxis;\n                zones = this.zones = (options.zones || []).slice();\n                if (\n                    (options.negativeColor || options.negativeFillColor) &&\n                    !options.zones\n                ) {\n                    zones.push({\n                        value: options[this.zoneAxis + 'Threshold'] ||\n                            options.threshold ||\n                            0,\n                        className: 'highcharts-negative',\n\n                        color: options.negativeColor,\n                        fillColor: options.negativeFillColor\n\n                    });\n                }\n                if (zones.length) { // Push one extra zone for the rest\n                    if (defined(zones[zones.length - 1].value)) {\n                        zones.push({\n\n                            color: this.color,\n                            fillColor: this.fillColor\n\n                        });\n                    }\n                }\n                return options;\n            },\n\n            getCyclic: function(prop, value, defaults) {\n                var i,\n                    chart = this.chart,\n                    userOptions = this.userOptions,\n                    indexName = prop + 'Index',\n                    counterName = prop + 'Counter',\n                    len = defaults ? defaults.length : pick(\n                        chart.options.chart[prop + 'Count'],\n                        chart[prop + 'Count']\n                    ),\n                    setting;\n\n                if (!value) {\n                    // Pick up either the colorIndex option, or the _colorIndex after\n                    // Series.update()\n                    setting = pick(\n                        userOptions[indexName],\n                        userOptions['_' + indexName]\n                    );\n                    if (defined(setting)) { // after Series.update()\n                        i = setting;\n                    } else {\n                        // #6138\n                        if (!chart.series.length) {\n                            chart[counterName] = 0;\n                        }\n                        userOptions['_' + indexName] = i = chart[counterName] % len;\n                        chart[counterName] += 1;\n                    }\n                    if (defaults) {\n                        value = defaults[i];\n                    }\n                }\n                // Set the colorIndex\n                if (i !== undefined) {\n                    this[indexName] = i;\n                }\n                this[prop] = value;\n            },\n\n            /**\n             * Get the series' color\n             */\n\n            getColor: function() {\n                if (this.options.colorByPoint) {\n                    // #4359, selected slice got series.color even when colorByPoint was\n                    // set.\n                    this.options.color = null;\n                } else {\n                    this.getCyclic(\n                        'color',\n                        this.options.color || defaultPlotOptions[this.type].color,\n                        this.chart.options.colors\n                    );\n                }\n            },\n\n            /**\n             * Get the series' symbol\n             */\n            getSymbol: function() {\n                var seriesMarkerOption = this.options.marker;\n\n                this.getCyclic(\n                    'symbol',\n                    seriesMarkerOption.symbol,\n                    this.chart.options.symbols\n                );\n            },\n\n            drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n            /**\n             * Apply a new set of data to the series and optionally redraw it. The new\n             * data array is passed by reference (except in case of `updatePoints`), and\n             * may later be mutated when updating the chart data.\n             * \n             * Note the difference in behaviour when setting the same amount of points,\n             * or a different amount of points, as handled by the `updatePoints`\n             * parameter. \n             * \n             * @param  {SeriesDataOptions} data\n             *         Takes an array of data in the same format as described under\n             *         `series<type>data` for the given series type.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw} after.\n             * @param  {AnimationOptions} [animation]\n             *         When the updated data is the same length as the existing data,\n             *         points will be updated by default, and animation visualizes how\n             *         the points are changed. Set false to disable animation, or a\n             *         configuration object to set duration or easing.\n             * @param  {Boolean} [updatePoints=true]\n             *         When the updated data is the same length as the existing data,\n             *         points will be updated instead of replaced. This allows updating\n             *         with animation and performs better. In this case, the original\n             *         array is not passed by reference. Set false to prevent.\n             *\n             * @sample highcharts/members/series-setdata/\n             *         Set new data from a button\n             * @sample highcharts/members/series-setdata-pie/\n             *         Set data in a pie\n             * @sample stock/members/series-setdata/\n             *         Set new data in Highstock\n             * @sample maps/members/series-setdata/\n             *         Set new data in Highmaps\n             */\n            setData: function(data, redraw, animation, updatePoints) {\n                var series = this,\n                    oldData = series.points,\n                    oldDataLength = (oldData && oldData.length) || 0,\n                    dataLength,\n                    options = series.options,\n                    chart = series.chart,\n                    firstPoint = null,\n                    xAxis = series.xAxis,\n                    i,\n                    turboThreshold = options.turboThreshold,\n                    pt,\n                    xData = this.xData,\n                    yData = this.yData,\n                    pointArrayMap = series.pointArrayMap,\n                    valueCount = pointArrayMap && pointArrayMap.length;\n\n                data = data || [];\n                dataLength = data.length;\n                redraw = pick(redraw, true);\n\n                // If the point count is the same as is was, just run Point.update which\n                // is cheaper, allows animation, and keeps references to points.\n                if (\n                    updatePoints !== false &&\n                    dataLength &&\n                    oldDataLength === dataLength &&\n                    !series.cropped &&\n                    !series.hasGroupedData &&\n                    series.visible\n                ) {\n                    each(data, function(point, i) {\n                        // .update doesn't exist on a linked, hidden series (#3709)\n                        if (oldData[i].update && point !== options.data[i]) {\n                            oldData[i].update(point, false, null, false);\n                        }\n                    });\n\n                } else {\n\n                    // Reset properties\n                    series.xIncrement = null;\n\n                    series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n                    // Update parallel arrays\n                    each(this.parallelArrays, function(key) {\n                        series[key + 'Data'].length = 0;\n                    });\n\n                    // In turbo mode, only one- or twodimensional arrays of numbers are\n                    // allowed. The first value is tested, and we assume that all the\n                    // rest are defined the same way. Although the 'for' loops are\n                    // similar, they are repeated inside each if-else conditional for\n                    // max performance.\n                    if (turboThreshold && dataLength > turboThreshold) {\n\n                        // find the first non-null point\n                        i = 0;\n                        while (firstPoint === null && i < dataLength) {\n                            firstPoint = data[i];\n                            i++;\n                        }\n\n\n                        if (isNumber(firstPoint)) { // assume all points are numbers\n                            for (i = 0; i < dataLength; i++) {\n                                xData[i] = this.autoIncrement();\n                                yData[i] = data[i];\n                            }\n\n                            // Assume all points are arrays when first point is\n                        } else if (isArray(firstPoint)) {\n                            if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                                for (i = 0; i < dataLength; i++) {\n                                    pt = data[i];\n                                    xData[i] = pt[0];\n                                    yData[i] = pt.slice(1, valueCount + 1);\n                                }\n                            } else { // [x, y]\n                                for (i = 0; i < dataLength; i++) {\n                                    pt = data[i];\n                                    xData[i] = pt[0];\n                                    yData[i] = pt[1];\n                                }\n                            }\n                        } else {\n                            // Highcharts expects configs to be numbers or arrays in\n                            // turbo mode\n                            H.error(12);\n                        }\n                    } else {\n                        for (i = 0; i < dataLength; i++) {\n                            if (data[i] !== undefined) { // stray commas in oldIE\n                                pt = {\n                                    series: series\n                                };\n                                series.pointClass.prototype.applyOptions.apply(\n                                    pt, [data[i]]\n                                );\n                                series.updateParallelArrays(pt, i);\n                            }\n                        }\n                    }\n\n                    // Forgetting to cast strings to numbers is a common caveat when\n                    // handling CSV or JSON\n                    if (isString(yData[0])) {\n                        H.error(14, true);\n                    }\n\n                    /**\n                     * Read only. An array containing the series' data point objects. To\n                     * modify the data, use {@link Highcharts.Series#setData} or {@link\n                     * Highcharts.Point#update}.\n                     *\n                     * @name data\n                     * @memberOf Highcharts.Series\n                     * @type {Array.<Highcharts.Point>}\n                     */\n                    series.data = [];\n                    series.options.data = series.userOptions.data = data;\n\n                    // destroy old points\n                    i = oldDataLength;\n                    while (i--) {\n                        if (oldData[i] && oldData[i].destroy) {\n                            oldData[i].destroy();\n                        }\n                    }\n\n                    // reset minRange (#878)\n                    if (xAxis) {\n                        xAxis.minRange = xAxis.userMinRange;\n                    }\n\n                    // redraw\n                    series.isDirty = chart.isDirtyBox = true;\n                    series.isDirtyData = !!oldData;\n                    animation = false;\n                }\n\n                // Typically for pie series, points need to be processed and generated\n                // prior to rendering the legend\n                if (options.legendType === 'point') {\n                    this.processData();\n                    this.generatePoints();\n                }\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            },\n\n            /**\n             * Process the data by cropping away unused data points if the series is\n             * longer than the crop threshold. This saves computing time for large\n             * series.\n             */\n            processData: function(force) {\n                var series = this,\n                    processedXData = series.xData, // copied during slice operation\n                    processedYData = series.yData,\n                    dataLength = processedXData.length,\n                    croppedData,\n                    cropStart = 0,\n                    cropped,\n                    distance,\n                    closestPointRange,\n                    xAxis = series.xAxis,\n                    i, // loop variable\n                    options = series.options,\n                    cropThreshold = options.cropThreshold,\n                    getExtremesFromAll =\n                    series.getExtremesFromAll ||\n                    options.getExtremesFromAll, // #4599\n                    isCartesian = series.isCartesian,\n                    xExtremes,\n                    val2lin = xAxis && xAxis.val2lin,\n                    isLog = xAxis && xAxis.isLog,\n                    min,\n                    max;\n\n                // If the series data or axes haven't changed, don't go through this.\n                // Return false to pass the message on to override methods like in data\n                // grouping.\n                if (\n                    isCartesian &&\n                    !series.isDirty &&\n                    !xAxis.isDirty &&\n                    !series.yAxis.isDirty &&\n                    !force\n                ) {\n                    return false;\n                }\n\n                if (xAxis) {\n                    xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n                    min = xExtremes.min;\n                    max = xExtremes.max;\n                }\n\n                // optionally filter out points outside the plot area\n                if (\n                    isCartesian &&\n                    series.sorted &&\n                    !getExtremesFromAll &&\n                    (!cropThreshold || dataLength > cropThreshold || series.forceCrop)\n                ) {\n\n                    // it's outside current extremes\n                    if (\n                        processedXData[dataLength - 1] < min ||\n                        processedXData[0] > max\n                    ) {\n                        processedXData = [];\n                        processedYData = [];\n\n                        // only crop if it's actually spilling out\n                    } else if (\n                        processedXData[0] < min ||\n                        processedXData[dataLength - 1] > max\n                    ) {\n                        croppedData = this.cropData(\n                            series.xData,\n                            series.yData,\n                            min,\n                            max\n                        );\n                        processedXData = croppedData.xData;\n                        processedYData = croppedData.yData;\n                        cropStart = croppedData.start;\n                        cropped = true;\n                    }\n                }\n\n\n                // Find the closest distance between processed points\n                i = processedXData.length || 1;\n                while (--i) {\n                    distance = isLog ?\n                        val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                        processedXData[i] - processedXData[i - 1];\n\n                    if (\n                        distance > 0 &&\n                        (\n                            closestPointRange === undefined ||\n                            distance < closestPointRange\n                        )\n                    ) {\n                        closestPointRange = distance;\n\n                        // Unsorted data is not supported by the line tooltip, as well as\n                        // data grouping and navigation in Stock charts (#725) and width\n                        // calculation of columns (#1900)\n                    } else if (distance < 0 && series.requireSorting) {\n                        H.error(15);\n                    }\n                }\n\n                // Record the properties\n                series.cropped = cropped; // undefined or true\n                series.cropStart = cropStart;\n                series.processedXData = processedXData;\n                series.processedYData = processedYData;\n\n                series.closestPointRange = closestPointRange;\n\n            },\n\n            /**\n             * Iterate over xData and crop values between min and max. Returns object\n             * containing crop start/end cropped xData with corresponding part of yData,\n             * dataMin and dataMax within the cropped range\n             */\n            cropData: function(xData, yData, min, max) {\n                var dataLength = xData.length,\n                    cropStart = 0,\n                    cropEnd = dataLength,\n                    // line-type series need one point outside\n                    cropShoulder = pick(this.cropShoulder, 1),\n                    i,\n                    j;\n\n                // iterate up to find slice start\n                for (i = 0; i < dataLength; i++) {\n                    if (xData[i] >= min) {\n                        cropStart = Math.max(0, i - cropShoulder);\n                        break;\n                    }\n                }\n\n                // proceed to find slice end\n                for (j = i; j < dataLength; j++) {\n                    if (xData[j] > max) {\n                        cropEnd = j + cropShoulder;\n                        break;\n                    }\n                }\n\n                return {\n                    xData: xData.slice(cropStart, cropEnd),\n                    yData: yData.slice(cropStart, cropEnd),\n                    start: cropStart,\n                    end: cropEnd\n                };\n            },\n\n\n            /**\n             * Generate the data point after the data has been processed by cropping\n             * away unused points and optionally grouped in Highcharts Stock.\n             */\n            generatePoints: function() {\n                var series = this,\n                    options = series.options,\n                    dataOptions = options.data,\n                    data = series.data,\n                    dataLength,\n                    processedXData = series.processedXData,\n                    processedYData = series.processedYData,\n                    PointClass = series.pointClass,\n                    processedDataLength = processedXData.length,\n                    cropStart = series.cropStart || 0,\n                    cursor,\n                    hasGroupedData = series.hasGroupedData,\n                    keys = options.keys,\n                    point,\n                    points = [],\n                    i;\n\n                if (!data && !hasGroupedData) {\n                    var arr = [];\n                    arr.length = dataOptions.length;\n                    data = series.data = arr;\n                }\n\n                if (keys && hasGroupedData) {\n                    // grouped data has already applied keys (#6590)\n                    series.options.keys = false;\n                }\n\n                for (i = 0; i < processedDataLength; i++) {\n                    cursor = cropStart + i;\n                    if (!hasGroupedData) {\n                        point = data[cursor];\n                        if (!point && dataOptions[cursor] !== undefined) { // #970\n                            data[cursor] = point = (new PointClass()).init(\n                                series,\n                                dataOptions[cursor],\n                                processedXData[i]\n                            );\n                        }\n                    } else {\n                        // splat the y data in case of ohlc data array\n                        point = (new PointClass()).init(\n                            series, [processedXData[i]].concat(splat(processedYData[i]))\n                        );\n\n                        /**\n                         * Highstock only. If a point object is created by data\n                         * grouping, it doesn't reflect actual points in the raw data.\n                         * In this case, the `dataGroup` property holds information\n                         * that points back to the raw data.\n                         *\n                         * - `dataGroup.start` is the index of the first raw data point\n                         * in the group.\n                         * - `dataGroup.length` is the amount of points in the group.\n                         *\n                         * @name dataGroup\n                         * @memberOf Point\n                         * @type {Object}\n                         * \n                         */\n                        point.dataGroup = series.groupMap[i];\n                    }\n                    if (point) { // #6279\n                        point.index = cursor; // For faster access in Point.update\n                        points[i] = point;\n                    }\n                }\n\n                // restore keys options (#6590)\n                series.options.keys = keys;\n\n                // Hide cropped-away points - this only runs when the number of points\n                // is above cropThreshold, or when swithching view from non-grouped\n                // data to grouped data (#637)\n                if (\n                    data &&\n                    (\n                        processedDataLength !== (dataLength = data.length) ||\n                        hasGroupedData\n                    )\n                ) {\n                    for (i = 0; i < dataLength; i++) {\n                        // when has grouped data, clear all points\n                        if (i === cropStart && !hasGroupedData) {\n                            i += processedDataLength;\n                        }\n                        if (data[i]) {\n                            data[i].destroyElements();\n                            data[i].plotX = undefined; // #1003\n                        }\n                    }\n                }\n\n                series.data = data;\n                series.points = points;\n            },\n\n            /**\n             * Calculate Y extremes for visible data\n             */\n            getExtremes: function(yData) {\n                var xAxis = this.xAxis,\n                    yAxis = this.yAxis,\n                    xData = this.processedXData,\n                    yDataLength,\n                    activeYData = [],\n                    activeCounter = 0,\n                    // #2117, need to compensate for log X axis\n                    xExtremes = xAxis.getExtremes(),\n                    xMin = xExtremes.min,\n                    xMax = xExtremes.max,\n                    validValue,\n                    withinRange,\n                    x,\n                    y,\n                    i,\n                    j;\n\n                yData = yData || this.stackedYData || this.processedYData || [];\n                yDataLength = yData.length;\n\n                for (i = 0; i < yDataLength; i++) {\n\n                    x = xData[i];\n                    y = yData[i];\n\n                    // For points within the visible range, including the first point\n                    // outside the visible range, consider y extremes\n                    validValue =\n                        (isNumber(y, true) || isArray(y)) &&\n                        (!yAxis.positiveValuesOnly || (y.length || y > 0));\n                    withinRange =\n                        this.getExtremesFromAll ||\n                        this.options.getExtremesFromAll ||\n                        this.cropped ||\n                        ((xData[i] || x) >= xMin && (xData[i] || x) <= xMax);\n\n                    if (validValue && withinRange) {\n\n                        j = y.length;\n                        if (j) { // array, like ohlc or range data\n                            while (j--) {\n                                if (y[j] !== null) {\n                                    activeYData[activeCounter++] = y[j];\n                                }\n                            }\n                        } else {\n                            activeYData[activeCounter++] = y;\n                        }\n                    }\n                }\n\n                this.dataMin = arrayMin(activeYData);\n                this.dataMax = arrayMax(activeYData);\n            },\n\n            /**\n             * Translate data points from raw data values to chart specific positioning\n             * data needed later in drawPoints, drawGraph and drawTracker.\n             *\n             * @function #translate\n             * @memberOf Series\n             * @returns {void}\n             */\n            translate: function() {\n                if (!this.processedXData) { // hidden series\n                    this.processData();\n                }\n                this.generatePoints();\n                var series = this,\n                    options = series.options,\n                    stacking = options.stacking,\n                    xAxis = series.xAxis,\n                    categories = xAxis.categories,\n                    yAxis = series.yAxis,\n                    points = series.points,\n                    dataLength = points.length,\n                    hasModifyValue = !!series.modifyValue,\n                    i,\n                    pointPlacement = options.pointPlacement,\n                    dynamicallyPlaced =\n                    pointPlacement === 'between' ||\n                    isNumber(pointPlacement),\n                    threshold = options.threshold,\n                    stackThreshold = options.startFromThreshold ? threshold : 0,\n                    plotX,\n                    plotY,\n                    lastPlotX,\n                    stackIndicator,\n                    closestPointRangePx = Number.MAX_VALUE;\n\n                // Point placement is relative to each series pointRange (#5889)\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                if (isNumber(pointPlacement)) {\n                    pointPlacement *= pick(options.pointRange || xAxis.pointRange);\n                }\n\n                // Translate each point\n                for (i = 0; i < dataLength; i++) {\n                    var point = points[i],\n                        xValue = point.x,\n                        yValue = point.y,\n                        yBottom = point.low,\n                        stack = stacking && yAxis.stacks[(\n                            series.negStacks &&\n                            yValue < (stackThreshold ? 0 : threshold) ? '-' : ''\n                        ) + series.stackKey],\n                        pointStack,\n                        stackValues;\n\n                    // Discard disallowed y values for log axes (#3434)\n                    if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {\n                        point.isNull = true;\n                    }\n\n                    // Get the plotX translation\n                    point.plotX = plotX = correctFloat( // #5236\n                        Math.min(Math.max(-1e5, xAxis.translate(\n                            xValue,\n                            0,\n                            0,\n                            0,\n                            1,\n                            pointPlacement,\n                            this.type === 'flags'\n                        )), 1e5) // #3923\n                    );\n\n                    // Calculate the bottom y value for stacked series\n                    if (\n                        stacking &&\n                        series.visible &&\n                        !point.isNull &&\n                        stack &&\n                        stack[xValue]\n                    ) {\n                        stackIndicator = series.getStackIndicator(\n                            stackIndicator,\n                            xValue,\n                            series.index\n                        );\n                        pointStack = stack[xValue];\n                        stackValues = pointStack.points[stackIndicator.key];\n                        yBottom = stackValues[0];\n                        yValue = stackValues[1];\n\n                        if (\n                            yBottom === stackThreshold &&\n                            stackIndicator.key === stack[xValue].base\n                        ) {\n                            yBottom = pick(threshold, yAxis.min);\n                        }\n                        if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232\n                            yBottom = null;\n                        }\n\n                        point.total = point.stackTotal = pointStack.total;\n                        point.percentage =\n                            pointStack.total &&\n                            (point.y / pointStack.total * 100);\n                        point.stackY = yValue;\n\n                        // Place the stack label\n                        pointStack.setOffset(\n                            series.pointXOffset || 0,\n                            series.barW || 0\n                        );\n\n                    }\n\n                    // Set translated yBottom or remove it\n                    point.yBottom = defined(yBottom) ?\n                        yAxis.translate(yBottom, 0, 1, 0, 1) :\n                        null;\n\n                    // general hook, used for Highstock compare mode\n                    if (hasModifyValue) {\n                        yValue = series.modifyValue(yValue, point);\n                    }\n\n                    // Set the the plotY value, reset it for redraws\n                    point.plotY = plotY =\n                        (typeof yValue === 'number' && yValue !== Infinity) ?\n                        Math.min(Math.max(-1e5,\n                            yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                        undefined;\n\n                    point.isInside =\n                        plotY !== undefined &&\n                        plotY >= 0 &&\n                        plotY <= yAxis.len && // #3519\n                        plotX >= 0 &&\n                        plotX <= xAxis.len;\n\n\n                    // Set client related positions for mouse tracking\n                    point.clientX = dynamicallyPlaced ?\n                        correctFloat(\n                            xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)\n                        ) :\n                        plotX; // #1514, #5383, #5518\n\n                    point.negative = point.y < (threshold || 0);\n\n                    // some API data\n                    point.category = categories && categories[point.x] !== undefined ?\n                        categories[point.x] : point.x;\n\n                    // Determine auto enabling of markers (#3635, #5099)\n                    if (!point.isNull) {\n                        if (lastPlotX !== undefined) {\n                            closestPointRangePx = Math.min(\n                                closestPointRangePx,\n                                Math.abs(plotX - lastPlotX)\n                            );\n                        }\n                        lastPlotX = plotX;\n                    }\n\n                    // Find point zone\n                    point.zone = this.zones.length && point.getZone();\n                }\n                series.closestPointRangePx = closestPointRangePx;\n            },\n\n            /**\n             * Return the series points with null points filtered out\n             */\n            getValidPoints: function(points, insideOnly) {\n                var chart = this.chart;\n                // #3916, #5029, #5085\n                return grep(points || this.points || [], function isValidPoint(point) {\n                    if (insideOnly && !chart.isInsidePlot(\n                            point.plotX,\n                            point.plotY,\n                            chart.inverted\n                        )) {\n                        return false;\n                    }\n                    return !point.isNull;\n                });\n            },\n\n            /**\n             * Set the clipping for the series. For animated series it is called twice,\n             * first to initiate animating the clip then the second time without the\n             * animation to set the final clip.\n             */\n            setClip: function(animation) {\n                var chart = this.chart,\n                    options = this.options,\n                    renderer = chart.renderer,\n                    inverted = chart.inverted,\n                    seriesClipBox = this.clipBox,\n                    clipBox = seriesClipBox || chart.clipBox,\n                    sharedClipKey =\n                    this.sharedClipKey || [\n                        '_sharedClip',\n                        animation && animation.duration,\n                        animation && animation.easing,\n                        clipBox.height,\n                        options.xAxis,\n                        options.yAxis\n                    ].join(','), // #4526\n                    clipRect = chart[sharedClipKey],\n                    markerClipRect = chart[sharedClipKey + 'm'];\n\n                // If a clipping rectangle with the same properties is currently present\n                // in the chart, use that.\n                if (!clipRect) {\n\n                    // When animation is set, prepare the initial positions\n                    if (animation) {\n                        clipBox.width = 0;\n\n                        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(-99, // include the width of the first marker\n                            inverted ? -chart.plotLeft : -chart.plotTop,\n                            99,\n                            inverted ? chart.chartWidth : chart.chartHeight\n                        );\n                    }\n                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n                    // Create hashmap for series indexes\n                    clipRect.count = {\n                        length: 0\n                    };\n\n                }\n                if (animation) {\n                    if (!clipRect.count[this.index]) {\n                        clipRect.count[this.index] = true;\n                        clipRect.count.length += 1;\n                    }\n                }\n\n                if (options.clip !== false) {\n                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n                    this.markerGroup.clip(markerClipRect);\n                    this.sharedClipKey = sharedClipKey;\n                }\n\n                // Remove the shared clipping rectangle when all series are shown\n                if (!animation) {\n                    if (clipRect.count[this.index]) {\n                        delete clipRect.count[this.index];\n                        clipRect.count.length -= 1;\n                    }\n\n                    if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {\n                        if (!seriesClipBox) {\n                            chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                        }\n                        if (chart[sharedClipKey + 'm']) {\n                            chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Animate in the series\n             */\n            animate: function(init) {\n                var series = this,\n                    chart = series.chart,\n                    clipRect,\n                    animation = animObject(series.options.animation),\n                    sharedClipKey;\n\n                // Initialize the animation. Set up the clipping rectangle.\n                if (init) {\n\n                    series.setClip(animation);\n\n                    // Run the animation\n                } else {\n                    sharedClipKey = this.sharedClipKey;\n                    clipRect = chart[sharedClipKey];\n                    if (clipRect) {\n                        clipRect.animate({\n                            width: chart.plotSizeX\n                        }, animation);\n                    }\n                    if (chart[sharedClipKey + 'm']) {\n                        chart[sharedClipKey + 'm'].animate({\n                            width: chart.plotSizeX + 99\n                        }, animation);\n                    }\n\n                    // Delete this function to allow it only once\n                    series.animate = null;\n\n                }\n            },\n\n            /**\n             * This runs after animation to land on the final plot clipping\n             */\n            afterAnimate: function() {\n                this.setClip();\n                fireEvent(this, 'afterAnimate');\n            },\n\n            /**\n             * Draw the markers.\n             *\n             * @function #drawPoints\n             * @memberOf Series\n             * @returns {void}\n             */\n            drawPoints: function() {\n                var series = this,\n                    points = series.points,\n                    chart = series.chart,\n                    plotY,\n                    i,\n                    point,\n                    symbol,\n                    graphic,\n                    options = series.options,\n                    seriesMarkerOptions = options.marker,\n                    pointMarkerOptions,\n                    hasPointMarker,\n                    enabled,\n                    isInside,\n                    markerGroup = series[series.specialGroup] || series.markerGroup,\n                    xAxis = series.xAxis,\n                    markerAttribs,\n                    globallyEnabled = pick(\n                        seriesMarkerOptions.enabled,\n                        xAxis.isRadial ? true : null,\n                        // Use larger or equal as radius is null in bubbles (#6321)\n                        series.closestPointRangePx >= 2 * seriesMarkerOptions.radius\n                    );\n\n                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n                    for (i = 0; i < points.length; i++) {\n                        point = points[i];\n                        plotY = point.plotY;\n                        graphic = point.graphic;\n                        pointMarkerOptions = point.marker || {};\n                        hasPointMarker = !!point.marker;\n                        enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;\n                        isInside = point.isInside;\n\n                        // only draw the point if y is defined\n                        if (enabled && isNumber(plotY) && point.y !== null) {\n\n                            // Shortcuts\n                            symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                            point.hasImage = symbol.indexOf('url') === 0;\n\n                            markerAttribs = series.markerAttribs(\n                                point,\n                                point.selected && 'select'\n                            );\n\n                            if (graphic) { // update\n                                graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                                    .animate(markerAttribs);\n                            } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {\n                                point.graphic = graphic = chart.renderer.symbol(\n                                        symbol,\n                                        markerAttribs.x,\n                                        markerAttribs.y,\n                                        markerAttribs.width,\n                                        markerAttribs.height,\n                                        hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                                    )\n                                    .add(markerGroup);\n                            }\n\n\n                            // Presentational attributes\n                            if (graphic) {\n                                graphic.attr(series.pointAttribs(point, point.selected && 'select'));\n                            }\n\n\n                            if (graphic) {\n                                graphic.addClass(point.getClassName(), true);\n                            }\n\n                        } else if (graphic) {\n                            point.graphic = graphic.destroy(); // #1269\n                        }\n                    }\n                }\n\n            },\n\n            /**\n             * Get non-presentational attributes for the point.\n             */\n            markerAttribs: function(point, state) {\n                var seriesMarkerOptions = this.options.marker,\n                    seriesStateOptions,\n                    pointMarkerOptions = point.marker || {},\n                    pointStateOptions,\n                    radius = pick(\n                        pointMarkerOptions.radius,\n                        seriesMarkerOptions.radius\n                    ),\n                    attribs;\n\n                // Handle hover and select states\n                if (state) {\n                    seriesStateOptions = seriesMarkerOptions.states[state];\n                    pointStateOptions = pointMarkerOptions.states &&\n                        pointMarkerOptions.states[state];\n\n                    radius = pick(\n                        pointStateOptions && pointStateOptions.radius,\n                        seriesStateOptions && seriesStateOptions.radius,\n                        radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)\n                    );\n                }\n\n                if (point.hasImage) {\n                    radius = 0; // and subsequently width and height is not set\n                }\n\n                attribs = {\n                    x: Math.floor(point.plotX) - radius, // Math.floor for #1843\n                    y: point.plotY - radius\n                };\n\n                if (radius) {\n                    attribs.width = attribs.height = 2 * radius;\n                }\n\n                return attribs;\n\n            },\n\n\n            /**\n             * Get presentational attributes for marker-based series (line, spline, scatter, bubble, mappoint...)\n             */\n            pointAttribs: function(point, state) {\n                var seriesMarkerOptions = this.options.marker,\n                    seriesStateOptions,\n                    pointOptions = point && point.options,\n                    pointMarkerOptions = (pointOptions && pointOptions.marker) || {},\n                    pointStateOptions,\n                    color = this.color,\n                    pointColorOption = pointOptions && pointOptions.color,\n                    pointColor = point && point.color,\n                    strokeWidth = pick(\n                        pointMarkerOptions.lineWidth,\n                        seriesMarkerOptions.lineWidth\n                    ),\n                    zoneColor = point && point.zone && point.zone.color,\n                    fill,\n                    stroke;\n\n                color = pointColorOption || zoneColor || pointColor || color;\n                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;\n                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;\n\n                // Handle hover and select states\n                if (state) {\n                    seriesStateOptions = seriesMarkerOptions.states[state];\n                    pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};\n                    strokeWidth = pick(\n                        pointStateOptions.lineWidth,\n                        seriesStateOptions.lineWidth,\n                        strokeWidth + pick(\n                            pointStateOptions.lineWidthPlus,\n                            seriesStateOptions.lineWidthPlus,\n                            0\n                        )\n                    );\n                    fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;\n                    stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;\n                }\n\n                return {\n                    'stroke': stroke,\n                    'stroke-width': strokeWidth,\n                    'fill': fill\n                };\n            },\n\n            /**\n             * Clear DOM objects and free up memory\n             */\n            destroy: function() {\n                var series = this,\n                    chart = series.chart,\n                    issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n                    destroy,\n                    i,\n                    data = series.data || [],\n                    point,\n                    axis;\n\n                // add event hook\n                fireEvent(series, 'destroy');\n\n                // remove all events\n                removeEvent(series);\n\n                // erase from axes\n                each(series.axisTypes || [], function(AXIS) {\n                    axis = series[AXIS];\n                    if (axis && axis.series) {\n                        erase(axis.series, series);\n                        axis.isDirty = axis.forceRedraw = true;\n                    }\n                });\n\n                // remove legend items\n                if (series.legendItem) {\n                    series.chart.legend.destroyItem(series);\n                }\n\n                // destroy all points with their elements\n                i = data.length;\n                while (i--) {\n                    point = data[i];\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n                series.points = null;\n\n                // Clear the animation timeout if we are destroying the series during initial animation\n                clearTimeout(series.animationTimeout);\n\n                // Destroy all SVGElements associated to the series\n                objectEach(series, function(val, prop) {\n                    if (val instanceof SVGElement && !val.survive) { // Survive provides a hook for not destroying\n\n                        // issue 134 workaround\n                        destroy = issue134 && prop === 'group' ?\n                            'hide' :\n                            'destroy';\n\n                        val[destroy]();\n                    }\n                });\n\n                // remove from hoverSeries\n                if (chart.hoverSeries === series) {\n                    chart.hoverSeries = null;\n                }\n                erase(chart.series, series);\n                chart.orderSeries();\n\n                // clear all members\n                objectEach(series, function(val, prop) {\n                    delete series[prop];\n                });\n            },\n\n            /**\n             * Get the graph path\n             */\n            getGraphPath: function(points, nullsAsZeroes, connectCliffs) {\n                var series = this,\n                    options = series.options,\n                    step = options.step,\n                    reversed,\n                    graphPath = [],\n                    xMap = [],\n                    gap;\n\n                points = points || series.points;\n\n                // Bottom of a stack is reversed\n                reversed = points.reversed;\n                if (reversed) {\n                    points.reverse();\n                }\n                // Reverse the steps (#5004)\n                step = {\n                    right: 1,\n                    center: 2\n                }[step] || (step && 3);\n                if (step && reversed) {\n                    step = 4 - step;\n                }\n\n                // Remove invalid points, especially in spline (#5015)\n                if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n                    points = this.getValidPoints(points);\n                }\n\n                // Build the line\n                each(points, function(point, i) {\n\n                    var plotX = point.plotX,\n                        plotY = point.plotY,\n                        lastPoint = points[i - 1],\n                        pathToPoint; // the path to this point from the previous\n\n                    if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                        gap = true; // ... and continue\n                    }\n\n                    // Line series, nullsAsZeroes is not handled\n                    if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                        gap = !options.connectNulls;\n\n                        // Area series, nullsAsZeroes is set\n                    } else if (point.isNull && !nullsAsZeroes) {\n                        gap = true;\n\n                    } else {\n\n                        if (i === 0 || gap) {\n                            pathToPoint = ['M', point.plotX, point.plotY];\n\n                        } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n\n                            pathToPoint = series.getPointSpline(points, point, i);\n\n                        } else if (step) {\n\n                            if (step === 1) { // right\n                                pathToPoint = [\n                                    'L',\n                                    lastPoint.plotX,\n                                    plotY\n                                ];\n\n                            } else if (step === 2) { // center\n                                pathToPoint = [\n                                    'L',\n                                    (lastPoint.plotX + plotX) / 2,\n                                    lastPoint.plotY,\n                                    'L',\n                                    (lastPoint.plotX + plotX) / 2,\n                                    plotY\n                                ];\n\n                            } else {\n                                pathToPoint = [\n                                    'L',\n                                    plotX,\n                                    lastPoint.plotY\n                                ];\n                            }\n                            pathToPoint.push('L', plotX, plotY);\n\n                        } else {\n                            // normal line to next point\n                            pathToPoint = [\n                                'L',\n                                plotX,\n                                plotY\n                            ];\n                        }\n\n                        // Prepare for animation. When step is enabled, there are two path nodes for each x value.\n                        xMap.push(point.x);\n                        if (step) {\n                            xMap.push(point.x);\n                        }\n\n                        graphPath.push.apply(graphPath, pathToPoint);\n                        gap = false;\n                    }\n                });\n\n                graphPath.xMap = xMap;\n                series.graphPath = graphPath;\n\n                return graphPath;\n\n            },\n\n            /**\n             * Draw the actual graph\n             */\n            drawGraph: function() {\n                var series = this,\n                    options = this.options,\n                    graphPath = (this.gappedPath || this.getGraphPath).call(this),\n                    props = [\n                        [\n                            'graph',\n                            'highcharts-graph',\n\n                            options.lineColor || this.color,\n                            options.dashStyle\n\n                        ]\n                    ];\n\n                // Add the zone properties if any\n                each(this.zones, function(zone, i) {\n                    props.push([\n                        'zone-graph-' + i,\n                        'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),\n\n                        zone.color || series.color,\n                        zone.dashStyle || options.dashStyle\n\n                    ]);\n                });\n\n                // Draw the graph\n                each(props, function(prop, i) {\n                    var graphKey = prop[0],\n                        graph = series[graphKey],\n                        attribs;\n\n                    if (graph) {\n                        graph.endX = graphPath.xMap;\n                        graph.animate({\n                            d: graphPath\n                        });\n\n                    } else if (graphPath.length) { // #1487\n\n                        series[graphKey] = series.chart.renderer.path(graphPath)\n                            .addClass(prop[1])\n                            .attr({\n                                zIndex: 1\n                            }) // #1069\n                            .add(series.group);\n\n\n                        attribs = {\n                            'stroke': prop[2],\n                            'stroke-width': options.lineWidth,\n                            'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph\n                        };\n\n                        if (prop[3]) {\n                            attribs.dashstyle = prop[3];\n                        } else if (options.linecap !== 'square') {\n                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                        }\n\n                        graph = series[graphKey]\n                            .attr(attribs)\n                            .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n\n                    }\n\n                    // Helpers for animation\n                    if (graph) {\n                        graph.startX = graphPath.xMap;\n                        //graph.shiftUnit = options.step ? 2 : 1;\n                        graph.isArea = graphPath.isArea; // For arearange animation\n                    }\n                });\n            },\n\n            /**\n             * Clip the graphs into the positive and negative coloured graphs\n             */\n            applyZones: function() {\n                var series = this,\n                    chart = this.chart,\n                    renderer = chart.renderer,\n                    zones = this.zones,\n                    translatedFrom,\n                    translatedTo,\n                    clips = this.clips || [],\n                    clipAttr,\n                    graph = this.graph,\n                    area = this.area,\n                    chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n                    axis = this[(this.zoneAxis || 'y') + 'Axis'],\n                    extremes,\n                    reversed,\n                    inverted = chart.inverted,\n                    horiz,\n                    pxRange,\n                    pxPosMin,\n                    pxPosMax,\n                    ignoreZones = false;\n\n                if (zones.length && (graph || area) && axis && axis.min !== undefined) {\n                    reversed = axis.reversed;\n                    horiz = axis.horiz;\n                    // The use of the Color Threshold assumes there are no gaps\n                    // so it is safe to hide the original graph and area\n                    if (graph) {\n                        graph.hide();\n                    }\n                    if (area) {\n                        area.hide();\n                    }\n\n                    // Create the clips\n                    extremes = axis.getExtremes();\n                    each(zones, function(threshold, i) {\n\n                        translatedFrom = reversed ?\n                            (horiz ? chart.plotWidth : 0) :\n                            (horiz ? 0 : axis.toPixels(extremes.min));\n                        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n                        if (ignoreZones) {\n                            translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                        }\n\n                        pxRange = Math.abs(translatedFrom - translatedTo);\n                        pxPosMin = Math.min(translatedFrom, translatedTo);\n                        pxPosMax = Math.max(translatedFrom, translatedTo);\n                        if (axis.isXAxis) {\n                            clipAttr = {\n                                x: inverted ? pxPosMax : pxPosMin,\n                                y: 0,\n                                width: pxRange,\n                                height: chartSizeMax\n                            };\n                            if (!horiz) {\n                                clipAttr.x = chart.plotHeight - clipAttr.x;\n                            }\n                        } else {\n                            clipAttr = {\n                                x: 0,\n                                y: inverted ? pxPosMax : pxPosMin,\n                                width: chartSizeMax,\n                                height: pxRange\n                            };\n                            if (horiz) {\n                                clipAttr.y = chart.plotWidth - clipAttr.y;\n                            }\n                        }\n\n\n                        /// VML SUPPPORT\n                        if (inverted && renderer.isVML) {\n                            if (axis.isXAxis) {\n                                clipAttr = {\n                                    x: 0,\n                                    y: reversed ? pxPosMin : pxPosMax,\n                                    height: clipAttr.width,\n                                    width: chart.chartWidth\n                                };\n                            } else {\n                                clipAttr = {\n                                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                                    y: 0,\n                                    width: clipAttr.height,\n                                    height: chart.chartHeight\n                                };\n                            }\n                        }\n                        /// END OF VML SUPPORT\n\n\n                        if (clips[i]) {\n                            clips[i].animate(clipAttr);\n                        } else {\n                            clips[i] = renderer.clipRect(clipAttr);\n\n                            if (graph) {\n                                series['zone-graph-' + i].clip(clips[i]);\n                            }\n\n                            if (area) {\n                                series['zone-area-' + i].clip(clips[i]);\n                            }\n                        }\n                        // if this zone extends out of the axis, ignore the others\n                        ignoreZones = threshold.value > extremes.max;\n                    });\n                    this.clips = clips;\n                }\n            },\n\n            /**\n             * Initialize and perform group inversion on series.group and series.markerGroup\n             */\n            invertGroups: function(inverted) {\n                var series = this,\n                    chart = series.chart,\n                    remover;\n\n                function setInvert() {\n                    each(['group', 'markerGroup'], function(groupName) {\n                        if (series[groupName]) {\n\n                            // VML/HTML needs explicit attributes for flipping\n                            if (chart.renderer.isVML) {\n                                series[groupName].attr({\n                                    width: series.yAxis.len,\n                                    height: series.xAxis.len\n                                });\n                            }\n\n                            series[groupName].width = series.yAxis.len;\n                            series[groupName].height = series.xAxis.len;\n                            series[groupName].invert(inverted);\n                        }\n                    });\n                }\n\n                // Pie, go away (#1736)\n                if (!series.xAxis) {\n                    return;\n                }\n\n                // A fixed size is needed for inversion to work\n                remover = addEvent(chart, 'resize', setInvert);\n                addEvent(series, 'destroy', remover);\n\n                // Do it now\n                setInvert(inverted); // do it now\n\n                // On subsequent render and redraw, just do setInvert without setting up events again\n                series.invertGroups = setInvert;\n            },\n\n            /**\n             * General abstraction for creating plot groups like series.group,\n             * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the\n             * group will only be adjusted to the updated plot size.\n             */\n            plotGroup: function(prop, name, visibility, zIndex, parent) {\n                var group = this[prop],\n                    isNew = !group;\n\n                // Generate it on first call\n                if (isNew) {\n                    this[prop] = group = this.chart.renderer.g()\n                        .attr({\n                            zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n                        })\n                        .add(parent);\n\n                }\n\n                // Add the class names, and replace existing ones as response to\n                // Series.update (#6660)\n                group.addClass(\n                    (\n                        'highcharts-' + name +\n                        ' highcharts-series-' + this.index +\n                        ' highcharts-' + this.type + '-series ' +\n                        'highcharts-color-' + this.colorIndex + ' ' +\n                        (this.options.className || '')\n                    ),\n                    true\n                );\n\n                // Place it on first and subsequent (redraw) calls\n                group.attr({\n                    visibility: visibility\n                })[isNew ? 'attr' : 'animate'](\n                    this.getPlotBox()\n                );\n                return group;\n            },\n\n            /**\n             * Get the translation and scale for the plot area of this series\n             */\n            getPlotBox: function() {\n                var chart = this.chart,\n                    xAxis = this.xAxis,\n                    yAxis = this.yAxis;\n\n                // Swap axes for inverted (#2339)\n                if (chart.inverted) {\n                    xAxis = yAxis;\n                    yAxis = this.xAxis;\n                }\n                return {\n                    translateX: xAxis ? xAxis.left : chart.plotLeft,\n                    translateY: yAxis ? yAxis.top : chart.plotTop,\n                    scaleX: 1, // #1623\n                    scaleY: 1\n                };\n            },\n\n            /**\n             * Render the graph and markers\n             */\n            render: function() {\n                var series = this,\n                    chart = series.chart,\n                    group,\n                    options = series.options,\n                    // Animation doesn't work in IE8 quirks when the group div is\n                    // hidden, and looks bad in other oldIE\n                    animDuration = (!!series.animate &&\n                        chart.renderer.isSVG &&\n                        animObject(options.animation).duration\n                    ),\n                    visibility = series.visible ? 'inherit' : 'hidden', // #2597\n                    zIndex = options.zIndex,\n                    hasRendered = series.hasRendered,\n                    chartSeriesGroup = chart.seriesGroup,\n                    inverted = chart.inverted;\n\n                // the group\n                group = series.plotGroup(\n                    'group',\n                    'series',\n                    visibility,\n                    zIndex,\n                    chartSeriesGroup\n                );\n\n                series.markerGroup = series.plotGroup(\n                    'markerGroup',\n                    'markers',\n                    visibility,\n                    zIndex,\n                    chartSeriesGroup\n                );\n\n                // initiate the animation\n                if (animDuration) {\n                    series.animate(true);\n                }\n\n                // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n                group.inverted = series.isCartesian ? inverted : false;\n\n                // draw the graph if any\n                if (series.drawGraph) {\n                    series.drawGraph();\n                    series.applyZones();\n                }\n\n                /*\t\teach(series.points, function (point) {\n                \t\t\tif (point.redraw) {\n                \t\t\t\tpoint.redraw();\n                \t\t\t}\n                \t\t});*/\n\n                // draw the data labels (inn pies they go before the points)\n                if (series.drawDataLabels) {\n                    series.drawDataLabels();\n                }\n\n                // draw the points\n                if (series.visible) {\n                    series.drawPoints();\n                }\n\n\n                // draw the mouse tracking area\n                if (\n                    series.drawTracker &&\n                    series.options.enableMouseTracking !== false\n                ) {\n                    series.drawTracker();\n                }\n\n                // Handle inverted series and tracker groups\n                series.invertGroups(inverted);\n\n                // Initial clipping, must be defined after inverting groups for VML.\n                // Applies to columns etc. (#3839).\n                if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n                    group.clip(chart.clipRect);\n                }\n\n                // Run the animation\n                if (animDuration) {\n                    series.animate();\n                }\n\n                // Call the afterAnimate function on animation complete (but don't\n                // overwrite the animation.complete option which should be available to\n                // the user).\n                if (!hasRendered) {\n                    series.animationTimeout = syncTimeout(function() {\n                        series.afterAnimate();\n                    }, animDuration);\n                }\n\n                series.isDirty = false; // means data is in accordance with what you see\n                // (See #322) series.isDirty = series.isDirtyData = false; // means\n                // data is in accordance with what you see\n                series.hasRendered = true;\n            },\n\n            /**\n             * Redraw the series after an update in the axes.\n             */\n            redraw: function() {\n                var series = this,\n                    chart = series.chart,\n                    // cache it here as it is set to false in render, but used after\n                    wasDirty = series.isDirty || series.isDirtyData,\n                    group = series.group,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis;\n\n                // reposition on resize\n                if (group) {\n                    if (chart.inverted) {\n                        group.attr({\n                            width: chart.plotWidth,\n                            height: chart.plotHeight\n                        });\n                    }\n\n                    group.animate({\n                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                        translateY: pick(yAxis && yAxis.top, chart.plotTop)\n                    });\n                }\n\n                series.translate();\n                series.render();\n                if (wasDirty) { // #3868, #3945\n                    delete this.kdTree;\n                }\n            },\n\n            /**\n             * KD Tree && PointSearching Implementation\n             */\n\n            kdAxisArray: ['clientX', 'plotY'],\n\n            searchPoint: function(e, compareX) {\n                var series = this,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    inverted = series.chart.inverted;\n\n                return this.searchKDTree({\n                    clientX: inverted ?\n                        xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n                    plotY: inverted ?\n                        yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n                }, compareX);\n            },\n\n            /**\n             * Build the k-d-tree that is used by mouse and touch interaction to get the\n             * closest point. Line-like series typically have a one-dimensional tree \n             * where points are searched along the X axis, while scatter-like series\n             * typically search in two dimensions, X and Y.\n             */\n            buildKDTree: function() {\n\n                // Prevent multiple k-d-trees from being built simultaneously (#6235)\n                this.buildingKdTree = true;\n\n                var series = this,\n                    dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                    2 : 1;\n\n                // Internal function\n                function _kdtree(points, depth, dimensions) {\n                    var axis,\n                        median,\n                        length = points && points.length;\n\n                    if (length) {\n\n                        // alternate between the axis\n                        axis = series.kdAxisArray[depth % dimensions];\n\n                        // sort point array\n                        points.sort(function(a, b) {\n                            return a[axis] - b[axis];\n                        });\n\n                        median = Math.floor(length / 2);\n\n                        // build and return nod\n                        return {\n                            point: points[median],\n                            left: _kdtree(\n                                points.slice(0, median), depth + 1, dimensions\n                            ),\n                            right: _kdtree(\n                                points.slice(median + 1), depth + 1, dimensions\n                            )\n                        };\n\n                    }\n                }\n\n                // Start the recursive build process with a clone of the points array\n                // and null points filtered out (#3873)\n                function startRecursive() {\n                    series.kdTree = _kdtree(\n                        series.getValidPoints(\n                            null,\n                            // For line-type series restrict to plot area, but\n                            // column-type series not (#3916, #4511)\n                            !series.directTouch\n                        ),\n                        dimensions,\n                        dimensions\n                    );\n                    series.buildingKdTree = false;\n                }\n                delete series.kdTree;\n\n                // For testing tooltips, don't build async\n                syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n            },\n\n            searchKDTree: function(point, compareX) {\n                var series = this,\n                    kdX = this.kdAxisArray[0],\n                    kdY = this.kdAxisArray[1],\n                    kdComparer = compareX ? 'distX' : 'dist',\n                    kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                    2 : 1;\n\n                // Set the one and two dimensional distance on the point object\n                function setDistance(p1, p2) {\n                    var x = (defined(p1[kdX]) && defined(p2[kdX])) ?\n                        Math.pow(p1[kdX] - p2[kdX], 2) :\n                        null,\n                        y = (defined(p1[kdY]) && defined(p2[kdY])) ?\n                        Math.pow(p1[kdY] - p2[kdY], 2) :\n                        null,\n                        r = (x || 0) + (y || 0);\n\n                    p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n                    p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n                }\n\n                function _search(search, tree, depth, dimensions) {\n                    var point = tree.point,\n                        axis = series.kdAxisArray[depth % dimensions],\n                        tdist,\n                        sideA,\n                        sideB,\n                        ret = point,\n                        nPoint1,\n                        nPoint2;\n\n                    setDistance(search, point);\n\n                    // Pick side based on distance to splitting point\n                    tdist = search[axis] - point[axis];\n                    sideA = tdist < 0 ? 'left' : 'right';\n                    sideB = tdist < 0 ? 'right' : 'left';\n\n                    // End of tree\n                    if (tree[sideA]) {\n                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n                    }\n                    if (tree[sideB]) {\n                        // compare distance to current best to splitting point to decide\n                        // wether to check side B or not\n                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                            nPoint2 = _search(\n                                search,\n                                tree[sideB],\n                                depth + 1,\n                                dimensions\n                            );\n                            ret = nPoint2[kdComparer] < ret[kdComparer] ?\n                                nPoint2 :\n                                ret;\n                        }\n                    }\n\n                    return ret;\n                }\n\n                if (!this.kdTree && !this.buildingKdTree) {\n                    this.buildKDTree();\n                }\n\n                if (this.kdTree) {\n                    return _search(point, this.kdTree, kdDimensions, kdDimensions);\n                }\n            }\n\n        }); // end Series prototype\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            Chart = H.Chart,\n            correctFloat = H.correctFloat,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            format = H.format,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Series = H.Series;\n\n        /**\n         * The class for stacks. Each stack, on a specific X value and either negative\n         * or positive, has its own stack item.\n         *\n         * @class\n         */\n        function StackItem(axis, options, isNegative, x, stackOption) {\n\n            var inverted = axis.chart.inverted;\n\n            this.axis = axis;\n\n            // Tells if the stack is negative\n            this.isNegative = isNegative;\n\n            // Save the options to be able to style the label\n            this.options = options;\n\n            // Save the x value to be able to position the label later\n            this.x = x;\n\n            // Initialize total value\n            this.total = null;\n\n            // This will keep each points' extremes stored by series.index and point \n            // index\n            this.points = {};\n\n            // Save the stack option on the series configuration object, and whether to \n            // treat it as percent\n            this.stack = stackOption;\n            this.leftCliff = 0;\n            this.rightCliff = 0;\n\n            // The align options and text align varies on whether the stack is negative \n            // and if the chart is inverted or not.\n            // First test the user supplied value, then use the dynamic.\n            this.alignOptions = {\n                align: options.align ||\n                    (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n                verticalAlign: options.verticalAlign ||\n                    (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n                y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n                x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n            };\n\n            this.textAlign = options.textAlign ||\n                (inverted ? (isNegative ? 'right' : 'left') : 'center');\n        }\n\n        StackItem.prototype = {\n            destroy: function() {\n                destroyObjectProperties(this, this.axis);\n            },\n\n            /**\n             * Renders the stack total label and adds it to the stack label group.\n             */\n            render: function(group) {\n                var options = this.options,\n                    formatOption = options.format,\n                    str = formatOption ?\n                    format(formatOption, this) :\n                    options.formatter.call(this); // format the text in the label\n\n                // Change the text to reflect the new total and set visibility to hidden\n                // in case the serie is hidden\n                if (this.label) {\n                    this.label.attr({\n                        text: str,\n                        visibility: 'hidden'\n                    });\n                    // Create new label\n                } else {\n                    this.label =\n                        this.axis.chart.renderer.text(str, null, null, options.useHTML)\n                        .css(options.style)\n                        .attr({\n                            align: this.textAlign,\n                            rotation: options.rotation,\n                            visibility: 'hidden' // hidden until setOffset is called\n                        })\n                        .add(group); // add to the labels-group\n                }\n            },\n\n            /**\n             * Sets the offset that the stack has from the x value and repositions the\n             * label.\n             */\n            setOffset: function(xOffset, xWidth) {\n                var stackItem = this,\n                    axis = stackItem.axis,\n                    chart = axis.chart,\n                    inverted = chart.inverted,\n                    reversed = axis.reversed,\n                    neg = (this.isNegative && !reversed) ||\n                    (!this.isNegative && reversed), // #4056\n                    // stack value translated mapped to chart coordinates\n                    y = axis.translate(\n                        axis.usePercentage ? 100 : this.total,\n                        0,\n                        0,\n                        0,\n                        1\n                    ),\n                    yZero = axis.translate(0), // stack origin\n                    h = Math.abs(y - yZero), // stack height\n                    x = chart.xAxis[0].translate(this.x) + xOffset, // stack x position\n                    plotHeight = chart.plotHeight,\n                    stackBox = { // this is the box for the complete stack\n                        x: inverted ? (neg ? y : y - h) : x,\n                        y: inverted ?\n                            plotHeight - x - xWidth : (neg ? (plotHeight - y - h) :\n                                plotHeight - y),\n                        width: inverted ? h : xWidth,\n                        height: inverted ? xWidth : h\n                    },\n                    label = this.label,\n                    alignAttr;\n\n                if (label) {\n                    // Align the label to the box\n                    label.align(this.alignOptions, null, stackBox);\n\n                    // Set visibility (#678)\n                    alignAttr = label.alignAttr;\n                    label[\n                        this.options.crop === false || chart.isInsidePlot(\n                            alignAttr.x,\n                            alignAttr.y\n                        ) ? 'show' : 'hide'](true);\n                }\n            }\n        };\n\n        /**\n         * Generate stacks for each series and calculate stacks total values\n         */\n        Chart.prototype.getStacks = function() {\n            var chart = this;\n\n            // reset stacks for each yAxis\n            each(chart.yAxis, function(axis) {\n                if (axis.stacks && axis.hasVisibleSeries) {\n                    axis.oldStacks = axis.stacks;\n                }\n            });\n\n            each(chart.series, function(series) {\n                if (series.options.stacking && (series.visible === true ||\n                        chart.options.chart.ignoreHiddenSeries === false)) {\n                    series.stackKey = series.type + pick(series.options.stack, '');\n                }\n            });\n        };\n\n\n        // Stacking methods defined on the Axis prototype\n\n        /**\n         * Build the stacks from top down\n         */\n        Axis.prototype.buildStacks = function() {\n            var axisSeries = this.series,\n                series,\n                reversedStacks = pick(this.options.reversedStacks, true),\n                len = axisSeries.length,\n                i;\n            if (!this.isXAxis) {\n                this.usePercentage = false;\n                i = len;\n                while (i--) {\n                    axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n                }\n\n                i = len;\n                while (i--) {\n                    series = axisSeries[reversedStacks ? i : len - i - 1];\n                    if (series.setStackCliffs) {\n                        series.setStackCliffs();\n                    }\n                }\n                // Loop up again to compute percent stack\n                if (this.usePercentage) {\n                    for (i = 0; i < len; i++) {\n                        axisSeries[i].setPercentStacks();\n                    }\n                }\n            }\n        };\n\n        Axis.prototype.renderStackTotals = function() {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                stacks = axis.stacks,\n                stackTotalGroup = axis.stackTotalGroup;\n\n            // Create a separate group for the stack total labels\n            if (!stackTotalGroup) {\n                axis.stackTotalGroup = stackTotalGroup =\n                    renderer.g('stack-labels')\n                    .attr({\n                        visibility: 'visible',\n                        zIndex: 6\n                    })\n                    .add();\n            }\n\n            // plotLeft/Top will change when y axis gets wider so we need to translate\n            // the stackTotalGroup at every render call. See bug #506 and #516\n            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n            // Render each stack total\n            objectEach(stacks, function(type) {\n                objectEach(type, function(stack) {\n                    stack.render(stackTotalGroup);\n                });\n            });\n        };\n\n        /**\n         * Set all the stacks to initial states and destroy unused ones.\n         */\n        Axis.prototype.resetStacks = function() {\n            var axis = this,\n                stacks = axis.stacks;\n            if (!axis.isXAxis) {\n                objectEach(stacks, function(type) {\n                    objectEach(type, function(stack, key) {\n                        // Clean up memory after point deletion (#1044, #4320)\n                        if (stack.touched < axis.stacksTouched) {\n                            stack.destroy();\n                            delete type[key];\n\n                            // Reset stacks\n                        } else {\n                            stack.total = null;\n                            stack.cum = null;\n                        }\n                    });\n                });\n            }\n        };\n\n        Axis.prototype.cleanStacks = function() {\n            var stacks;\n\n            if (!this.isXAxis) {\n                if (this.oldStacks) {\n                    stacks = this.stacks = this.oldStacks;\n                }\n\n                // reset stacks\n                objectEach(stacks, function(type) {\n                    objectEach(type, function(stack) {\n                        stack.cum = stack.total;\n                    });\n                });\n            }\n        };\n\n\n        // Stacking methods defnied for Series prototype\n\n        /**\n         * Adds series' points value to corresponding stack\n         */\n        Series.prototype.setStackedPoints = function() {\n            if (!this.options.stacking || (this.visible !== true &&\n                    this.chart.options.chart.ignoreHiddenSeries !== false)) {\n                return;\n            }\n\n            var series = this,\n                xData = series.processedXData,\n                yData = series.processedYData,\n                stackedYData = [],\n                yDataLength = yData.length,\n                seriesOptions = series.options,\n                threshold = seriesOptions.threshold,\n                stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n                stackOption = seriesOptions.stack,\n                stacking = seriesOptions.stacking,\n                stackKey = series.stackKey,\n                negKey = '-' + stackKey,\n                negStacks = series.negStacks,\n                yAxis = series.yAxis,\n                stacks = yAxis.stacks,\n                oldStacks = yAxis.oldStacks,\n                stackIndicator,\n                isNegative,\n                stack,\n                other,\n                key,\n                pointKey,\n                i,\n                x,\n                y;\n\n\n            yAxis.stacksTouched += 1;\n\n            // loop over the non-null y values and read them into a local array\n            for (i = 0; i < yDataLength; i++) {\n                x = xData[i];\n                y = yData[i];\n                stackIndicator = series.getStackIndicator(\n                    stackIndicator,\n                    x,\n                    series.index\n                );\n                pointKey = stackIndicator.key;\n                // Read stacked values into a stack based on the x value,\n                // the sign of y and the stack key. Stacking is also handled for null\n                // values (#739)\n                isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n                key = isNegative ? negKey : stackKey;\n\n                // Create empty object for this stack if it doesn't exist yet\n                if (!stacks[key]) {\n                    stacks[key] = {};\n                }\n\n                // Initialize StackItem for this x\n                if (!stacks[key][x]) {\n                    if (oldStacks[key] && oldStacks[key][x]) {\n                        stacks[key][x] = oldStacks[key][x];\n                        stacks[key][x].total = null;\n                    } else {\n                        stacks[key][x] = new StackItem(\n                            yAxis,\n                            yAxis.options.stackLabels,\n                            isNegative,\n                            x,\n                            stackOption\n                        );\n                    }\n                }\n\n                // If the StackItem doesn't exist, create it first\n                stack = stacks[key][x];\n                if (y !== null) {\n                    stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];\n\n                    // Record the base of the stack\n                    if (!defined(stack.cum)) {\n                        stack.base = pointKey;\n                    }\n                    stack.touched = yAxis.stacksTouched;\n\n\n                    // In area charts, if there are multiple points on the same X value,\n                    // let the area fill the full span of those points\n                    if (stackIndicator.index > 0 && series.singleStacks === false) {\n                        stack.points[pointKey][0] =\n                            stack.points[series.index + ',' + x + ',0'][0];\n                    }\n                }\n\n                // Add value to the stack total\n                if (stacking === 'percent') {\n\n                    // Percent stacked column, totals are the same for the positive and\n                    // negative stacks\n                    other = isNegative ? stackKey : negKey;\n                    if (negStacks && stacks[other] && stacks[other][x]) {\n                        other = stacks[other][x];\n                        stack.total = other.total =\n                            Math.max(other.total, stack.total) + Math.abs(y) || 0;\n\n                        // Percent stacked areas\n                    } else {\n                        stack.total = correctFloat(stack.total + (Math.abs(y) || 0));\n                    }\n                } else {\n                    stack.total = correctFloat(stack.total + (y || 0));\n                }\n\n                stack.cum = pick(stack.cum, stackThreshold) + (y || 0);\n\n                if (y !== null) {\n                    stack.points[pointKey].push(stack.cum);\n                    stackedYData[i] = stack.cum;\n                }\n\n            }\n\n            if (stacking === 'percent') {\n                yAxis.usePercentage = true;\n            }\n\n            this.stackedYData = stackedYData; // To be used in getExtremes\n\n            // Reset old stacks\n            yAxis.oldStacks = {};\n        };\n\n        /**\n         * Iterate over all stacks and compute the absolute values to percent\n         */\n        Series.prototype.setPercentStacks = function() {\n            var series = this,\n                stackKey = series.stackKey,\n                stacks = series.yAxis.stacks,\n                processedXData = series.processedXData,\n                stackIndicator;\n\n            each([stackKey, '-' + stackKey], function(key) {\n                var i = processedXData.length,\n                    x,\n                    stack,\n                    pointExtremes,\n                    totalFactor;\n\n                while (i--) {\n                    x = processedXData[i];\n                    stackIndicator = series.getStackIndicator(\n                        stackIndicator,\n                        x,\n                        series.index,\n                        key\n                    );\n                    stack = stacks[key] && stacks[key][x];\n                    pointExtremes = stack && stack.points[stackIndicator.key];\n                    if (pointExtremes) {\n                        totalFactor = stack.total ? 100 / stack.total : 0;\n                        // Y bottom value\n                        pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);\n                        // Y value\n                        pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);\n                        series.stackedYData[i] = pointExtremes[1];\n                    }\n                }\n            });\n        };\n\n        /**\n         * Get stack indicator, according to it's x-value, to determine points with the\n         * same x-value\n         */\n        Series.prototype.getStackIndicator = function(stackIndicator, x, index, key) {\n            // Update stack indicator, when:\n            // first point in a stack || x changed || stack type (negative vs positive)\n            // changed:\n            if (!defined(stackIndicator) || stackIndicator.x !== x ||\n                (key && stackIndicator.key !== key)) {\n                stackIndicator = {\n                    x: x,\n                    index: 0,\n                    key: key\n                };\n            } else {\n                stackIndicator.index++;\n            }\n\n            stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n            return stackIndicator;\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            inArray = H.inArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            isArray = H.isArray,\n            merge = H.merge,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            setAnimation = H.setAnimation,\n            splat = H.splat;\n\n        // Extend the Chart prototype for dynamic methods\n        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n            /**\n             * Add a series to the chart after render time. Note that this method should\n             * never be used when adding data synchronously at chart render time, as it\n             * adds expense to the calculations and rendering. When adding data at the\n             * same time as the chart is initiated, add the series as a configuration\n             * option instead. With multiple axes, the `offset` is dynamically adjusted.\n             *\n             * @param  {SeriesOptions} options\n             *         The config options for the series.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after adding.\n             * @param  {AnimationOptions} animation\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @return {Highcharts.Series}\n             *         The newly created series object.\n             *\n             * @sample highcharts/members/chart-addseries/\n             *         Add a series from a button\n             * @sample stock/members/chart-addseries/\n             *         Add a series in Highstock\n             */\n            addSeries: function(options, redraw, animation) {\n                var series,\n                    chart = this;\n\n                if (options) {\n                    redraw = pick(redraw, true); // defaults to true\n\n                    fireEvent(chart, 'addSeries', {\n                        options: options\n                    }, function() {\n                        series = chart.initSeries(options);\n\n                        chart.isDirtyLegend = true; // the series array is out of sync with the display\n                        chart.linkSeries();\n                        if (redraw) {\n                            chart.redraw(animation);\n                        }\n                    });\n                }\n\n                return series;\n            },\n\n            /**\n             * Add an axis to the chart after render time. Note that this method should\n             * never be used when adding data synchronously at chart render time, as it\n             * adds expense to the calculations and rendering. When adding data at the\n             * same time as the chart is initiated, add the axis as a configuration\n             * option instead.\n             * @param  {AxisOptions} options\n             *         The axis options.\n             * @param  {Boolean} [isX=false]\n             *         Whether it is an X axis or a value axis.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after adding.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether and how to apply animation in the redraw.\n             *\n             * @sample highcharts/members/chart-addaxis/ Add and remove axes\n             */\n            addAxis: function(options, isX, redraw, animation) {\n                var key = isX ? 'xAxis' : 'yAxis',\n                    chartOptions = this.options,\n                    userOptions = merge(options, {\n                        index: this[key].length,\n                        isX: isX\n                    });\n\n                new Axis(this, userOptions); // eslint-disable-line no-new\n\n                // Push the new axis options to the chart options\n                chartOptions[key] = splat(chartOptions[key] || {});\n                chartOptions[key].push(userOptions);\n\n                if (pick(redraw, true)) {\n                    this.redraw(animation);\n                }\n            },\n\n            /**\n             * Dim the chart and show a loading text or symbol. Options for the loading\n             * screen are defined in {@link\n             * https://api.highcharts.com/highcharts/loading|the loading options}.\n             * \n             * @param  {String} str\n             *         An optional text to show in the loading label instead of the\n             *         default one. The default text is set in {@link\n             *         http://api.highcharts.com/highcharts/lang.loading|lang.loading}.\n             *\n             * @sample highcharts/members/chart-hideloading/\n             *         Show and hide loading from a button\n             * @sample highcharts/members/chart-showloading/\n             *         Apply different text labels\n             * @sample stock/members/chart-show-hide-loading/\n             *         Toggle loading in Highstock\n             */\n            showLoading: function(str) {\n                var chart = this,\n                    options = chart.options,\n                    loadingDiv = chart.loadingDiv,\n                    loadingOptions = options.loading,\n                    setLoadingSize = function() {\n                        if (loadingDiv) {\n                            css(loadingDiv, {\n                                left: chart.plotLeft + 'px',\n                                top: chart.plotTop + 'px',\n                                width: chart.plotWidth + 'px',\n                                height: chart.plotHeight + 'px'\n                            });\n                        }\n                    };\n\n                // create the layer at the first call\n                if (!loadingDiv) {\n                    chart.loadingDiv = loadingDiv = createElement('div', {\n                        className: 'highcharts-loading highcharts-loading-hidden'\n                    }, null, chart.container);\n\n                    chart.loadingSpan = createElement(\n                        'span', {\n                            className: 'highcharts-loading-inner'\n                        },\n                        null,\n                        loadingDiv\n                    );\n                    addEvent(chart, 'redraw', setLoadingSize); // #1080\n                }\n\n                loadingDiv.className = 'highcharts-loading';\n\n                // Update text\n                chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n\n                // Update visuals\n                css(loadingDiv, extend(loadingOptions.style, {\n                    zIndex: 10\n                }));\n                css(chart.loadingSpan, loadingOptions.labelStyle);\n\n                // Show it\n                if (!chart.loadingShown) {\n                    css(loadingDiv, {\n                        opacity: 0,\n                        display: ''\n                    });\n                    animate(loadingDiv, {\n                        opacity: loadingOptions.style.opacity || 0.5\n                    }, {\n                        duration: loadingOptions.showDuration || 0\n                    });\n                }\n\n\n                chart.loadingShown = true;\n                setLoadingSize();\n            },\n\n            /**\n             * Hide the loading layer.\n             *\n             * @see    Highcharts.Chart#showLoading\n             * @sample highcharts/members/chart-hideloading/\n             *         Show and hide loading from a button\n             * @sample stock/members/chart-show-hide-loading/\n             *         Toggle loading in Highstock\n             */\n            hideLoading: function() {\n                var options = this.options,\n                    loadingDiv = this.loadingDiv;\n\n                if (loadingDiv) {\n                    loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';\n\n                    animate(loadingDiv, {\n                        opacity: 0\n                    }, {\n                        duration: options.loading.hideDuration || 100,\n                        complete: function() {\n                            css(loadingDiv, {\n                                display: 'none'\n                            });\n                        }\n                    });\n\n                }\n                this.loadingShown = false;\n            },\n\n            /** \n             * These properties cause isDirtyBox to be set to true when updating. Can be extended from plugins.\n             */\n            propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',\n                'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',\n                'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth',\n                'plotShadow', 'shadow'\n            ],\n\n            /** \n             * These properties cause all series to be updated when updating. Can be\n             * extended from plugins.\n             */\n            propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',\n                'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions',\n                'tooltip'\n            ],\n\n            /**\n             * A generic function to update any element of the chart. Elements can be\n             * enabled and disabled, moved, re-styled, re-formatted etc.\n             *\n             * A special case is configuration objects that take arrays, for example\n             * {@link https://api.highcharts.com/highcharts/xAxis|xAxis}, \n             * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or \n             * {@link https://api.highcharts.com/highcharts/series|series}. For these\n             * collections, an `id` option is used to map the new option set to an\n             * existing object. If an existing object of the same id is not found, the\n             * corresponding item is updated. So for example, running `chart.update`\n             * with a series item without an id, will cause the existing chart's series\n             * with the same index in the series array to be updated.\n             *\n             * See also the {@link https://api.highcharts.com/highcharts/responsive|\n             * responsive option set}. Switching between `responsive.rules` basically\n             * runs `chart.update` under the hood.\n             *\n             * @param  {Options} options\n             *         A configuration object for the new chart options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart.\n             *\n             * @sample highcharts/members/chart-update/\n             *         Update chart geometry \n             */\n            update: function(options, redraw) {\n                var chart = this,\n                    adders = {\n                        credits: 'addCredits',\n                        title: 'setTitle',\n                        subtitle: 'setSubtitle'\n                    },\n                    optionsChart = options.chart,\n                    updateAllAxes,\n                    updateAllSeries,\n                    newWidth,\n                    newHeight;\n\n                // If the top-level chart option is present, some special updates are required\t\t\n                if (optionsChart) {\n                    merge(true, chart.options.chart, optionsChart);\n\n                    // Setter function\n                    if ('className' in optionsChart) {\n                        chart.setClassName(optionsChart.className);\n                    }\n\n                    if ('inverted' in optionsChart || 'polar' in optionsChart) {\n                        // Parse options.chart.inverted and options.chart.polar together\n                        // with the available series.\n                        chart.propFromSeries();\n                        updateAllAxes = true;\n                    }\n\n                    if ('alignTicks' in optionsChart) { // #6452\n                        updateAllAxes = true;\n                    }\n\n                    objectEach(optionsChart, function(val, key) {\n                        if (inArray('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {\n                            updateAllSeries = true;\n                        }\n                        // Only dirty box\n                        if (inArray(key, chart.propsRequireDirtyBox) !== -1) {\n                            chart.isDirtyBox = true;\n                        }\n                    });\n\n\n                    if ('style' in optionsChart) {\n                        chart.renderer.setStyle(optionsChart.style);\n                    }\n\n                }\n\n                // Moved up, because tooltip needs updated plotOptions (#6218)\n\n                if (options.colors) {\n                    this.options.colors = options.colors;\n                }\n\n\n                if (options.plotOptions) {\n                    merge(true, this.options.plotOptions, options.plotOptions);\n                }\n\n                // Some option stuctures correspond one-to-one to chart objects that\n                // have update methods, for example\n                // options.credits => chart.credits\n                // options.legend => chart.legend\n                // options.title => chart.title\n                // options.tooltip => chart.tooltip\n                // options.subtitle => chart.subtitle\n                // options.mapNavigation => chart.mapNavigation\n                // options.navigator => chart.navigator\n                // options.scrollbar => chart.scrollbar\n                objectEach(options, function(val, key) {\n                    if (chart[key] && typeof chart[key].update === 'function') {\n                        chart[key].update(val, false);\n\n                        // If a one-to-one object does not exist, look for an adder function\n                    } else if (typeof chart[adders[key]] === 'function') {\n                        chart[adders[key]](val);\n                    }\n\n                    if (\n                        key !== 'chart' &&\n                        inArray(key, chart.propsRequireUpdateSeries) !== -1\n                    ) {\n                        updateAllSeries = true;\n                    }\n                });\n\n                // Setters for collections. For axes and series, each item is referred\n                // by an id. If the id is not found, it defaults to the corresponding\n                // item in the collection, so setting one series without an id, will\n                // update the first series in the chart. Setting two series without\n                // an id will update the first and the second respectively (#6019)\n                // chart.update and responsive.\n                each([\n                    'xAxis',\n                    'yAxis',\n                    'zAxis',\n                    'series',\n                    'colorAxis',\n                    'pane'\n                ], function(coll) {\n                    if (options[coll]) {\n                        each(splat(options[coll]), function(newOptions, i) {\n                            var item = (\n                                defined(newOptions.id) &&\n                                chart.get(newOptions.id)\n                            ) || chart[coll][i];\n                            if (item && item.coll === coll) {\n                                item.update(newOptions, false);\n                            }\n                        });\n                    }\n                });\n\n                if (updateAllAxes) {\n                    each(chart.axes, function(axis) {\n                        axis.update({}, false);\n                    });\n                }\n\n                // Certain options require the whole series structure to be thrown away\n                // and rebuilt\n                if (updateAllSeries) {\n                    each(chart.series, function(series) {\n                        series.update({}, false);\n                    });\n                }\n\n                // For loading, just update the options, do not redraw\n                if (options.loading) {\n                    merge(true, chart.options.loading, options.loading);\n                }\n\n                // Update size. Redraw is forced.\n                newWidth = optionsChart && optionsChart.width;\n                newHeight = optionsChart && optionsChart.height;\n                if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||\n                    (isNumber(newHeight) && newHeight !== chart.chartHeight)) {\n                    chart.setSize(newWidth, newHeight);\n                } else if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Setter function to allow use from chart.update\n             */\n            setSubtitle: function(options) {\n                this.setTitle(undefined, options);\n            }\n\n\n        });\n\n        // extend the Point prototype for dynamic methods\n        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n            /**\n             * Update point with new options (typically x/y data) and optionally redraw\n             * the series.\n             *\n             * @param  {Object} options\n             *         The point options. Point options are handled as described under\n             *         the `series<type>.data` item for each series type. For example\n             *         for a line series, if options is a single number, the point will\n             *         be given that number as the main y value. If it is an array, it\n             *         will be interpreted as x and y values respectively. If it is an\n             *         object, advanced options are applied. \n             * @param  {Boolean} [redraw=true]\n             *          Whether to redraw the chart after the point is updated. If doing\n             *          more operations on the chart, it is best practice to set\n             *          `redraw` to false and call `chart.redraw()` after.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/members/point-update-column/\n             *         Update column value\n             * @sample highcharts/members/point-update-pie/\n             *         Update pie slice\n             * @sample maps/members/point-update/\n             *         Update map area value in Highmaps\n             */\n            update: function(options, redraw, animation, runEvent) {\n                var point = this,\n                    series = point.series,\n                    graphic = point.graphic,\n                    i,\n                    chart = series.chart,\n                    seriesOptions = series.options;\n\n                redraw = pick(redraw, true);\n\n                function update() {\n\n                    point.applyOptions(options);\n\n                    // Update visuals\n                    if (point.y === null && graphic) { // #4146\n                        point.graphic = graphic.destroy();\n                    }\n                    if (isObject(options, true)) {\n                        // Destroy so we can get new elements\n                        if (graphic && graphic.element) {\n                            if (options && options.marker && options.marker.symbol) {\n                                point.graphic = graphic.destroy();\n                            }\n                        }\n                        if (options && options.dataLabels && point.dataLabel) { // #2468\n                            point.dataLabel = point.dataLabel.destroy();\n                        }\n                    }\n\n                    // record changes in the parallel arrays\n                    i = point.index;\n                    series.updateParallelArrays(point, i);\n\n                    // Record the options to options.data. If the old or the new config\n                    // is an object, use point options, otherwise use raw options\n                    // (#4701, #4916).\n                    seriesOptions.data[i] = (\n                            isObject(seriesOptions.data[i], true) ||\n                            isObject(options, true)\n                        ) ?\n                        point.options :\n                        options;\n\n                    // redraw\n                    series.isDirty = series.isDirtyData = true;\n                    if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                        chart.isDirtyBox = true;\n                    }\n\n                    if (seriesOptions.legendType === 'point') { // #1831, #1885\n                        chart.isDirtyLegend = true;\n                    }\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                }\n\n                // Fire the event with a default handler of doing the update\n                if (runEvent === false) { // When called from setData\n                    update();\n                } else {\n                    point.firePointEvent('update', {\n                        options: options\n                    }, update);\n                }\n            },\n\n            /**\n             * Remove a point and optionally redraw the series and if necessary the axes\n             * @param  {Boolean} redraw\n             *         Whether to redraw the chart or wait for an explicit call. When\n             *         doing more operations on the chart, for example running\n             *         `point.remove()` in a loop, it is best practice to set `redraw`\n             *         to false and call `chart.redraw()` after.         \n             * @param  {AnimationOptions} [animation=false]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/plotoptions/series-point-events-remove/\n             *         Remove point and confirm\n             * @sample highcharts/members/point-remove/\n             *         Remove pie slice\n             * @sample maps/members/point-remove/\n             *         Remove selected points in Highmaps\n             */\n            remove: function(redraw, animation) {\n                this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n            }\n        });\n\n        // Extend the series prototype for dynamic methods\n        extend(Series.prototype, /** @lends Series.prototype */ {\n            /**\n             * Add a point to the series after render time. The point can be added at\n             * the end, or by giving it an X value, to the start or in the middle of the\n             * series.\n             * \n             * @param  {Number|Array|Object} options\n             *         The point options. If options is a single number, a point with\n             *         that y value is appended to the series.If it is an array, it will\n             *         be interpreted as x and y values respectively. If it is an\n             *         object, advanced options as outlined under `series.data` are\n             *         applied.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the point is added. When adding\n             *         more than one point, it is highly recommended that the redraw\n             *         option be set to false, and instead {@link Chart#redraw}\n             *         is explicitly called after the adding of points is finished.\n             *         Otherwise, the chart will redraw after adding each point.\n             * @param  {Boolean} [shift=false]\n             *         If true, a point is shifted off the start of the series as one is\n             *         appended to the end.\n             * @param  {AnimationOptions} [animation]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/members/series-addpoint-append/\n             *         Append point\n             * @sample highcharts/members/series-addpoint-append-and-shift/\n             *         Append and shift\n             * @sample highcharts/members/series-addpoint-x-and-y/\n             *         Both X and Y values given\n             * @sample highcharts/members/series-addpoint-pie/\n             *         Append pie slice\n             * @sample stock/members/series-addpoint/\n             *         Append 100 points in Highstock\n             * @sample stock/members/series-addpoint-shift/\n             *         Append and shift in Highstock\n             * @sample maps/members/series-addpoint/\n             *         Add a point in Highmaps\n             */\n            addPoint: function(options, redraw, shift, animation) {\n                var series = this,\n                    seriesOptions = series.options,\n                    data = series.data,\n                    chart = series.chart,\n                    xAxis = series.xAxis,\n                    names = xAxis && xAxis.hasNames && xAxis.names,\n                    dataOptions = seriesOptions.data,\n                    point,\n                    isInTheMiddle,\n                    xData = series.xData,\n                    i,\n                    x;\n\n                // Optional redraw, defaults to true\n                redraw = pick(redraw, true);\n\n                // Get options and push the point to xData, yData and series.options. In series.generatePoints\n                // the Point instance will be created on demand and pushed to the series.data array.\n                point = {\n                    series: series\n                };\n                series.pointClass.prototype.applyOptions.apply(point, [options]);\n                x = point.x;\n\n                // Get the insertion point\n                i = xData.length;\n                if (series.requireSorting && x < xData[i - 1]) {\n                    isInTheMiddle = true;\n                    while (i && xData[i - 1] > x) {\n                        i--;\n                    }\n                }\n\n                series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n                series.updateParallelArrays(point, i); // update it\n\n                if (names && point.name) {\n                    names[x] = point.name;\n                }\n                dataOptions.splice(i, 0, options);\n\n                if (isInTheMiddle) {\n                    series.data.splice(i, 0, null);\n                    series.processData();\n                }\n\n                // Generate points to be added to the legend (#1329)\n                if (seriesOptions.legendType === 'point') {\n                    series.generatePoints();\n                }\n\n                // Shift the first point off the parallel arrays\n                if (shift) {\n                    if (data[0] && data[0].remove) {\n                        data[0].remove(false);\n                    } else {\n                        data.shift();\n                        series.updateParallelArrays(point, 'shift');\n\n                        dataOptions.shift();\n                    }\n                }\n\n                // redraw\n                series.isDirty = true;\n                series.isDirtyData = true;\n\n                if (redraw) {\n                    chart.redraw(animation); // Animation is set anyway on redraw, #5665\n                }\n            },\n\n            /**\n             * Remove a point from the series. Unlike the {@link Highcharts.Point#remove}\n             * method, this can also be done on a point that is not instanciated because\n             * it is outside the view or subject to Highstock data grouping.\n             *\n             * @param  {Number} i\n             *         The index of the point in the {@link Highcharts.Series.data|data}\n             *         array.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the point is added. When \n             *         removing more than one point, it is highly recommended that the\n             *         `redraw` option be set to `false`, and instead {@link\n             *         Highcharts.Chart#redraw} is explicitly called after the adding of\n             *         points is finished.\n             * @param  {AnimationOptions} [animation]\n             *         Whether and optionally how the series should be animated.\n             *\n             * @sample highcharts/members/series-removepoint/\n             *         Remove cropped point\n             */\n            removePoint: function(i, redraw, animation) {\n\n                var series = this,\n                    data = series.data,\n                    point = data[i],\n                    points = series.points,\n                    chart = series.chart,\n                    remove = function() {\n\n                        if (points && points.length === data.length) { // #4935\n                            points.splice(i, 1);\n                        }\n                        data.splice(i, 1);\n                        series.options.data.splice(i, 1);\n                        series.updateParallelArrays(point || {\n                            series: series\n                        }, 'splice', i, 1);\n\n                        if (point) {\n                            point.destroy();\n                        }\n\n                        // redraw\n                        series.isDirty = true;\n                        series.isDirtyData = true;\n                        if (redraw) {\n                            chart.redraw();\n                        }\n                    };\n\n                setAnimation(animation, chart);\n                redraw = pick(redraw, true);\n\n                // Fire the event with a default handler of removing the point\n                if (point) {\n                    point.firePointEvent('remove', null, remove);\n                } else {\n                    remove();\n                }\n            },\n\n            /**\n             * Remove a series and optionally redraw the chart.\n             *\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart or wait for an explicit call to\n             *         {@link Highcharts.Chart#redraw}.\n             * @param  {AnimationOptions} [animation]\n             *         Whether to apply animation, and optionally animation\n             *         configuration\n             * @param  {Boolean} [withEvent=true]\n             *         Used internally, whether to fire the series `remove` event.\n             *\n             * @sample highcharts/members/series-remove/\n             *         Remove first series from a button\n             */\n            remove: function(redraw, animation, withEvent) {\n                var series = this,\n                    chart = series.chart;\n\n                function remove() {\n\n                    // Destroy elements\n                    series.destroy();\n\n                    // Redraw\n                    chart.isDirtyLegend = chart.isDirtyBox = true;\n                    chart.linkSeries();\n\n                    if (pick(redraw, true)) {\n                        chart.redraw(animation);\n                    }\n                }\n\n                // Fire the event with a default handler of removing the point\n                if (withEvent !== false) {\n                    fireEvent(series, 'remove', null, remove);\n                } else {\n                    remove();\n                }\n            },\n\n            /**\n             * Update the series with a new set of options. For a clean and precise\n             * handling of new options, all methods and elements from the series are\n             * removed, and it is initiated from scratch. Therefore, this method is more\n             * performance expensive than some other utility methods like {@link\n             * Series#setData} or {@link Series#setVisible}.\n             *\n             * @param  {SeriesOptions} options\n             *         New options that will be merged with the series' existing\n             *         options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw} after.\n             *\n             * @sample highcharts/members/series-update/\n             *         Updating series options\n             * @sample maps/members/series-update/\n             *         Update series options in Highmaps\n             */\n            update: function(newOptions, redraw) {\n                var series = this,\n                    chart = series.chart,\n                    // must use user options when changing type because series.options\n                    // is merged in with type specific plotOptions\n                    oldOptions = series.userOptions,\n                    oldType = series.oldType || series.type,\n                    newType = newOptions.type || oldOptions.type || chart.options.chart.type,\n                    proto = seriesTypes[oldType].prototype,\n                    preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n                    n;\n\n                // Running Series.update to update the data only is an intuitive usage,\n                // so we want to make sure that when used like this, we run the\n                // cheaper setData function and allow animation instead of completely\n                // recreating the series instance.\n                if (Object.keys && Object.keys(newOptions).toString() === 'data') {\n                    return this.setData(newOptions.data, redraw);\n                }\n\n                // If we're changing type or zIndex, create new groups (#3380, #3404)\n                if ((newType && newType !== oldType) || newOptions.zIndex !== undefined) {\n                    preserve.length = 0;\n                }\n\n                // Make sure groups are not destroyed (#3094)\n                each(preserve, function(prop) {\n                    preserve[prop] = series[prop];\n                    delete series[prop];\n                });\n\n                // Do the merge, with some forced options\n                newOptions = merge(oldOptions, {\n                    animation: false,\n                    index: series.index,\n                    pointStart: series.xData[0] // when updating after addPoint\n                }, {\n                    data: series.options.data\n                }, newOptions);\n\n                // Destroy the series and delete all properties. Reinsert all methods\n                // and properties from the new type prototype (#2270, #3719)\n                series.remove(false, null, false);\n                for (n in proto) {\n                    series[n] = undefined;\n                }\n                extend(series, seriesTypes[newType || oldType].prototype);\n\n                // Re-register groups (#3094)\n                each(preserve, function(prop) {\n                    series[prop] = preserve[prop];\n                });\n\n                series.init(chart, newOptions);\n                series.oldType = oldType;\n                chart.linkSeries(); // Links are lost in series.remove (#3028)\n                if (pick(redraw, true)) {\n                    chart.redraw(false);\n                }\n            }\n        });\n\n        // Extend the Axis.prototype for dynamic methods\n        extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Update an axis object with a new set of options. The options are merged\n             * with the existing options, so only new or altered options need to be\n             * specified.\n             *\n             * @param  {Object} options\n             *         The new options that will be merged in with existing options on\n             *         the axis.\n             * @sample highcharts/members/axis-update/ Axis update demo\n             */\n            update: function(options, redraw) {\n                var chart = this.chart;\n\n                options = chart.options[this.coll][this.options.index] =\n                    merge(this.userOptions, options);\n\n                this.destroy(true);\n\n                this.init(chart, extend(options, {\n                    events: undefined\n                }));\n\n                chart.isDirtyBox = true;\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Remove the axis from the chart.\n             *\n             * @param {Boolean} [redraw=true] Whether to redraw the chart following the\n             * remove.\n             *\n             * @sample highcharts/members/chart-addaxis/ Add and remove axes\n             */\n            remove: function(redraw) {\n                var chart = this.chart,\n                    key = this.coll, // xAxis or yAxis\n                    axisSeries = this.series,\n                    i = axisSeries.length;\n\n                // Remove associated series (#2687)\n                while (i--) {\n                    if (axisSeries[i]) {\n                        axisSeries[i].remove(false);\n                    }\n                }\n\n                // Remove the axis\n                erase(chart.axes, this);\n                erase(chart[key], this);\n\n                if (isArray(chart.options[key])) {\n                    chart.options[key].splice(this.options.index, 1);\n                } else { // color axis, #6488\n                    delete chart.options[key];\n                }\n\n                each(chart[key], function(axis, i) { // Re-index, #1706\n                    axis.options.index = i;\n                });\n                this.destroy();\n                chart.isDirtyBox = true;\n\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Update the axis title by options after render time.\n             *\n             * @param  {TitleOptions} titleOptions\n             *         The additional title options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after setting the title.\n             * @sample highcharts/members/axis-settitle/ Set a new Y axis title\n             */\n            setTitle: function(titleOptions, redraw) {\n                this.update({\n                    title: titleOptions\n                }, redraw);\n            },\n\n            /**\n             * Set new axis categories and optionally redraw.\n             * @param {Array.<String>} categories - The new categories.\n             * @param {Boolean} [redraw=true] - Whether to redraw the chart.\n             * @sample highcharts/members/axis-setcategories/ Set categories by click on\n             * a button\n             */\n            setCategories: function(categories, redraw) {\n                this.update({\n                    categories: categories\n                }, redraw);\n            }\n\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var color = H.color,\n            each = H.each,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            map = H.map,\n            pick = H.pick,\n            Series = H.Series,\n            seriesType = H.seriesType;\n\n        /**\n         * Area series type.\n         * @constructor seriesTypes.area\n         * @extends {Series}\n         */\n        seriesType('area', 'line', {\n            softThreshold: false,\n            threshold: 0\n            // trackByArea: false,\n            // lineColor: null, // overrides color, but lets fillColor be unaltered\n            // fillOpacity: 0.75,\n            // fillColor: null\n        }, /** @lends seriesTypes.area.prototype */ {\n            singleStacks: false,\n            /** \n             * Return an array of stacked points, where null and missing points are replaced by \n             * dummy points in order for gaps to be drawn correctly in stacks.\n             */\n            getStackPoints: function() {\n                var series = this,\n                    segment = [],\n                    keys = [],\n                    xAxis = this.xAxis,\n                    yAxis = this.yAxis,\n                    stack = yAxis.stacks[this.stackKey],\n                    pointMap = {},\n                    points = this.points,\n                    seriesIndex = series.index,\n                    yAxisSeries = yAxis.series,\n                    seriesLength = yAxisSeries.length,\n                    visibleSeries,\n                    upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n                    i;\n\n                if (this.options.stacking) {\n                    // Create a map where we can quickly look up the points by their X value.\n                    for (i = 0; i < points.length; i++) {\n                        pointMap[points[i].x] = points[i];\n                    }\n\n                    // Sort the keys (#1651)\n                    H.objectEach(stack, function(stackX, x) {\n                        if (stackX.total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                            keys.push(x);\n                        }\n                    });\n                    keys.sort(function(a, b) {\n                        return a - b;\n                    });\n\n                    visibleSeries = map(yAxisSeries, function() {\n                        return this.visible;\n                    });\n\n                    each(keys, function(x, idx) {\n                        var y = 0,\n                            stackPoint,\n                            stackedValues;\n\n                        if (pointMap[x] && !pointMap[x].isNull) {\n                            segment.push(pointMap[x]);\n\n                            // Find left and right cliff. -1 goes left, 1 goes right.\n                            each([-1, 1], function(direction) {\n                                var nullName = direction === 1 ? 'rightNull' : 'leftNull',\n                                    cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n                                    cliff = 0,\n                                    otherStack = stack[keys[idx + direction]];\n\n                                // If there is a stack next to this one, to the left or to the right...\n                                if (otherStack) {\n                                    i = seriesIndex;\n                                    while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks\n                                        stackPoint = otherStack.points[i];\n                                        if (!stackPoint) {\n                                            // If the next point in this series is missing, mark the point\n                                            // with point.leftNull or point.rightNull = true.\n                                            if (i === seriesIndex) {\n                                                pointMap[x][nullName] = true;\n\n                                                // If there are missing points in the next stack in any of the \n                                                // series below this one, we need to substract the missing values\n                                                // and add a hiatus to the left or right.\n                                            } else if (visibleSeries[i]) {\n                                                stackedValues = stack[x].points[i];\n                                                if (stackedValues) {\n                                                    cliff -= stackedValues[1] - stackedValues[0];\n                                                }\n                                            }\n                                        }\n                                        // When reversedStacks is true, loop up, else loop down\n                                        i += upOrDown;\n                                    }\n                                }\n                                pointMap[x][cliffName] = cliff;\n                            });\n\n\n                            // There is no point for this X value in this series, so we \n                            // insert a dummy point in order for the areas to be drawn\n                            // correctly.\n                        } else {\n\n                            // Loop down the stack to find the series below this one that has\n                            // a value (#1991)\n                            i = seriesIndex;\n                            while (i >= 0 && i < seriesLength) {\n                                stackPoint = stack[x].points[i];\n                                if (stackPoint) {\n                                    y = stackPoint[1];\n                                    break;\n                                }\n                                // When reversedStacks is true, loop up, else loop down\n                                i += upOrDown;\n                            }\n                            y = yAxis.translate(y, 0, 1, 0, 1); // #6272\n                            segment.push({\n                                isNull: true,\n                                plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272\n                                x: x,\n                                plotY: y,\n                                yBottom: y\n                            });\n                        }\n                    });\n\n                }\n\n                return segment;\n            },\n\n            getGraphPath: function(points) {\n                var getGraphPath = Series.prototype.getGraphPath,\n                    graphPath,\n                    options = this.options,\n                    stacking = options.stacking,\n                    yAxis = this.yAxis,\n                    topPath,\n                    //topPoints = [],\n                    bottomPath,\n                    bottomPoints = [],\n                    graphPoints = [],\n                    seriesIndex = this.index,\n                    i,\n                    areaPath,\n                    plotX,\n                    stacks = yAxis.stacks[this.stackKey],\n                    threshold = options.threshold,\n                    translatedThreshold = yAxis.getThreshold(options.threshold),\n                    isNull,\n                    yBottom,\n                    connectNulls = options.connectNulls || stacking === 'percent',\n                    /**\n                     * To display null points in underlying stacked series, this series graph must be \n                     * broken, and the area also fall down to fill the gap left by the null point. #2069\n                     */\n                    addDummyPoints = function(i, otherI, side) {\n                        var point = points[i],\n                            stackedValues = stacking && stacks[point.x].points[seriesIndex],\n                            nullVal = point[side + 'Null'] || 0,\n                            cliffVal = point[side + 'Cliff'] || 0,\n                            top,\n                            bottom,\n                            isNull = true;\n\n                        if (cliffVal || nullVal) {\n\n                            top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n                            bottom = stackedValues[0] + cliffVal;\n                            isNull = !!nullVal;\n\n                        } else if (!stacking && points[otherI] && points[otherI].isNull) {\n                            top = bottom = threshold;\n                        }\n\n                        // Add to the top and bottom line of the area\n                        if (top !== undefined) {\n                            graphPoints.push({\n                                plotX: plotX,\n                                plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),\n                                isNull: isNull,\n                                isCliff: true\n                            });\n                            bottomPoints.push({\n                                plotX: plotX,\n                                plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),\n                                doCurve: false // #1041, gaps in areaspline areas\n                            });\n                        }\n                    };\n\n                // Find what points to use\n                points = points || this.points;\n\n                // Fill in missing points\n                if (stacking) {\n                    points = this.getStackPoints();\n                }\n\n                for (i = 0; i < points.length; i++) {\n                    isNull = points[i].isNull;\n                    plotX = pick(points[i].rectPlotX, points[i].plotX);\n                    yBottom = pick(points[i].yBottom, translatedThreshold);\n\n                    if (!isNull || connectNulls) {\n\n                        if (!connectNulls) {\n                            addDummyPoints(i, i - 1, 'left');\n                        }\n\n                        if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true\n                            graphPoints.push(points[i]);\n                            bottomPoints.push({\n                                x: i,\n                                plotX: plotX,\n                                plotY: yBottom\n                            });\n                        }\n\n                        if (!connectNulls) {\n                            addDummyPoints(i, i + 1, 'right');\n                        }\n                    }\n                }\n\n                topPath = getGraphPath.call(this, graphPoints, true, true);\n\n                bottomPoints.reversed = true;\n                bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n                if (bottomPath.length) {\n                    bottomPath[0] = 'L';\n                }\n\n                areaPath = topPath.concat(bottomPath);\n                graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?\n\n                areaPath.xMap = topPath.xMap;\n                this.areaPath = areaPath;\n\n                return graphPath;\n            },\n\n            /**\n             * Draw the graph and the underlying area. This method calls the Series base\n             * function and adds the area. The areaPath is calculated in the getSegmentPath\n             * method called from Series.prototype.drawGraph.\n             */\n            drawGraph: function() {\n\n                // Define or reset areaPath\n                this.areaPath = [];\n\n                // Call the base method\n                Series.prototype.drawGraph.apply(this);\n\n                // Define local variables\n                var series = this,\n                    areaPath = this.areaPath,\n                    options = this.options,\n                    zones = this.zones,\n                    props = [\n                        [\n                            'area',\n                            'highcharts-area',\n\n                            this.color,\n                            options.fillColor\n\n                        ]\n                    ]; // area name, main color, fill color\n\n                each(zones, function(zone, i) {\n                    props.push([\n                        'zone-area-' + i,\n                        'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,\n\n                        zone.color || series.color,\n                        zone.fillColor || options.fillColor\n\n                    ]);\n                });\n\n                each(props, function(prop) {\n                    var areaKey = prop[0],\n                        area = series[areaKey];\n\n                    // Create or update the area\n                    if (area) { // update\n                        area.endX = areaPath.xMap;\n                        area.animate({\n                            d: areaPath\n                        });\n\n                    } else { // create\n                        area = series[areaKey] = series.chart.renderer.path(areaPath)\n                            .addClass(prop[1])\n                            .attr({\n\n                                fill: pick(\n                                    prop[3],\n                                    color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n                                ),\n\n                                zIndex: 0 // #1069\n                            }).add(series.group);\n                        area.isArea = true;\n                    }\n                    area.startX = areaPath.xMap;\n                    area.shiftUnit = options.step ? 2 : 1;\n                });\n            },\n\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var pick = H.pick,\n            seriesType = H.seriesType;\n\n        /**\n         * Spline series type.\n         * @constructor seriesTypes.spline\n         * @extends {Series}\n         */\n        seriesType('spline', 'line', {}, /** @lends seriesTypes.spline.prototype */ {\n            /**\n             * Get the spline segment from a given point's previous neighbour to the given point\n             */\n            getPointSpline: function(points, point, i) {\n                var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n                    denom = smoothing + 1,\n                    plotX = point.plotX,\n                    plotY = point.plotY,\n                    lastPoint = points[i - 1],\n                    nextPoint = points[i + 1],\n                    leftContX,\n                    leftContY,\n                    rightContX,\n                    rightContY,\n                    ret;\n\n                function doCurve(otherPoint) {\n                    return otherPoint &&\n                        !otherPoint.isNull &&\n                        otherPoint.doCurve !== false &&\n                        !point.isCliff; // #6387, area splines next to null\n                }\n\n                // Find control points\n                if (doCurve(lastPoint) && doCurve(nextPoint)) {\n                    var lastX = lastPoint.plotX,\n                        lastY = lastPoint.plotY,\n                        nextX = nextPoint.plotX,\n                        nextY = nextPoint.plotY,\n                        correction = 0;\n\n                    leftContX = (smoothing * plotX + lastX) / denom;\n                    leftContY = (smoothing * plotY + lastY) / denom;\n                    rightContX = (smoothing * plotX + nextX) / denom;\n                    rightContY = (smoothing * plotY + nextY) / denom;\n\n                    // Have the two control points make a straight line through main point\n                    if (rightContX !== leftContX) { // #5016, division by zero\n                        correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                            (rightContX - leftContX) + plotY - rightContY;\n                    }\n\n                    leftContY += correction;\n                    rightContY += correction;\n\n                    // to prevent false extremes, check that control points are between\n                    // neighbouring points' y values\n                    if (leftContY > lastY && leftContY > plotY) {\n                        leftContY = Math.max(lastY, plotY);\n                        rightContY = 2 * plotY - leftContY; // mirror of left control point\n                    } else if (leftContY < lastY && leftContY < plotY) {\n                        leftContY = Math.min(lastY, plotY);\n                        rightContY = 2 * plotY - leftContY;\n                    }\n                    if (rightContY > nextY && rightContY > plotY) {\n                        rightContY = Math.max(nextY, plotY);\n                        leftContY = 2 * plotY - rightContY;\n                    } else if (rightContY < nextY && rightContY < plotY) {\n                        rightContY = Math.min(nextY, plotY);\n                        leftContY = 2 * plotY - rightContY;\n                    }\n\n                    // record for drawing in next point\n                    point.rightContX = rightContX;\n                    point.rightContY = rightContY;\n\n\n                }\n\n                // Visualize control points for debugging\n                /*\n                if (leftContX) {\n                \tthis.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n                \t\t.attr({\n                \t\t\tstroke: 'red',\n                \t\t\t'stroke-width': 2,\n                \t\t\tfill: 'none',\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                \tthis.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n                \t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                \t\t.attr({\n                \t\t\tstroke: 'red',\n                \t\t\t'stroke-width': 2,\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                }\n                if (rightContX) {\n                \tthis.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n                \t\t.attr({\n                \t\t\tstroke: 'green',\n                \t\t\t'stroke-width': 2,\n                \t\t\tfill: 'none',\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                \tthis.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n                \t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                \t\t.attr({\n                \t\t\tstroke: 'green',\n                \t\t\t'stroke-width': 2,\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                }\n                // */\n                ret = [\n                    'C',\n                    pick(lastPoint.rightContX, lastPoint.plotX),\n                    pick(lastPoint.rightContY, lastPoint.plotY),\n                    pick(leftContX, plotX),\n                    pick(leftContY, plotY),\n                    plotX,\n                    plotY\n                ];\n                lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n                return ret;\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var areaProto = H.seriesTypes.area.prototype,\n            defaultPlotOptions = H.defaultPlotOptions,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            seriesType = H.seriesType;\n        /**\n         * AreaSplineSeries object\n         */\n        seriesType('areaspline', 'spline', defaultPlotOptions.area, {\n            getStackPoints: areaProto.getStackPoints,\n            getGraphPath: areaProto.getGraphPath,\n            setStackCliffs: areaProto.setStackCliffs,\n            drawGraph: areaProto.drawGraph,\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var animObject = H.animObject,\n            color = H.color,\n            each = H.each,\n            extend = H.extend,\n            isNumber = H.isNumber,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Series = H.Series,\n            seriesType = H.seriesType,\n            svg = H.svg;\n        /**\n         * The column series type.\n         *\n         * @constructor seriesTypes.column\n         * @augments Series\n         */\n        seriesType('column', 'line', {\n            borderRadius: 0,\n            //colorByPoint: undefined,\n            crisp: true,\n            groupPadding: 0.2,\n            //grouping: true,\n            marker: null, // point options are specified in the base options\n            pointPadding: 0.1,\n            //pointWidth: null,\n            minPointLength: 0,\n            cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n            pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n            states: {\n                hover: {\n                    halo: false,\n\n                    brightness: 0.1,\n                    shadow: false\n\n                },\n\n                select: {\n                    color: '#cccccc',\n                    borderColor: '#000000',\n                    shadow: false\n                }\n\n            },\n            dataLabels: {\n                align: null, // auto\n                verticalAlign: null, // auto\n                y: null\n            },\n            softThreshold: false,\n            startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n            stickyTracking: false,\n            tooltip: {\n                distance: 6\n            },\n            threshold: 0,\n\n            borderColor: '#ffffff'\n            // borderWidth: 1\n\n\n        }, /** @lends seriesTypes.column.prototype */ {\n            cropShoulder: 0,\n            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n            // point is substracted from previous (#1910)\n\n            /**\n             * Initialize the series. Extends the basic Series.init method by\n             * marking other series of the same type as dirty.\n             *\n             * @function #init\n             * @memberOf seriesTypes.column\n             * @returns {void}\n             */\n            init: function() {\n                Series.prototype.init.apply(this, arguments);\n\n                var series = this,\n                    chart = series.chart;\n\n                // if the series is added dynamically, force redraw of other\n                // series affected by a new column\n                if (chart.hasRendered) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.type === series.type) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n             * pointWidth etc.\n             */\n            getColumnMetrics: function() {\n\n                var series = this,\n                    options = series.options,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    reversedXAxis = xAxis.reversed,\n                    stackKey,\n                    stackGroups = {},\n                    columnCount = 0;\n\n                // Get the total number of column type series.\n                // This is called on every series. Consider moving this logic to a\n                // chart.orderStacks() function and call it on init, addSeries and removeSeries\n                if (options.grouping === false) {\n                    columnCount = 1;\n                } else {\n                    each(series.chart.series, function(otherSeries) {\n                        var otherOptions = otherSeries.options,\n                            otherYAxis = otherSeries.yAxis,\n                            columnIndex;\n                        if (\n                            otherSeries.type === series.type &&\n                            (\n                                otherSeries.visible ||\n                                !series.chart.options.chart.ignoreHiddenSeries\n                            ) &&\n                            yAxis.len === otherYAxis.len &&\n                            yAxis.pos === otherYAxis.pos\n                        ) { // #642, #2086\n                            if (otherOptions.stacking) {\n                                stackKey = otherSeries.stackKey;\n                                if (stackGroups[stackKey] === undefined) {\n                                    stackGroups[stackKey] = columnCount++;\n                                }\n                                columnIndex = stackGroups[stackKey];\n                            } else if (otherOptions.grouping !== false) { // #1162\n                                columnIndex = columnCount++;\n                            }\n                            otherSeries.columnIndex = columnIndex;\n                        }\n                    });\n                }\n\n                var categoryWidth = Math.min(\n                        Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                        xAxis.len // #1535\n                    ),\n                    groupPadding = categoryWidth * options.groupPadding,\n                    groupWidth = categoryWidth - 2 * groupPadding,\n                    pointOffsetWidth = groupWidth / (columnCount || 1),\n                    pointWidth = Math.min(\n                        options.maxPointWidth || xAxis.len,\n                        pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n                    ),\n                    pointPadding = (pointOffsetWidth - pointWidth) / 2,\n                    colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n                    pointXOffset = pointPadding + (groupPadding + colIndex *\n                        pointOffsetWidth - (categoryWidth / 2)) *\n                    (reversedXAxis ? -1 : 1);\n\n                // Save it for reading in linked series (Error bars particularly)\n                series.columnMetrics = {\n                    width: pointWidth,\n                    offset: pointXOffset\n                };\n                return series.columnMetrics;\n\n            },\n\n            /**\n             * Make the columns crisp. The edges are rounded to the nearest full pixel.\n             */\n            crispCol: function(x, y, w, h) {\n                var chart = this.chart,\n                    borderWidth = this.borderWidth,\n                    xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n                    yCrisp = borderWidth % 2 ? 0.5 : 1,\n                    right,\n                    bottom,\n                    fromTop;\n\n                if (chart.inverted && chart.renderer.isVML) {\n                    yCrisp += 1;\n                }\n\n                // Horizontal. We need to first compute the exact right edge, then round it\n                // and compute the width from there.\n                if (this.options.crisp) {\n                    right = Math.round(x + w) + xCrisp;\n                    x = Math.round(x) + xCrisp;\n                    w = right - x;\n                }\n\n                // Vertical\n                bottom = Math.round(y + h) + yCrisp;\n                fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n                y = Math.round(y) + yCrisp;\n                h = bottom - y;\n\n                // Top edges are exceptions\n                if (fromTop && h) { // #5146\n                    y -= 1;\n                    h += 1;\n                }\n\n                return {\n                    x: x,\n                    y: y,\n                    width: w,\n                    height: h\n                };\n            },\n\n            /**\n             * Translate each point to the plot area coordinate system and find shape positions\n             */\n            translate: function() {\n                var series = this,\n                    chart = series.chart,\n                    options = series.options,\n                    dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,\n                    borderWidth = series.borderWidth = pick(\n                        options.borderWidth,\n                        dense ? 0 : 1 // #3635\n                    ),\n                    yAxis = series.yAxis,\n                    threshold = options.threshold,\n                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n                    minPointLength = pick(options.minPointLength, 5),\n                    metrics = series.getColumnMetrics(),\n                    pointWidth = metrics.width,\n                    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n                    pointXOffset = series.pointXOffset = metrics.offset;\n\n                if (chart.inverted) {\n                    translatedThreshold -= 0.5; // #3355\n                }\n\n                // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n                // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n                // columns (#2694).\n                if (options.pointPadding) {\n                    seriesBarW = Math.ceil(seriesBarW);\n                }\n\n                Series.prototype.translate.apply(series);\n\n                // Record the new values\n                each(series.points, function(point) {\n                    var yBottom = pick(point.yBottom, translatedThreshold),\n                        safeDistance = 999 + Math.abs(yBottom),\n                        plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                        barX = point.plotX + pointXOffset,\n                        barW = seriesBarW,\n                        barY = Math.min(plotY, yBottom),\n                        up,\n                        barH = Math.max(plotY, yBottom) - barY;\n\n                    // Handle options.minPointLength\n                    if (Math.abs(barH) < minPointLength) {\n                        if (minPointLength) {\n                            barH = minPointLength;\n                            up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                            barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked\n                                yBottom - minPointLength : // keep position\n                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                        }\n                    }\n\n                    // Cache for access in polar\n                    point.barX = barX;\n                    point.pointWidth = pointWidth;\n\n                    // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n                    // Register shape type and arguments to be used in drawPoints\n                    point.shapeType = 'rect';\n                    point.shapeArgs = series.crispCol.apply(\n                        series,\n                        point.isNull ?\n                        // #3169, drilldown from null must have a position to work from\n                        // #6585, dataLabel should be placed on xAxis, not floating in the middle of the chart\n                        [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]\n                    );\n                });\n\n            },\n\n            getSymbol: noop,\n\n            /**\n             * Use a solid rectangle like the area series types\n             */\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n            /**\n             * Columns have no graph\n             */\n            drawGraph: function() {\n                this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n            },\n\n\n            /**\n             * Get presentational attributes\n             */\n            pointAttribs: function(point, state) {\n                var options = this.options,\n                    stateOptions,\n                    ret,\n                    p2o = this.pointAttrToOptions || {},\n                    strokeOption = p2o.stroke || 'borderColor',\n                    strokeWidthOption = p2o['stroke-width'] || 'borderWidth',\n                    fill = (point && point.color) || this.color,\n                    stroke = point[strokeOption] || options[strokeOption] ||\n                    this.color || fill, // set to fill when borderColor null\n                    strokeWidth = point[strokeWidthOption] ||\n                    options[strokeWidthOption] || this[strokeWidthOption] || 0,\n                    dashstyle = options.dashStyle,\n                    zone,\n                    brightness;\n\n                // Handle zone colors\n                if (point && this.zones.length) {\n                    zone = point.getZone();\n                    fill = point.options.color || (zone && zone.color) || this.color; // When zones are present, don't use point.color (#4267). Changed order (#6527)\n                }\n\n                // Select or hover states\n                if (state) {\n                    stateOptions = merge(\n                        options.states[state],\n                        point.options.states && point.options.states[state] || {} // #6401\n                    );\n                    brightness = stateOptions.brightness;\n                    fill = stateOptions.color ||\n                        (brightness !== undefined && color(fill).brighten(stateOptions.brightness).get()) ||\n                        fill;\n                    stroke = stateOptions[strokeOption] || stroke;\n                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;\n                    dashstyle = stateOptions.dashStyle || dashstyle;\n                }\n\n                ret = {\n                    'fill': fill,\n                    'stroke': stroke,\n                    'stroke-width': strokeWidth\n                };\n                if (options.borderRadius) {\n                    ret.r = options.borderRadius;\n                }\n\n                if (dashstyle) {\n                    ret.dashstyle = dashstyle;\n                }\n\n                return ret;\n            },\n\n\n            /**\n             * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n             * apply for columns and bars. This method is inherited by scatter series.\n             *\n             */\n            drawPoints: function() {\n                var series = this,\n                    chart = this.chart,\n                    options = series.options,\n                    renderer = chart.renderer,\n                    animationLimit = options.animationLimit || 250,\n                    shapeArgs;\n\n                // draw the columns\n                each(series.points, function(point) {\n                    var plotY = point.plotY,\n                        graphic = point.graphic;\n\n                    if (isNumber(plotY) && point.y !== null) {\n                        shapeArgs = point.shapeArgs;\n\n                        if (graphic) { // update\n                            graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](\n                                merge(shapeArgs)\n                            );\n\n                        } else {\n                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                                .add(point.group || series.group);\n                        }\n\n\n                        // Presentational\n                        graphic\n                            .attr(series.pointAttribs(point, point.selected && 'select'))\n                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n\n\n                        graphic.addClass(point.getClassName(), true);\n\n\n                    } else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                });\n            },\n\n            /**\n             * Animate the column heights one by one from zero\n             * @param {Boolean} init Whether to initialize the animation or run it\n             */\n            animate: function(init) {\n                var series = this,\n                    yAxis = this.yAxis,\n                    options = series.options,\n                    inverted = this.chart.inverted,\n                    attr = {},\n                    translatedThreshold;\n\n                if (svg) { // VML is too slow anyway\n                    if (init) {\n                        attr.scaleY = 0.001;\n                        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n                        if (inverted) {\n                            attr.translateX = translatedThreshold - yAxis.len;\n                        } else {\n                            attr.translateY = translatedThreshold;\n                        }\n                        series.group.attr(attr);\n\n                    } else { // run the animation\n\n                        attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                        series.group.animate(attr, extend(animObject(series.options.animation), {\n                            // Do the scale synchronously to ensure smooth updating (#5030)\n                            step: function(val, fx) {\n                                series.group.attr({\n                                    scaleY: Math.max(0.001, fx.pos) // #5250\n                                });\n                            }\n                        }));\n\n                        // delete this function to allow it only once\n                        series.animate = null;\n                    }\n                }\n            },\n\n            /**\n             * Remove this series from the chart\n             */\n            remove: function() {\n                var series = this,\n                    chart = series.chart;\n\n                // column and bar series affects other series of the same type\n                // as they are either stacked or grouped\n                if (chart.hasRendered) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.type === series.type) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n\n                Series.prototype.remove.apply(series, arguments);\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var seriesType = H.seriesType;\n\n        /**\n         * The Bar series class\n         */\n        seriesType('bar', 'column', null, {\n            inverted: true\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Series = H.Series,\n            seriesType = H.seriesType;\n        /**\n         * The scatter series type\n         */\n        seriesType('scatter', 'line', {\n            lineWidth: 0,\n            findNearestPointBy: 'xy',\n            marker: {\n                enabled: true // Overrides auto-enabling in line series (#3647)\n            },\n            tooltip: {\n\n                headerFormat: '<span style=\"color:{point.color}\">\\u25CF</span> ' +\n                    '<span style=\"font-size: 0.85em\"> {series.name}</span><br/>',\n\n                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n            }\n\n            // Prototype members\n        }, {\n            sorted: false,\n            requireSorting: false,\n            noSharedTooltip: true,\n            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n            takeOrdinalPosition: false, // #2342\n            drawGraph: function() {\n                if (this.options.lineWidth) {\n                    Series.prototype.drawGraph.call(this);\n                }\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var pick = H.pick,\n            relativeLength = H.relativeLength;\n\n        H.CenteredSeriesMixin = {\n            /**\n             * Get the center of the pie based on the size and center options relative to the\n             * plot area. Borrowed by the polar and gauge series types.\n             */\n            getCenter: function() {\n\n                var options = this.options,\n                    chart = this.chart,\n                    slicingRoom = 2 * (options.slicedOffset || 0),\n                    handleSlicingRoom,\n                    plotWidth = chart.plotWidth - 2 * slicingRoom,\n                    plotHeight = chart.plotHeight - 2 * slicingRoom,\n                    centerOption = options.center,\n                    positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n                    smallestSize = Math.min(plotWidth, plotHeight),\n                    i,\n                    value;\n\n                for (i = 0; i < 4; ++i) {\n                    value = positions[i];\n                    handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n                    // i == 0: centerX, relative to width\n                    // i == 1: centerY, relative to height\n                    // i == 2: size, relative to smallestSize\n                    // i == 3: innerSize, relative to size\n                    positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +\n                        (handleSlicingRoom ? slicingRoom : 0);\n\n                }\n                // innerSize cannot be larger than size (#3632)\n                if (positions[3] > positions[2]) {\n                    positions[3] = positions[2];\n                }\n                return positions;\n            }\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            CenteredSeriesMixin = H.CenteredSeriesMixin,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            inArray = H.inArray,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesType = H.seriesType,\n            seriesTypes = H.seriesTypes,\n            setAnimation = H.setAnimation;\n\n        /**\n         * The pie series type.\n         *\n         * @constructor seriesTypes.pie\n         * @augments Series\n         */\n        seriesType('pie', 'line', {\n            center: [null, null],\n            clip: false,\n            colorByPoint: true, // always true for pies\n            dataLabels: {\n                // align: null,\n                // connectorWidth: 1,\n                // connectorColor: point.color,\n                // connectorPadding: 5,\n                distance: 30,\n                enabled: true,\n                formatter: function() { // #2945\n                    return this.point.isNull ? undefined : this.point.name;\n                },\n                // softConnector: true,\n                x: 0\n                // y: 0\n            },\n            ignoreHiddenPoint: true,\n            //innerSize: 0,\n            legendType: 'point',\n            marker: null, // point options are specified in the base options\n            size: null,\n            showInLegend: false,\n            slicedOffset: 10,\n            stickyTracking: false,\n            tooltip: {\n                followPointer: true\n            },\n\n            borderColor: '#ffffff',\n            borderWidth: 1,\n            states: {\n                hover: {\n                    brightness: 0.1,\n                    shadow: false\n                }\n            }\n\n\n        }, /** @lends seriesTypes.pie.prototype */ {\n            isCartesian: false,\n            requireSorting: false,\n            directTouch: true,\n            noSharedTooltip: true,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            axisTypes: [],\n            pointAttribs: seriesTypes.column.prototype.pointAttribs,\n            /**\n             * Animate the pies in\n             */\n            animate: function(init) {\n                var series = this,\n                    points = series.points,\n                    startAngleRad = series.startAngleRad;\n\n                if (!init) {\n                    each(points, function(point) {\n                        var graphic = point.graphic,\n                            args = point.shapeArgs;\n\n                        if (graphic) {\n                            // start values\n                            graphic.attr({\n                                r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)\n                                start: startAngleRad,\n                                end: startAngleRad\n                            });\n\n                            // animate\n                            graphic.animate({\n                                r: args.r,\n                                start: args.start,\n                                end: args.end\n                            }, series.options.animation);\n                        }\n                    });\n\n                    // delete this function to allow it only once\n                    series.animate = null;\n                }\n            },\n\n            /**\n             * Recompute total chart sum and update percentages of points.\n             */\n            updateTotals: function() {\n                var i,\n                    total = 0,\n                    points = this.points,\n                    len = points.length,\n                    point,\n                    ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n                // Get the total sum\n                for (i = 0; i < len; i++) {\n                    point = points[i];\n                    total += (ignoreHiddenPoint && !point.visible) ?\n                        0 :\n                        point.isNull ? 0 : point.y;\n                }\n                this.total = total;\n\n                // Set each point's properties\n                for (i = 0; i < len; i++) {\n                    point = points[i];\n                    point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n                    point.total = total;\n                }\n            },\n\n            /**\n             * Extend the generatePoints method by adding total and percentage properties to each point\n             */\n            generatePoints: function() {\n                Series.prototype.generatePoints.call(this);\n                this.updateTotals();\n            },\n\n            /**\n             * Do translation for pie slices\n             */\n            translate: function(positions) {\n                this.generatePoints();\n\n                var series = this,\n                    cumulative = 0,\n                    precision = 1000, // issue #172\n                    options = series.options,\n                    slicedOffset = options.slicedOffset,\n                    connectorOffset = slicedOffset + (options.borderWidth || 0),\n                    finalConnectorOffset,\n                    start,\n                    end,\n                    angle,\n                    startAngle = options.startAngle || 0,\n                    startAngleRad = series.startAngleRad = Math.PI / 180 * (startAngle - 90),\n                    endAngleRad = series.endAngleRad = Math.PI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n                    circ = endAngleRad - startAngleRad, //2 * Math.PI,\n                    points = series.points,\n                    radiusX, // the x component of the radius vector for a given point\n                    radiusY,\n                    labelDistance = options.dataLabels.distance,\n                    ignoreHiddenPoint = options.ignoreHiddenPoint,\n                    i,\n                    len = points.length,\n                    point;\n\n                // Get positions - either an integer or a percentage string must be given.\n                // If positions are passed as a parameter, we're in a recursive loop for adjusting\n                // space for data labels.\n                if (!positions) {\n                    series.center = positions = series.getCenter();\n                }\n\n                // Utility for getting the x value from a given y, used for anticollision\n                // logic in data labels.\n                // Added point for using specific points' label distance.\n                series.getX = function(y, left, point) {\n                    angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + point.labelDistance), 1));\n                    return positions[0] +\n                        (left ? -1 : 1) *\n                        (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));\n                };\n\n                // Calculate the geometry for each point\n                for (i = 0; i < len; i++) {\n\n                    point = points[i];\n\n                    // Used for distance calculation for specific point.\n                    point.labelDistance = pick(\n                        point.options.dataLabels && point.options.dataLabels.distance,\n                        labelDistance\n                    );\n\n                    // Saved for later dataLabels distance calculation.\n                    series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);\n\n                    // set start and end angle\n                    start = startAngleRad + (cumulative * circ);\n                    if (!ignoreHiddenPoint || point.visible) {\n                        cumulative += point.percentage / 100;\n                    }\n                    end = startAngleRad + (cumulative * circ);\n\n                    // set the shape\n                    point.shapeType = 'arc';\n                    point.shapeArgs = {\n                        x: positions[0],\n                        y: positions[1],\n                        r: positions[2] / 2,\n                        innerR: positions[3] / 2,\n                        start: Math.round(start * precision) / precision,\n                        end: Math.round(end * precision) / precision\n                    };\n\n                    // The angle must stay within -90 and 270 (#2645)\n                    angle = (end + start) / 2;\n                    if (angle > 1.5 * Math.PI) {\n                        angle -= 2 * Math.PI;\n                    } else if (angle < -Math.PI / 2) {\n                        angle += 2 * Math.PI;\n                    }\n\n                    // Center for the sliced out slice\n                    point.slicedTranslation = {\n                        translateX: Math.round(Math.cos(angle) * slicedOffset),\n                        translateY: Math.round(Math.sin(angle) * slicedOffset)\n                    };\n\n                    // set the anchor point for tooltips\n                    radiusX = Math.cos(angle) * positions[2] / 2;\n                    radiusY = Math.sin(angle) * positions[2] / 2;\n                    point.tooltipPos = [\n                        positions[0] + radiusX * 0.7,\n                        positions[1] + radiusY * 0.7\n                    ];\n\n                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;\n                    point.angle = angle;\n\n                    // Set the anchor point for data labels. Use point.labelDistance \n                    // instead of labelDistance // #1174\n                    // finalConnectorOffset - not override connectorOffset value.\n                    finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5); // #1678\n                    point.labelPos = [\n                        positions[0] + radiusX + Math.cos(angle) * point.labelDistance, // first break of connector\n                        positions[1] + radiusY + Math.sin(angle) * point.labelDistance, // a/a\n                        positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset, // second break, right outside pie\n                        positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset, // a/a\n                        positions[0] + radiusX, // landing point for connector\n                        positions[1] + radiusY, // a/a\n                        point.labelDistance < 0 ? // alignment\n                        'center' :\n                        point.half ? 'right' : 'left', // alignment\n                        angle // center angle\n                    ];\n\n                }\n            },\n\n            drawGraph: null,\n\n            /**\n             * Draw the data points\n             */\n            drawPoints: function() {\n                var series = this,\n                    chart = series.chart,\n                    renderer = chart.renderer,\n                    groupTranslation,\n                    //center,\n                    graphic,\n                    //group,\n                    pointAttr,\n                    shapeArgs;\n\n\n                var shadow = series.options.shadow;\n                if (shadow && !series.shadowGroup) {\n                    series.shadowGroup = renderer.g('shadow')\n                        .add(series.group);\n                }\n\n\n                // draw the slices\n                each(series.points, function(point) {\n                    if (!point.isNull) {\n                        graphic = point.graphic;\n                        shapeArgs = point.shapeArgs;\n\n\n                        // If the point is sliced, use special translation, else use\n                        // plot area traslation\n                        groupTranslation = point.getTranslate();\n\n\n                        // Put the shadow behind all points\n                        var shadowGroup = point.shadowGroup;\n                        if (shadow && !shadowGroup) {\n                            shadowGroup = point.shadowGroup = renderer.g('shadow')\n                                .add(series.shadowGroup);\n                        }\n\n                        if (shadowGroup) {\n                            shadowGroup.attr(groupTranslation);\n                        }\n                        pointAttr = series.pointAttribs(point, point.selected && 'select');\n\n\n                        // Draw the slice\n                        if (graphic) {\n                            graphic\n                                .setRadialReference(series.center)\n\n                                .attr(pointAttr)\n\n                                .animate(extend(shapeArgs, groupTranslation));\n                        } else {\n\n                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                                .setRadialReference(series.center)\n                                .attr(groupTranslation)\n                                .add(series.group);\n\n                            if (!point.visible) {\n                                graphic.attr({\n                                    visibility: 'hidden'\n                                });\n                            }\n\n\n                            graphic\n                                .attr(pointAttr)\n                                .attr({\n                                    'stroke-linejoin': 'round'\n                                })\n                                .shadow(shadow, shadowGroup);\n\n                        }\n\n                        graphic.addClass(point.getClassName());\n\n                    }\n                });\n\n            },\n\n\n            searchPoint: noop,\n\n            /**\n             * Utility for sorting data labels\n             */\n            sortByAngle: function(points, sign) {\n                points.sort(function(a, b) {\n                    return a.angle !== undefined && (b.angle - a.angle) * sign;\n                });\n            },\n\n            /**\n             * Use a simple symbol from LegendSymbolMixin\n             */\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n            /**\n             * Use the getCenter method from drawLegendSymbol\n             */\n            getCenter: CenteredSeriesMixin.getCenter,\n\n            /**\n             * Pies don't have point marker symbols\n             */\n            getSymbol: noop\n\n\n            /**\n             * @constructor seriesTypes.pie.prototype.pointClass\n             * @extends {Point}\n             */\n        }, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {\n            /**\n             * Initiate the pie slice\n             */\n            init: function() {\n\n                Point.prototype.init.apply(this, arguments);\n\n                var point = this,\n                    toggleSlice;\n\n                point.name = pick(point.name, 'Slice');\n\n                // add event listener for select\n                toggleSlice = function(e) {\n                    point.slice(e.type === 'select');\n                };\n                addEvent(point, 'select', toggleSlice);\n                addEvent(point, 'unselect', toggleSlice);\n\n                return point;\n            },\n\n            /**\n             * Negative points are not valid (#1530, #3623, #5322)\n             */\n            isValid: function() {\n                return H.isNumber(this.y, true) && this.y >= 0;\n            },\n\n            /**\n             * Toggle the visibility of the pie slice\n             * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n             *    visibility is toggled\n             */\n            setVisible: function(vis, redraw) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n                redraw = pick(redraw, ignoreHiddenPoint);\n\n                if (vis !== point.visible) {\n\n                    // If called without an argument, toggle visibility\n                    point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;\n                    series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                    // Show and hide associated elements. This is performed regardless of redraw or not,\n                    // because chart.redraw only handles full series.\n                    each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function(key) {\n                        if (point[key]) {\n                            point[key][vis ? 'show' : 'hide'](true);\n                        }\n                    });\n\n                    if (point.legendItem) {\n                        chart.legend.colorizeItem(point, vis);\n                    }\n\n                    // #4170, hide halo after hiding point\n                    if (!vis && point.state === 'hover') {\n                        point.setState('');\n                    }\n\n                    // Handle ignore hidden slices\n                    if (ignoreHiddenPoint) {\n                        series.isDirty = true;\n                    }\n\n                    if (redraw) {\n                        chart.redraw();\n                    }\n                }\n            },\n\n            /**\n             * Set or toggle whether the slice is cut out from the pie\n             * @param {Boolean} sliced When undefined, the slice state is toggled\n             * @param {Boolean} redraw Whether to redraw the chart. True by default.\n             */\n            slice: function(sliced, redraw, animation) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart;\n\n                setAnimation(animation, chart);\n\n                // redraw is true by default\n                redraw = pick(redraw, true);\n\n                // if called without an argument, toggle\n                point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                point.graphic.animate(this.getTranslate());\n\n\n                if (point.shadowGroup) {\n                    point.shadowGroup.animate(this.getTranslate());\n                }\n\n            },\n\n            getTranslate: function() {\n                return this.sliced ? this.slicedTranslation : {\n                    translateX: 0,\n                    translateY: 0\n                };\n            },\n\n            haloPath: function(size) {\n                var shapeArgs = this.shapeArgs;\n\n                return this.sliced || !this.visible ? [] :\n                    this.series.chart.renderer.symbols.arc(\n                        shapeArgs.x,\n                        shapeArgs.y,\n                        shapeArgs.r + size,\n                        shapeArgs.r + size, {\n                            innerR: this.shapeArgs.r,\n                            start: shapeArgs.start,\n                            end: shapeArgs.end\n                        }\n                    );\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            arrayMax = H.arrayMax,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            map = H.map,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            relativeLength = H.relativeLength,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            stableSort = H.stableSort;\n\n\n        /**\n         * Generatl distribution algorithm for distributing labels of differing size along a\n         * confined length in two dimensions. The algorithm takes an array of objects containing\n         * a size, a target and a rank. It will place the labels as close as possible to their \n         * targets, skipping the lowest ranked labels if necessary.\n         */\n        H.distribute = function(boxes, len) {\n\n            var i,\n                overlapping = true,\n                origBoxes = boxes, // Original array will be altered with added .pos\n                restBoxes = [], // The outranked overshoot\n                box,\n                target,\n                total = 0;\n\n            function sortByTarget(a, b) {\n                return a.target - b.target;\n            }\n\n            // If the total size exceeds the len, remove those boxes with the lowest rank\n            i = boxes.length;\n            while (i--) {\n                total += boxes[i].size;\n            }\n\n            // Sort by rank, then slice away overshoot\n            if (total > len) {\n                stableSort(boxes, function(a, b) {\n                    return (b.rank || 0) - (a.rank || 0);\n                });\n                i = 0;\n                total = 0;\n                while (total <= len) {\n                    total += boxes[i].size;\n                    i++;\n                }\n                restBoxes = boxes.splice(i - 1, boxes.length);\n            }\n\n            // Order by target\n            stableSort(boxes, sortByTarget);\n\n\n            // So far we have been mutating the original array. Now\n            // create a copy with target arrays\n            boxes = map(boxes, function(box) {\n                return {\n                    size: box.size,\n                    targets: [box.target]\n                };\n            });\n\n            while (overlapping) {\n                // Initial positions: target centered in box\n                i = boxes.length;\n                while (i--) {\n                    box = boxes[i];\n                    // Composite box, average of targets\n                    target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;\n                    box.pos = Math.min(Math.max(0, target - box.size / 2), len - box.size);\n                }\n\n                // Detect overlap and join boxes\n                i = boxes.length;\n                overlapping = false;\n                while (i--) {\n                    if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) { // Overlap\n                        boxes[i - 1].size += boxes[i].size; // Add this size to the previous box\n                        boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);\n\n                        // Overlapping right, push left\n                        if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n                            boxes[i - 1].pos = len - boxes[i - 1].size;\n                        }\n                        boxes.splice(i, 1); // Remove this item\n                        overlapping = true;\n                    }\n                }\n            }\n\n            // Now the composite boxes are placed, we need to put the original boxes within them\n            i = 0;\n            each(boxes, function(box) {\n                var posInCompositeBox = 0;\n                each(box.targets, function() {\n                    origBoxes[i].pos = box.pos + posInCompositeBox;\n                    posInCompositeBox += origBoxes[i].size;\n                    i++;\n                });\n            });\n\n            // Add the rest (hidden) boxes and sort by target\n            origBoxes.push.apply(origBoxes, restBoxes);\n            stableSort(origBoxes, sortByTarget);\n        };\n\n\n        /**\n         * Draw the data labels\n         */\n        Series.prototype.drawDataLabels = function() {\n            var series = this,\n                seriesOptions = series.options,\n                options = seriesOptions.dataLabels,\n                points = series.points,\n                pointOptions,\n                generalOptions,\n                hasRendered = series.hasRendered || 0,\n                str,\n                dataLabelsGroup,\n                defer = pick(options.defer, !!seriesOptions.animation),\n                renderer = series.chart.renderer;\n\n            if (options.enabled || series._hasPointLabels) {\n\n                // Process default alignment of data labels for columns\n                if (series.dlProcessOptions) {\n                    series.dlProcessOptions(options);\n                }\n\n                // Create a separate group for the data labels to avoid rotation\n                dataLabelsGroup = series.plotGroup(\n                    'dataLabelsGroup',\n                    'data-labels',\n                    defer && !hasRendered ? 'hidden' : 'visible', // #5133\n                    options.zIndex || 6\n                );\n\n                if (defer) {\n                    dataLabelsGroup.attr({\n                        opacity: +hasRendered\n                    }); // #3300\n                    if (!hasRendered) {\n                        addEvent(series, 'afterAnimate', function() {\n                            if (series.visible) { // #2597, #3023, #3024\n                                dataLabelsGroup.show(true);\n                            }\n                            dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({\n                                opacity: 1\n                            }, {\n                                duration: 200\n                            });\n                        });\n                    }\n                }\n\n                // Make the labels for each point\n                generalOptions = options;\n                each(points, function(point) {\n                    var enabled,\n                        dataLabel = point.dataLabel,\n                        labelConfig,\n                        attr,\n                        rotation,\n                        connector = point.connector,\n                        isNew = !dataLabel,\n                        style;\n                    // Determine if each data label is enabled\n                    // @note dataLabelAttribs (like pointAttribs) would eradicate\n                    // the need for dlOptions, and simplify the section below.\n                    pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n                    enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n                    if (enabled) {\n                        // Create individual options structure that can be extended without\n                        // affecting others\n                        options = merge(generalOptions, pointOptions);\n                        labelConfig = point.getLabelConfig();\n                        str = options.format ?\n                            format(options.format, labelConfig) :\n                            options.formatter.call(labelConfig, options);\n                        style = options.style;\n                        rotation = options.rotation;\n\n                        // Determine the color\n                        style.color = pick(options.color, style.color, series.color, '#000000');\n                        // Get automated contrast color\n                        if (style.color === 'contrast') {\n                            point.contrastColor = renderer.getContrast(point.color || series.color);\n                            style.color = options.inside || pick(point.labelDistance, options.distance) < 0 ||\n                                !!seriesOptions.stacking ? point.contrastColor : '#000000';\n                        }\n                        if (seriesOptions.cursor) {\n                            style.cursor = seriesOptions.cursor;\n                        }\n\n\n                        attr = {\n                            //align: align,\n\n                            fill: options.backgroundColor,\n                            stroke: options.borderColor,\n                            'stroke-width': options.borderWidth,\n\n                            r: options.borderRadius || 0,\n                            rotation: rotation,\n                            padding: options.padding,\n                            zIndex: 1\n                        };\n\n                        // Remove unused attributes (#947)\n                        H.objectEach(attr, function(val, name) {\n                            if (val === undefined) {\n                                delete attr[name];\n                            }\n                        });\n                    }\n                    // If the point is outside the plot area, destroy it. #678, #820\n                    if (dataLabel && (!enabled || !defined(str))) {\n                        point.dataLabel = dataLabel = dataLabel.destroy();\n                        if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                        // Individual labels are disabled if the are explicitly disabled\n                        // in the point options, or if they fall outside the plot area.\n                    } else if (enabled && defined(str)) {\n                        // create new label\n                        if (!dataLabel) {\n                            dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                                str,\n                                0, -9999,\n                                options.shape,\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'data-label'\n                            );\n                            dataLabel.addClass(\n                                'highcharts-data-label-color-' + point.colorIndex +\n                                ' ' + (options.className || '') +\n                                (options.useHTML ? 'highcharts-tracker' : '') // #3398\n                            );\n                        } else {\n                            attr.text = str;\n                        }\n                        dataLabel.attr(attr);\n\n                        // Styles must be applied before add in order to read text bounding box\n                        dataLabel.css(style).shadow(options.shadow);\n\n\n                        if (!dataLabel.added) {\n                            dataLabel.add(dataLabelsGroup);\n                        }\n                        // Now the data label is created and placed at 0,0, so we need to align it\n                        series.alignDataLabel(point, dataLabel, options, null, isNew);\n                    }\n                });\n            }\n        };\n\n        /**\n         * Align each individual data label\n         */\n        Series.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {\n            var chart = this.chart,\n                inverted = chart.inverted,\n                plotX = pick(point.plotX, -9999),\n                plotY = pick(point.plotY, -9999),\n                bBox = dataLabel.getBBox(),\n                fontSize,\n                baseline,\n                rotation = options.rotation,\n                normRotation,\n                negRotation,\n                align = options.align,\n                rotCorr, // rotation correction\n                // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n                visible =\n                this.visible &&\n                (\n                    point.series.forceDL ||\n                    chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||\n                    (\n                        alignTo && chart.isInsidePlot(\n                            plotX,\n                            inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1,\n                            inverted\n                        )\n                    )\n                ),\n                alignAttr, // the final position;\n                justify = pick(options.overflow, 'justify') === 'justify';\n\n            if (visible) {\n\n\n                fontSize = options.style.fontSize;\n\n\n                baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;\n\n                // The alignment box is a singular point\n                alignTo = extend({\n                    x: inverted ? chart.plotWidth - plotY : plotX,\n                    y: Math.round(inverted ? chart.plotHeight - plotX : plotY),\n                    width: 0,\n                    height: 0\n                }, alignTo);\n\n                // Add the text size for alignment calculation\n                extend(options, {\n                    width: bBox.width,\n                    height: bBox.height\n                });\n\n                // Allow a hook for changing alignment in the last moment, then do the alignment\n                if (rotation) {\n                    justify = false; // Not supported for rotated text\n                    rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n                    alignAttr = {\n                        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                        y: alignTo.y + options.y + {\n                            top: 0,\n                            middle: 0.5,\n                            bottom: 1\n                        }[options.verticalAlign] * alignTo.height\n                    };\n                    dataLabel[isNew ? 'attr' : 'animate'](alignAttr)\n                        .attr({ // #3003\n                            align: align\n                        });\n\n                    // Compensate for the rotated label sticking out on the sides\n                    normRotation = (rotation + 720) % 360;\n                    negRotation = normRotation > 180 && normRotation < 360;\n\n                    if (align === 'left') {\n                        alignAttr.y -= negRotation ? bBox.height : 0;\n                    } else if (align === 'center') {\n                        alignAttr.x -= bBox.width / 2;\n                        alignAttr.y -= bBox.height / 2;\n                    } else if (align === 'right') {\n                        alignAttr.x -= bBox.width;\n                        alignAttr.y -= negRotation ? 0 : bBox.height;\n                    }\n\n\n                } else {\n                    dataLabel.align(options, null, alignTo);\n                    alignAttr = dataLabel.alignAttr;\n                }\n\n                // Handle justify or crop\n                if (justify) {\n                    point.isLabelJustified = this.justifyDataLabel(\n                        dataLabel,\n                        options,\n                        alignAttr,\n                        bBox,\n                        alignTo,\n                        isNew\n                    );\n\n                    // Now check that the data label is within the plot area\n                } else if (pick(options.crop, true)) {\n                    visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n                }\n\n                // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n                if (options.shape && !rotation) {\n                    dataLabel[isNew ? 'attr' : 'animate']({\n                        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,\n                        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY\n                    });\n                }\n            }\n\n            // Show or hide based on the final aligned position\n            if (!visible) {\n                dataLabel.attr({\n                    y: -9999\n                });\n                dataLabel.placed = false; // don't animate back in\n            }\n\n        };\n\n        /**\n         * If data labels fall partly outside the plot area, align them back in, in a way that\n         * doesn't hide the point.\n         */\n        Series.prototype.justifyDataLabel = function(dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n            var chart = this.chart,\n                align = options.align,\n                verticalAlign = options.verticalAlign,\n                off,\n                justified,\n                padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n            // Off left\n            off = alignAttr.x + padding;\n            if (off < 0) {\n                if (align === 'right') {\n                    options.align = 'left';\n                } else {\n                    options.x = -off;\n                }\n                justified = true;\n            }\n\n            // Off right\n            off = alignAttr.x + bBox.width - padding;\n            if (off > chart.plotWidth) {\n                if (align === 'left') {\n                    options.align = 'right';\n                } else {\n                    options.x = chart.plotWidth - off;\n                }\n                justified = true;\n            }\n\n            // Off top\n            off = alignAttr.y + padding;\n            if (off < 0) {\n                if (verticalAlign === 'bottom') {\n                    options.verticalAlign = 'top';\n                } else {\n                    options.y = -off;\n                }\n                justified = true;\n            }\n\n            // Off bottom\n            off = alignAttr.y + bBox.height - padding;\n            if (off > chart.plotHeight) {\n                if (verticalAlign === 'top') {\n                    options.verticalAlign = 'bottom';\n                } else {\n                    options.y = chart.plotHeight - off;\n                }\n                justified = true;\n            }\n\n            if (justified) {\n                dataLabel.placed = !isNew;\n                dataLabel.align(options, null, alignTo);\n            }\n\n            return justified;\n        };\n\n        /**\n         * Override the base drawDataLabels method by pie specific functionality\n         */\n        if (seriesTypes.pie) {\n            seriesTypes.pie.prototype.drawDataLabels = function() {\n                var series = this,\n                    data = series.data,\n                    point,\n                    chart = series.chart,\n                    options = series.options.dataLabels,\n                    connectorPadding = pick(options.connectorPadding, 10),\n                    connectorWidth = pick(options.connectorWidth, 1),\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    connector,\n                    seriesCenter = series.center,\n                    radius = seriesCenter[2] / 2,\n                    centerY = seriesCenter[1],\n                    dataLabel,\n                    dataLabelWidth,\n                    labelPos,\n                    labelHeight,\n                    halves = [ // divide the points into right and left halves for anti collision\n                        [], // right\n                        [] // left\n                    ],\n                    x,\n                    y,\n                    visibility,\n                    j,\n                    overflow = [0, 0, 0, 0]; // top, right, bottom, left\n\n                // get out if not enabled\n                if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n                    return;\n                }\n\n                // Reset all labels that have been shortened\n                each(data, function(point) {\n                    if (point.dataLabel && point.visible && point.dataLabel.shortened) {\n                        point.dataLabel\n                            .attr({\n                                width: 'auto'\n                            }).css({\n                                width: 'auto',\n                                textOverflow: 'clip'\n                            });\n                        point.dataLabel.shortened = false;\n                    }\n                });\n\n\n                // run parent method\n                Series.prototype.drawDataLabels.apply(series);\n\n                each(data, function(point) {\n                    if (point.dataLabel && point.visible) { // #407, #2510\n\n                        // Arrange points for detection collision\n                        halves[point.half].push(point);\n\n                        // Reset positions (#4905)\n                        point.dataLabel._pos = null;\n                    }\n                });\n\n                /* Loop over the points in each half, starting from the top and bottom\n                 * of the pie to detect overlapping labels.\n                 */\n                each(halves, function(points, i) {\n\n                    var top,\n                        bottom,\n                        length = points.length,\n                        positions = [],\n                        naturalY,\n                        sideOverflow,\n                        positionsIndex, // Point index in positions array.\n                        size;\n\n                    if (!length) {\n                        return;\n                    }\n\n                    // Sort by angle\n                    series.sortByAngle(points, i - 0.5);\n                    // Only do anti-collision when we have dataLabels outside the pie \n                    // and have connectors. (#856)\n                    if (series.maxLabelDistance > 0) {\n                        top = Math.max(\n                            0,\n                            centerY - radius - series.maxLabelDistance\n                        );\n                        bottom = Math.min(\n                            centerY + radius + series.maxLabelDistance,\n                            chart.plotHeight\n                        );\n                        each(points, function(point) {\n                            // check if specific points' label is outside the pie\n                            if (point.labelDistance > 0 && point.dataLabel) {\n                                // point.top depends on point.labelDistance value\n                                // Used for calculation of y value in getX method \n                                point.top = Math.max(\n                                    0,\n                                    centerY - radius - point.labelDistance\n                                );\n                                point.bottom = Math.min(\n                                    centerY + radius + point.labelDistance,\n                                    chart.plotHeight\n                                );\n                                size = point.dataLabel.getBBox().height || 21;\n\n                                // point.positionsIndex is needed for getting index of \n                                // parameter related to specific point inside positions \n                                // array - not every point is in positions array.\n                                point.positionsIndex = positions.push({\n                                    target: point.labelPos[1] - point.top + size / 2,\n                                    size: size,\n                                    rank: point.y\n                                }) - 1;\n                            }\n                        });\n                        H.distribute(positions, bottom + size - top);\n                    }\n\n                    // Now the used slots are sorted, fill them up sequentially\n                    for (j = 0; j < length; j++) {\n\n                        point = points[j];\n                        positionsIndex = point.positionsIndex;\n                        labelPos = point.labelPos;\n                        dataLabel = point.dataLabel;\n                        visibility = point.visible === false ? 'hidden' : 'inherit';\n                        naturalY = labelPos[1];\n\n                        if (positions && defined(positions[positionsIndex])) {\n                            if (positions[positionsIndex].pos === undefined) {\n                                visibility = 'hidden';\n                            } else {\n                                labelHeight = positions[positionsIndex].size;\n                                y = point.top + positions[positionsIndex].pos;\n                            }\n\n                        } else {\n                            y = naturalY;\n                        }\n\n                        // It is needed to delete point.positionIndex for \n                        // dynamically added points etc.\n\n                        delete point.positionIndex;\n\n                        // get the x - use the natural x position for labels near the \n                        // top and bottom, to prevent the top and botton slice connectors \n                        // from touching each other on either side\n                        if (options.justify) {\n                            x = seriesCenter[0] + (i ? -1 : 1) * (radius + point.labelDistance);\n                        } else {\n                            x = series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, i, point);\n                        }\n\n\n                        // Record the placement and visibility\n                        dataLabel._attr = {\n                            visibility: visibility,\n                            align: labelPos[6]\n                        };\n                        dataLabel._pos = {\n                            x: x + options.x +\n                                ({\n                                    left: connectorPadding,\n                                    right: -connectorPadding\n                                }[labelPos[6]] || 0),\n                            y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                        };\n                        labelPos.x = x;\n                        labelPos.y = y;\n\n\n                        // Detect overflowing data labels\n                        dataLabelWidth = dataLabel.getBBox().width;\n\n                        sideOverflow = null;\n                        // Overflow left\n                        if (x - dataLabelWidth < connectorPadding) {\n                            sideOverflow = Math.round(\n                                dataLabelWidth - x + connectorPadding\n                            );\n                            overflow[3] = Math.max(sideOverflow, overflow[3]);\n\n                            // Overflow right\n                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                            sideOverflow = Math.round(\n                                x + dataLabelWidth - plotWidth + connectorPadding\n                            );\n                            overflow[1] = Math.max(sideOverflow, overflow[1]);\n                        }\n\n                        // Overflow top\n                        if (y - labelHeight / 2 < 0) {\n                            overflow[0] = Math.max(\n                                Math.round(-y + labelHeight / 2),\n                                overflow[0]\n                            );\n\n                            // Overflow left\n                        } else if (y + labelHeight / 2 > plotHeight) {\n                            overflow[2] = Math.max(\n                                Math.round(y + labelHeight / 2 - plotHeight),\n                                overflow[2]\n                            );\n                        }\n                        dataLabel.sideOverflow = sideOverflow;\n                    } // for each point\n                }); // for each half\n\n                // Do not apply the final placement and draw the connectors until we have verified\n                // that labels are not spilling over.\n                if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n                    // Place the labels in the final position\n                    this.placeDataLabels();\n\n                    // Draw the connectors\n                    if (connectorWidth) {\n                        each(this.points, function(point) {\n                            var isNew;\n\n                            connector = point.connector;\n                            dataLabel = point.dataLabel;\n\n                            if (\n                                dataLabel &&\n                                dataLabel._pos &&\n                                point.visible &&\n                                point.labelDistance > 0\n                            ) {\n                                visibility = dataLabel._attr.visibility;\n\n                                isNew = !connector;\n\n                                if (isNew) {\n                                    point.connector = connector = chart.renderer.path()\n                                        .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)\n                                        .add(series.dataLabelsGroup);\n\n\n                                    connector.attr({\n                                        'stroke-width': connectorWidth,\n                                        'stroke': options.connectorColor || point.color || '#666666'\n                                    });\n\n                                }\n                                connector[isNew ? 'attr' : 'animate']({\n                                    d: series.connectorPath(point.labelPos)\n                                });\n                                connector.attr('visibility', visibility);\n\n                            } else if (connector) {\n                                point.connector = connector.destroy();\n                            }\n                        });\n                    }\n                }\n            };\n\n            /**\n             * Extendable method for getting the path of the connector between the data label\n             * and the pie slice.\n             */\n            seriesTypes.pie.prototype.connectorPath = function(labelPos) {\n                var x = labelPos.x,\n                    y = labelPos.y;\n                return pick(this.options.dataLabels.softConnector, true) ? [\n                    'M',\n                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                    'C',\n                    x, y, // first break, next to the label\n                    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                    labelPos[2], labelPos[3], // second break\n                    'L',\n                    labelPos[4], labelPos[5] // base\n                ] : [\n                    'M',\n                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                    'L',\n                    labelPos[2], labelPos[3], // second break\n                    'L',\n                    labelPos[4], labelPos[5] // base\n                ];\n            };\n\n            /**\n             * Perform the final placement of the data labels after we have verified that they\n             * fall within the plot area.\n             */\n            seriesTypes.pie.prototype.placeDataLabels = function() {\n                each(this.points, function(point) {\n                    var dataLabel = point.dataLabel,\n                        _pos;\n                    if (dataLabel && point.visible) {\n                        _pos = dataLabel._pos;\n                        if (_pos) {\n\n                            // Shorten data labels with ellipsis if they still overflow\n                            // after the pie has reached minSize (#223).\n                            if (dataLabel.sideOverflow) {\n                                dataLabel._attr.width =\n                                    dataLabel.getBBox().width - dataLabel.sideOverflow;\n                                dataLabel.css({\n                                    width: dataLabel._attr.width + 'px',\n                                    textOverflow: 'ellipsis'\n                                });\n                                dataLabel.shortened = true;\n                            }\n\n                            dataLabel.attr(dataLabel._attr);\n                            dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                            dataLabel.moved = true;\n                        } else if (dataLabel) {\n                            dataLabel.attr({\n                                y: -9999\n                            });\n                        }\n                    }\n                }, this);\n            };\n\n            seriesTypes.pie.prototype.alignDataLabel = noop;\n\n            /**\n             * Verify whether the data labels are allowed to draw, or we should run more translation and data\n             * label positioning to keep them inside the plot area. Returns true when data labels are ready\n             * to draw.\n             */\n            seriesTypes.pie.prototype.verifyDataLabelOverflow = function(overflow) {\n\n                var center = this.center,\n                    options = this.options,\n                    centerOption = options.center,\n                    minSize = options.minSize || 80,\n                    newSize = minSize,\n                    // If a size is set, return true and don't try to shrink the pie\n                    // to fit the labels.\n                    ret = options.size !== null;\n\n                if (!ret) {\n                    // Handle horizontal size and center\n                    if (centerOption[0] !== null) { // Fixed center\n                        newSize = Math.max(center[2] -\n                            Math.max(overflow[1], overflow[3]), minSize);\n\n                    } else { // Auto center\n                        newSize = Math.max(\n                            // horizontal overflow\n                            center[2] - overflow[1] - overflow[3],\n                            minSize\n                        );\n                        // horizontal center\n                        center[0] += (overflow[3] - overflow[1]) / 2;\n                    }\n\n                    // Handle vertical size and center\n                    if (centerOption[1] !== null) { // Fixed center\n                        newSize = Math.max(Math.min(newSize, center[2] -\n                            Math.max(overflow[0], overflow[2])), minSize);\n\n                    } else { // Auto center\n                        newSize = Math.max(\n                            Math.min(\n                                newSize,\n                                // vertical overflow\n                                center[2] - overflow[0] - overflow[2]\n                            ),\n                            minSize\n                        );\n                        // vertical center\n                        center[1] += (overflow[0] - overflow[2]) / 2;\n                    }\n\n                    // If the size must be decreased, we need to run translate and\n                    // drawDataLabels again\n                    if (newSize < center[2]) {\n                        center[2] = newSize;\n                        center[3] = Math.min( // #3632\n                            relativeLength(options.innerSize || 0, newSize),\n                            newSize\n                        );\n                        this.translate(center);\n\n                        if (this.drawDataLabels) {\n                            this.drawDataLabels();\n                        }\n                        // Else, return true to indicate that the pie and its labels is\n                        // within the plot area\n                    } else {\n                        ret = true;\n                    }\n                }\n                return ret;\n            };\n        }\n\n        if (seriesTypes.column) {\n\n            /**\n             * Override the basic data label alignment by adjusting for the position of the column\n             */\n            seriesTypes.column.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {\n                var inverted = this.chart.inverted,\n                    series = point.series,\n                    dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n                    below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n                    inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n                    overshoot;\n\n                // Align to the column itself, or the top of it\n                if (dlBox) { // Area range uses this method but not alignTo\n                    alignTo = merge(dlBox);\n\n                    if (alignTo.y < 0) {\n                        alignTo.height += alignTo.y;\n                        alignTo.y = 0;\n                    }\n                    overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n                    if (overshoot > 0) {\n                        alignTo.height -= overshoot;\n                    }\n\n                    if (inverted) {\n                        alignTo = {\n                            x: series.yAxis.len - alignTo.y - alignTo.height,\n                            y: series.xAxis.len - alignTo.x - alignTo.width,\n                            width: alignTo.height,\n                            height: alignTo.width\n                        };\n                    }\n\n                    // Compute the alignment box\n                    if (!inside) {\n                        if (inverted) {\n                            alignTo.x += below ? 0 : alignTo.width;\n                            alignTo.width = 0;\n                        } else {\n                            alignTo.y += below ? alignTo.height : 0;\n                            alignTo.height = 0;\n                        }\n                    }\n                }\n\n\n                // When alignment is undefined (typically columns and bars), display the individual\n                // point below or above the point depending on the threshold\n                options.align = pick(\n                    options.align, !inverted || inside ? 'center' : below ? 'right' : 'left'\n                );\n                options.verticalAlign = pick(\n                    options.verticalAlign,\n                    inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n                );\n\n                // Call the parent method\n                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n\n                // If label was justified and we have contrast, set it:\n                if (point.isLabelJustified && point.contrastColor) {\n                    point.dataLabel.css({\n                        color: point.contrastColor\n                    });\n                }\n            };\n        }\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2009-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /**\n         * Highcharts module to hide overlapping data labels. This module is included in\n         * Highcharts.\n         */\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need\n        // to be considered because they are usually accompanied by data labels that lie\n        // inside the columns.\n        Chart.prototype.callbacks.push(function(chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series || [], function(series) {\n                    var dlOptions = series.options.dataLabels,\n                        // Range series have two collections\n                        collections = series.dataLabelCollections || ['dataLabel'];\n\n                    if (\n                        (dlOptions.enabled || series._hasPointLabels) &&\n                        !dlOptions.allowOverlap &&\n                        series.visible\n                    ) { // #3866\n                        each(collections, function(coll) {\n                            each(series.points, function(point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(\n                                        point.labelrank,\n                                        point.shapeArgs && point.shapeArgs.height\n                                    ); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to\n         * provide a smooth visual imression.\n         */\n        Chart.prototype.hideOverlappingLabels = function(labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n\n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label will\n            // hide the previous one because the previous one always has lower rank.\n            labels.sort(function(a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (\n                        label1 && label2 &&\n                        label1 !== label2 && // #6465, polar chart with connectEnds\n                        label1.placed && label2.placed &&\n                        label1.newOpacity !== 0 && label2.newOpacity !== 0\n                    ) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        // Different panes have different positions\n                        parent1 = label1.parentGroup;\n                        parent2 = label2.parentGroup;\n                        // Substract the padding if no background or border (#4333)\n                        padding = 2 * (label1.box ? 0 : label1.padding);\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2)\n                            .newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function(label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching\n                        // clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function() {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity\t\t\t\t\t\n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](\n                            label.alignAttr,\n                            null,\n                            complete\n                        );\n\n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            hasTouch = H.hasTouch,\n            inArray = H.inArray,\n            isObject = H.isObject,\n            Legend = H.Legend,\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            svg = H.svg,\n            TrackerMixin;\n\n        /**\n         * TrackerMixin for points and graphs.\n         *\n         * @mixin\n         */\n        TrackerMixin = H.TrackerMixin = {\n\n            /**\n             * Draw the tracker for a point.\n             */\n            drawTrackerPoint: function() {\n                var series = this,\n                    chart = series.chart,\n                    pointer = chart.pointer,\n                    onMouseOver = function(e) {\n                        var point = pointer.getPointFromEvent(e);\n                        // undefined on graph in scatterchart\n                        if (point !== undefined) {\n                            pointer.isDirectTouch = true;\n                            point.onMouseOver(e);\n                        }\n                    };\n\n                // Add reference to the point\n                each(series.points, function(point) {\n                    if (point.graphic) {\n                        point.graphic.element.point = point;\n                    }\n                    if (point.dataLabel) {\n                        if (point.dataLabel.div) {\n                            point.dataLabel.div.point = point;\n                        } else {\n                            point.dataLabel.element.point = point;\n                        }\n                    }\n                });\n\n                // Add the event listeners, we need to do this only once\n                if (!series._hasTracking) {\n                    each(series.trackerGroups, function(key) {\n                        if (series[key]) { // we don't always have dataLabelsGroup\n                            series[key]\n                                .addClass('highcharts-tracker')\n                                .on('mouseover', onMouseOver)\n                                .on('mouseout', function(e) {\n                                    pointer.onTrackerMouseOut(e);\n                                });\n                            if (hasTouch) {\n                                series[key].on('touchstart', onMouseOver);\n                            }\n\n\n                            if (series.options.cursor) {\n                                series[key]\n                                    .css(css)\n                                    .css({\n                                        cursor: series.options.cursor\n                                    });\n                            }\n\n                        }\n                    });\n                    series._hasTracking = true;\n                }\n            },\n\n            /**\n             * Draw the tracker object that sits above all data labels and markers to\n             * track mouse events on the graph or points. For the line type charts\n             * the tracker uses the same graphPath, but with a greater stroke width\n             * for better control.\n             */\n            drawTrackerGraph: function() {\n                var series = this,\n                    options = series.options,\n                    trackByArea = options.trackByArea,\n                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n                    trackerPathLength = trackerPath.length,\n                    chart = series.chart,\n                    pointer = chart.pointer,\n                    renderer = chart.renderer,\n                    snap = chart.options.tooltip.snap,\n                    tracker = series.tracker,\n                    i,\n                    onMouseOver = function() {\n                        if (chart.hoverSeries !== series) {\n                            series.onMouseOver();\n                        }\n                    },\n                    /*\n                     * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n                     * IE6: 0.002\n                     * IE7: 0.002\n                     * IE8: 0.002\n                     * IE9: 0.00000000001 (unlimited)\n                     * IE10: 0.0001 (exporting only)\n                     * FF: 0.00000000001 (unlimited)\n                     * Chrome: 0.000001\n                     * Safari: 0.000001\n                     * Opera: 0.00000000001 (unlimited)\n                     */\n                    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n\n                // Extend end points. A better way would be to use round linecaps,\n                // but those are not clickable in VML.\n                if (trackerPathLength && !trackByArea) {\n                    i = trackerPathLength + 1;\n                    while (i--) {\n                        if (trackerPath[i] === 'M') { // extend left side\n                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n                        }\n                        if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side\n                            trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                        }\n                    }\n                }\n\n                // handle single points\n                /*for (i = 0; i < singlePoints.length; i++) {\n                \tsinglePoint = singlePoints[i];\n                \ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n                \tL, singlePoint.plotX + snap, singlePoint.plotY);\n                }*/\n\n                // draw the tracker\n                if (tracker) {\n                    tracker.attr({\n                        d: trackerPath\n                    });\n                } else if (series.graph) { // create\n\n                    series.tracker = renderer.path(trackerPath)\n                        .attr({\n                            'stroke-linejoin': 'round', // #1225\n                            visibility: series.visible ? 'visible' : 'hidden',\n                            stroke: TRACKER_FILL,\n                            fill: trackByArea ? TRACKER_FILL : 'none',\n                            'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),\n                            zIndex: 2\n                        })\n                        .add(series.group);\n\n                    // The tracker is added to the series group, which is clipped, but is covered\n                    // by the marker group. So the marker group also needs to capture events.\n                    each([series.tracker, series.markerGroup], function(tracker) {\n                        tracker.addClass('highcharts-tracker')\n                            .on('mouseover', onMouseOver)\n                            .on('mouseout', function(e) {\n                                pointer.onTrackerMouseOut(e);\n                            });\n\n\n                        if (options.cursor) {\n                            tracker.css({\n                                cursor: options.cursor\n                            });\n                        }\n\n\n                        if (hasTouch) {\n                            tracker.on('touchstart', onMouseOver);\n                        }\n                    });\n                }\n            }\n        };\n        /* End TrackerMixin */\n\n\n        /**\n         * Add tracking event listener to the series group, so the point graphics\n         * themselves act as trackers\n         */\n\n        if (seriesTypes.column) {\n            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        if (seriesTypes.pie) {\n            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        if (seriesTypes.scatter) {\n            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        /*\n         * Extend Legend for item events\n         */\n        extend(Legend.prototype, {\n\n            setItemEvents: function(item, legendItem, useHTML) {\n                var legend = this,\n                    boxWrapper = legend.chart.renderer.boxWrapper,\n                    activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';\n\n                // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n                (useHTML ? legendItem : item.legendGroup).on('mouseover', function() {\n                        item.setState('hover');\n\n                        // A CSS class to dim or hide other than the hovered series\n                        boxWrapper.addClass(activeClass);\n\n\n                        legendItem.css(legend.options.itemHoverStyle);\n\n                    })\n                    .on('mouseout', function() {\n\n                        legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));\n\n\n                        // A CSS class to dim or hide other than the hovered series\n                        boxWrapper.removeClass(activeClass);\n\n                        item.setState();\n                    })\n                    .on('click', function(event) {\n                        var strLegendItemClick = 'legendItemClick',\n                            fnLegendItemClick = function() {\n                                if (item.setVisible) {\n                                    item.setVisible();\n                                }\n                            };\n\n                        // Pass over the click/touch event. #4.\n                        event = {\n                            browserEvent: event\n                        };\n\n                        // click the name or symbol\n                        if (item.firePointEvent) { // point\n                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                        } else {\n                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                        }\n                    });\n            },\n\n            createCheckboxForItem: function(item) {\n                var legend = this;\n\n                item.checkbox = createElement('input', {\n                    type: 'checkbox',\n                    checked: item.selected,\n                    defaultChecked: item.selected // required by IE7\n                }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n                addEvent(item.checkbox, 'click', function(event) {\n                    var target = event.target;\n                    fireEvent(\n                        item.series || item,\n                        'checkboxClick', { // #3712\n                            checked: target.checked,\n                            item: item\n                        },\n                        function() {\n                            item.select();\n                        }\n                    );\n                });\n            }\n        });\n\n\n\n        // Add pointer cursor to legend itemstyle in defaultOptions\n        defaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n\n        /*\n         * Extend the Chart object with interaction\n         */\n\n        extend(Chart.prototype, /** @lends Chart.prototype */ {\n            /**\n             * Display the zoom button\n             */\n            showResetZoom: function() {\n                var chart = this,\n                    lang = defaultOptions.lang,\n                    btnOptions = chart.options.chart.resetZoomButton,\n                    theme = btnOptions.theme,\n                    states = theme.states,\n                    alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n                function zoomOut() {\n                    chart.zoomOut();\n                }\n\n                this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n                    .attr({\n                        align: btnOptions.position.align,\n                        title: lang.resetZoomTitle\n                    })\n                    .addClass('highcharts-reset-zoom')\n                    .add()\n                    .align(btnOptions.position, false, alignTo);\n\n            },\n\n            /**\n             * Zoom out to 1:1\n             */\n            zoomOut: function() {\n                var chart = this;\n                fireEvent(chart, 'selection', {\n                    resetSelection: true\n                }, function() {\n                    chart.zoom();\n                });\n            },\n\n            /**\n             * Zoom into a given portion of the chart given by axis coordinates\n             * @param {Object} event\n             */\n            zoom: function(event) {\n                var chart = this,\n                    hasZoomed,\n                    pointer = chart.pointer,\n                    displayButton = false,\n                    resetZoomButton;\n\n                // If zoom is called with no arguments, reset the axes\n                if (!event || event.resetSelection) {\n                    each(chart.axes, function(axis) {\n                        hasZoomed = axis.zoom();\n                    });\n                } else { // else, zoom in on all axes\n                    each(event.xAxis.concat(event.yAxis), function(axisData) {\n                        var axis = axisData.axis,\n                            isXAxis = axis.isXAxis;\n\n                        // don't zoom more than minRange\n                        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {\n                            hasZoomed = axis.zoom(axisData.min, axisData.max);\n                            if (axis.displayBtn) {\n                                displayButton = true;\n                            }\n                        }\n                    });\n                }\n\n                // Show or hide the Reset zoom button\n                resetZoomButton = chart.resetZoomButton;\n                if (displayButton && !resetZoomButton) {\n                    chart.showResetZoom();\n                } else if (!displayButton && isObject(resetZoomButton)) {\n                    chart.resetZoomButton = resetZoomButton.destroy();\n                }\n\n\n                // Redraw\n                if (hasZoomed) {\n                    chart.redraw(\n                        pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n                    );\n                }\n            },\n\n            /**\n             * Pan the chart by dragging the mouse across the pane. This function is called\n             * on mouse move, and the distance to pan is computed from chartX compared to\n             * the first chartX position in the dragging operation.\n             */\n            pan: function(e, panning) {\n\n                var chart = this,\n                    hoverPoints = chart.hoverPoints,\n                    doRedraw;\n\n                // remove active points for shared tooltip\n                if (hoverPoints) {\n                    each(hoverPoints, function(point) {\n                        point.setState();\n                    });\n                }\n\n                each(panning === 'xy' ? [1, 0] : [1], function(isX) { // xy is used in maps\n                    var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                        horiz = axis.horiz,\n                        mousePos = e[horiz ? 'chartX' : 'chartY'],\n                        mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                        startPos = chart[mouseDown],\n                        halfPointRange = (axis.pointRange || 0) / 2,\n                        extremes = axis.getExtremes(),\n                        panMin = axis.toValue(startPos - mousePos, true) +\n                        halfPointRange,\n                        panMax = axis.toValue(startPos + axis.len - mousePos, true) -\n                        halfPointRange,\n                        flipped = panMax < panMin,\n                        newMin = flipped ? panMax : panMin,\n                        newMax = flipped ? panMin : panMax,\n                        paddedMin = Math.min(\n                            extremes.dataMin,\n                            axis.toValue(\n                                axis.toPixels(extremes.min) - axis.minPixelPadding\n                            )\n                        ),\n                        paddedMax = Math.max(\n                            extremes.dataMax,\n                            axis.toValue(\n                                axis.toPixels(extremes.max) + axis.minPixelPadding\n                            )\n                        ),\n                        spill;\n\n                    // If the new range spills over, either to the min or max, adjust\n                    // the new range.\n                    spill = paddedMin - newMin;\n                    if (spill > 0) {\n                        newMax += spill;\n                        newMin = paddedMin;\n                    }\n                    spill = newMax - paddedMax;\n                    if (spill > 0) {\n                        newMax = paddedMax;\n                        newMin -= spill;\n                    }\n\n                    // Set new extremes if they are actually new\n                    if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {\n                        axis.setExtremes(\n                            newMin,\n                            newMax,\n                            false,\n                            false, {\n                                trigger: 'pan'\n                            }\n                        );\n                        doRedraw = true;\n                    }\n\n                    chart[mouseDown] = mousePos; // set new reference for next run\n                });\n\n                if (doRedraw) {\n                    chart.redraw(false);\n                }\n                css(chart.container, {\n                    cursor: 'move'\n                });\n            }\n        });\n\n        /*\n         * Extend the Point object with interaction\n         */\n        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n            /**\n             * Toggle the selection status of a point.\n             * @param  {Boolean} [selected]\n             *         When `true`, the point is selected. When `false`, the point is\n             *         unselected. When `null` or `undefined`, the selection state is\n             *         toggled.\n             * @param  {Boolean} [accumulate=false]\n             *         When `true`, the selection is added to other selected points.\n             *         When `false`, other selected points are deselected. Internally in\n             *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}\n             *         is `true`, selected points are accumulated on Control, Shift or\n             *         Cmd clicking the point.\n             *\n             * @see    Highcharts.Chart#getSelectedPoints\n             *\n             * @sample highcharts/members/point-select/\n             *         Select a point from a button\n             * @sample highcharts/chart/events-selection-points/\n             *         Select a range of points through a drag selection\n             * @sample maps/series/data-id/\n             *         Select a point in Highmaps\n             */\n            select: function(selected, accumulate) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart;\n\n                selected = pick(selected, !point.selected);\n\n                // fire the event with the default handler\n                point.firePointEvent(selected ? 'select' : 'unselect', {\n                    accumulate: accumulate\n                }, function() {\n\n                    /**\n                     * Whether the point is selected or not. \n                     * @see Highcharts.Point#select\n                     * @memberof Highcharts.Point\n                     * @name selected\n                     * @type {Boolean}\n                     */\n                    point.selected = point.options.selected = selected;\n                    series.options.data[inArray(point, series.data)] = point.options;\n\n                    point.setState(selected && 'select');\n\n                    // unselect all other points unless Ctrl or Cmd + click\n                    if (!accumulate) {\n                        each(chart.getSelectedPoints(), function(loopPoint) {\n                            if (loopPoint.selected && loopPoint !== point) {\n                                loopPoint.selected = loopPoint.options.selected = false;\n                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                                loopPoint.setState('');\n                                loopPoint.firePointEvent('unselect');\n                            }\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Runs on mouse over the point\n             * \n             * @param {Object} e The event arguments\n             */\n            onMouseOver: function(e) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    pointer = chart.pointer;\n                e = e ?\n                    pointer.normalize(e) :\n                    // In cases where onMouseOver is called directly without an event\n                    pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n                pointer.runPointActions(e, point);\n            },\n\n            /**\n             * Runs on mouse out from the point\n             */\n            onMouseOut: function() {\n                var point = this,\n                    chart = point.series.chart;\n                point.firePointEvent('mouseOut');\n                each(chart.hoverPoints || [], function(p) {\n                    p.setState();\n                });\n                chart.hoverPoints = chart.hoverPoint = null;\n            },\n\n            /**\n             * Import events from the series' and point's options. Only do it on\n             * demand, to save processing time on hovering.\n             */\n            importEvents: function() {\n                if (!this.hasImportedEvents) {\n                    var point = this,\n                        options = merge(point.series.options.point, point.options),\n                        events = options.events;\n\n                    point.events = events;\n\n                    H.objectEach(events, function(event, eventType) {\n                        addEvent(point, eventType, event);\n                    });\n                    this.hasImportedEvents = true;\n\n                }\n            },\n\n            /**\n             * Set the point's state\n             * @param {String} state\n             */\n            setState: function(state, move) {\n                var point = this,\n                    plotX = Math.floor(point.plotX), // #4586\n                    plotY = point.plotY,\n                    series = point.series,\n                    stateOptions = series.options.states[state] || {},\n                    markerOptions = defaultPlotOptions[series.type].marker &&\n                    series.options.marker,\n                    normalDisabled = markerOptions && markerOptions.enabled === false,\n                    markerStateOptions = (markerOptions && markerOptions.states &&\n                        markerOptions.states[state]) || {},\n                    stateDisabled = markerStateOptions.enabled === false,\n                    stateMarkerGraphic = series.stateMarkerGraphic,\n                    pointMarker = point.marker || {},\n                    chart = series.chart,\n                    halo = series.halo,\n                    haloOptions,\n                    markerAttribs,\n                    hasMarkers = markerOptions && series.markerAttribs,\n                    newSymbol;\n\n                state = state || ''; // empty string\n\n                if (\n                    // already has this state\n                    (state === point.state && !move) ||\n                    // selected points don't respond to hover\n                    (point.selected && state !== 'select') ||\n                    // series' state options is disabled\n                    (stateOptions.enabled === false) ||\n                    // general point marker's state options is disabled\n                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                    // individual point marker's state options is disabled\n                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n                ) {\n                    return;\n                }\n\n                if (hasMarkers) {\n                    markerAttribs = series.markerAttribs(point, state);\n                }\n\n                // Apply hover styles to the existing point\n                if (point.graphic) {\n\n                    if (point.state) {\n                        point.graphic.removeClass('highcharts-point-' + point.state);\n                    }\n                    if (state) {\n                        point.graphic.addClass('highcharts-point-' + state);\n                    }\n\n                    /*attribs = radius ? { // new symbol attributes (#507, #612)\n                    \tx: plotX - radius,\n                    \ty: plotY - radius,\n                    \twidth: 2 * radius,\n                    \theight: 2 * radius\n                    } : {};*/\n\n\n                    //attribs = merge(series.pointAttribs(point, state), attribs);\n                    point.graphic.attr(series.pointAttribs(point, state));\n\n\n                    if (markerAttribs) {\n                        point.graphic.animate(\n                            markerAttribs,\n                            pick(\n                                chart.options.chart.animation, // Turn off globally\n                                markerStateOptions.animation,\n                                markerOptions.animation\n                            )\n                        );\n                    }\n\n                    // Zooming in from a range with no markers to a range with markers\n                    if (stateMarkerGraphic) {\n                        stateMarkerGraphic.hide();\n                    }\n                } else {\n                    // if a graphic is not applied to each point in the normal state, create a shared\n                    // graphic for the hover state\n                    if (state && markerStateOptions) {\n                        newSymbol = pointMarker.symbol || series.symbol;\n\n                        // If the point has another symbol than the previous one, throw away the\n                        // state marker graphic and force a new one (#1459)\n                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                            stateMarkerGraphic = stateMarkerGraphic.destroy();\n                        }\n\n                        // Add a new state marker graphic\n                        if (!stateMarkerGraphic) {\n                            if (newSymbol) {\n                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                                        newSymbol,\n                                        markerAttribs.x,\n                                        markerAttribs.y,\n                                        markerAttribs.width,\n                                        markerAttribs.height\n                                    )\n                                    .add(series.markerGroup);\n                                stateMarkerGraphic.currentSymbol = newSymbol;\n                            }\n\n                            // Move the existing graphic\n                        } else {\n                            stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                                x: markerAttribs.x,\n                                y: markerAttribs.y\n                            });\n                        }\n\n                        if (stateMarkerGraphic) {\n                            stateMarkerGraphic.attr(series.pointAttribs(point, state));\n                        }\n\n                    }\n\n                    if (stateMarkerGraphic) {\n                        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                        stateMarkerGraphic.element.point = point; // #4310\n                    }\n                }\n\n                // Show me your halo\n                haloOptions = stateOptions.halo;\n                if (haloOptions && haloOptions.size) {\n                    if (!halo) {\n                        series.halo = halo = chart.renderer.path()\n                            // #5818, #5903, #6705\n                            .add((point.graphic || stateMarkerGraphic).parentGroup);\n                    }\n                    halo[move ? 'animate' : 'attr']({\n                        d: point.haloPath(haloOptions.size)\n                    });\n                    halo.attr({\n                        'class': 'highcharts-halo highcharts-color-' +\n                            pick(point.colorIndex, series.colorIndex)\n                    });\n                    halo.point = point; // #6055\n\n\n                    halo.attr(extend({\n                        'fill': point.color || series.color,\n                        'fill-opacity': haloOptions.opacity,\n                        'zIndex': -1 // #4929, IE8 added halo above everything\n                    }, haloOptions.attributes));\n\n\n                } else if (halo && halo.point && halo.point.haloPath) {\n                    // Animate back to 0 on the current halo point (#6055)\n                    halo.animate({\n                        d: halo.point.haloPath(0)\n                    });\n                }\n\n                point.state = state;\n            },\n\n            /**\n             * Get the circular path definition for the halo\n             * @param  {Number} size The radius of the circular halo.\n             * @returns {Array} The path definition\n             */\n            haloPath: function(size) {\n                var series = this.series,\n                    chart = series.chart;\n\n                return chart.renderer.symbols.circle(\n                    Math.floor(this.plotX) - size,\n                    this.plotY - size,\n                    size * 2,\n                    size * 2\n                );\n            }\n        });\n\n        /*\n         * Extend the Series object with interaction\n         */\n\n        extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {\n            /**\n             * Series mouse over handler\n             */\n            onMouseOver: function() {\n                var series = this,\n                    chart = series.chart,\n                    hoverSeries = chart.hoverSeries;\n\n                // set normal state to previous series\n                if (hoverSeries && hoverSeries !== series) {\n                    hoverSeries.onMouseOut();\n                }\n\n                // trigger the event, but to save processing time,\n                // only if defined\n                if (series.options.events.mouseOver) {\n                    fireEvent(series, 'mouseOver');\n                }\n\n                // hover this\n                series.setState('hover');\n                chart.hoverSeries = series;\n            },\n\n            /**\n             * Series mouse out handler\n             */\n            onMouseOut: function() {\n                // trigger the event only if listeners exist\n                var series = this,\n                    options = series.options,\n                    chart = series.chart,\n                    tooltip = chart.tooltip,\n                    hoverPoint = chart.hoverPoint;\n\n                chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n                // trigger mouse out on the point, which must be in this series\n                if (hoverPoint) {\n                    hoverPoint.onMouseOut();\n                }\n\n                // fire the mouse out event\n                if (series && options.events.mouseOut) {\n                    fireEvent(series, 'mouseOut');\n                }\n\n\n                // hide the tooltip\n                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n                    tooltip.hide();\n                }\n\n                // set normal state\n                series.setState();\n            },\n\n            /**\n             * Set the state of the graph\n             */\n            setState: function(state) {\n                var series = this,\n                    options = series.options,\n                    graph = series.graph,\n                    stateOptions = options.states,\n                    lineWidth = options.lineWidth,\n                    attribs,\n                    i = 0;\n\n                state = state || '';\n\n                if (series.state !== state) {\n\n                    // Toggle class names\n                    each([\n                        series.group,\n                        series.markerGroup,\n                        series.dataLabelsGroup\n                    ], function(group) {\n                        if (group) {\n                            // Old state\n                            if (series.state) {\n                                group.removeClass('highcharts-series-' + series.state);\n                            }\n                            // New state\n                            if (state) {\n                                group.addClass('highcharts-series-' + state);\n                            }\n                        }\n                    });\n\n                    series.state = state;\n\n\n\n                    if (stateOptions[state] && stateOptions[state].enabled === false) {\n                        return;\n                    }\n\n                    if (state) {\n                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n                    }\n\n                    if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                        attribs = {\n                            'stroke-width': lineWidth\n                        };\n\n                        // Animate the graph stroke-width. By default a quick animation\n                        // to hover, slower to un-hover.\n                        graph.animate(\n                            attribs,\n                            pick(\n                                series.chart.options.chart.animation,\n                                stateOptions[state] && stateOptions[state].animation\n                            )\n                        );\n                        while (series['zone-graph-' + i]) {\n                            series['zone-graph-' + i].attr(attribs);\n                            i = i + 1;\n                        }\n                    }\n\n                }\n            },\n\n            /**\n             * Show or hide the series.\n             *\n             * @param  {Boolean} [visible]\n             *         True to show the series, false to hide. If undefined, the\n             *         visibility is toggled.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw|chart.redraw()} after.\n             */\n            setVisible: function(vis, redraw) {\n                var series = this,\n                    chart = series.chart,\n                    legendItem = series.legendItem,\n                    showOrHide,\n                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n                    oldVisibility = series.visible;\n\n                // if called without an argument, toggle visibility\n                series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618\n                showOrHide = vis ? 'show' : 'hide';\n\n                // show or hide elements\n                each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function(key) {\n                    if (series[key]) {\n                        series[key][showOrHide]();\n                    }\n                });\n\n\n                // hide tooltip (#1361)\n                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n                    series.onMouseOut();\n                }\n\n\n                if (legendItem) {\n                    chart.legend.colorizeItem(series, vis);\n                }\n\n\n                // rescale or adapt to resized chart\n                series.isDirty = true;\n                // in a stack, all other series are affected\n                if (series.options.stacking) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.options.stacking && otherSeries.visible) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n\n                // show or hide linked series\n                each(series.linkedSeries, function(otherSeries) {\n                    otherSeries.setVisible(vis, false);\n                });\n\n                if (ignoreHiddenSeries) {\n                    chart.isDirtyBox = true;\n                }\n                if (redraw !== false) {\n                    chart.redraw();\n                }\n\n                fireEvent(series, showOrHide);\n            },\n\n            /**\n             * Show the series if hidden.\n             *\n             * @sample highcharts/members/series-hide/\n             *         Toggle visibility from a button\n             */\n            show: function() {\n                this.setVisible(true);\n            },\n\n            /**\n             * Hide the series if visible. If the {@link\n             * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|\n             * chart.ignoreHiddenSeries} option is true, the chart is redrawn without\n             * this series.\n             *\n             * @sample highcharts/members/series-hide/\n             *         Toggle visibility from a button\n             */\n            hide: function() {\n                this.setVisible(false);\n            },\n\n\n            /**\n             * Select or unselect the series. This means its {@link\n             * Highcharts.Series.selected|selected} property is set, the checkbox in the\n             * legend is toggled and when selected, the series is returned by the\n             * {@link Highcharts.Chart#getSelectedSeries} function.\n             *\n             * @param  {Boolean} [selected]\n             *         True to select the series, false to unselect. If\tundefined, the\n             *         selection state is toggled.\n             *\n             * @sample highcharts/members/series-select/\n             *         Select a series from a button\n             */\n            select: function(selected) {\n                var series = this;\n\n                series.selected = selected = (selected === undefined) ?\n                    !series.selected :\n                    selected;\n\n                if (series.checkbox) {\n                    series.checkbox.checked = selected;\n                }\n\n                fireEvent(series, selected ? 'select' : 'unselect');\n            },\n\n            drawTracker: TrackerMixin.drawTrackerGraph\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Chart = H.Chart,\n            each = H.each,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isObject = H.isObject,\n            pick = H.pick,\n            splat = H.splat;\n\n        /**\n         * Update the chart based on the current chart/document size and options for\n         * responsiveness.\n         */\n        Chart.prototype.setResponsive = function(redraw) {\n            var options = this.options.responsive,\n                ruleIds = [],\n                currentResponsive = this.currentResponsive,\n                currentRuleIds;\n\n            if (options && options.rules) {\n                each(options.rules, function(rule) {\n                    if (rule._id === undefined) {\n                        rule._id = H.uniqueKey();\n                    }\n\n                    this.matchResponsiveRule(rule, ruleIds, redraw);\n                }, this);\n            }\n\n            // Merge matching rules\n            var mergedOptions = H.merge.apply(0, H.map(ruleIds, function(ruleId) {\n                return H.find(options.rules, function(rule) {\n                    return rule._id === ruleId;\n                }).chartOptions;\n            }));\n\n            // Stringified key for the rules that currently apply.\n            ruleIds = ruleIds.toString() || undefined;\n            currentRuleIds = currentResponsive && currentResponsive.ruleIds;\n\n\n            // Changes in what rules apply\n            if (ruleIds !== currentRuleIds) {\n\n                // Undo previous rules. Before we apply a new set of rules, we need to\n                // roll back completely to base options (#6291).\n                if (currentResponsive) {\n                    this.update(currentResponsive.undoOptions, redraw);\n                }\n\n                if (ruleIds) {\n                    // Get undo-options for matching rules\n                    this.currentResponsive = {\n                        ruleIds: ruleIds,\n                        mergedOptions: mergedOptions,\n                        undoOptions: this.currentOptions(mergedOptions)\n                    };\n\n                    this.update(mergedOptions, redraw);\n\n                } else {\n                    this.currentResponsive = undefined;\n                }\n            }\n        };\n\n        /**\n         * Handle a single responsiveness rule\n         */\n        Chart.prototype.matchResponsiveRule = function(rule, matches) {\n            var condition = rule.condition,\n                fn = condition.callback || function() {\n                    return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&\n                        this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&\n                        this.chartWidth >= pick(condition.minWidth, 0) &&\n                        this.chartHeight >= pick(condition.minHeight, 0);\n                };\n\n            if (fn.call(this)) {\n                matches.push(rule._id);\n            }\n\n        };\n\n        /**\n         * Get the current values for a given set of options. Used before we update\n         * the chart with a new responsiveness rule.\n         * TODO: Restore axis options (by id?)\n         */\n        Chart.prototype.currentOptions = function(options) {\n\n            var ret = {};\n\n            /**\n             * Recurse over a set of options and its current values,\n             * and store the current values in the ret object.\n             */\n            function getCurrent(options, curr, ret, depth) {\n                var i;\n                H.objectEach(options, function(val, key) {\n                    if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {\n                        options[key] = splat(options[key]);\n\n                        ret[key] = [];\n\n                        // Iterate over collections like series, xAxis or yAxis and map\n                        // the items by index.\n                        for (i = 0; i < options[key].length; i++) {\n                            if (curr[key][i]) { // Item exists in current data (#6347)\n                                ret[key][i] = {};\n                                getCurrent(\n                                    val[i],\n                                    curr[key][i],\n                                    ret[key][i],\n                                    depth + 1\n                                );\n                            }\n                        }\n                    } else if (isObject(val)) {\n                        ret[key] = isArray(val) ? [] : {};\n                        getCurrent(val, curr[key] || {}, ret[key], depth + 1);\n                    } else {\n                        ret[key] = curr[key] || null;\n                    }\n                });\n            }\n\n            getCurrent(options, this.options, ret, 0);\n            return ret;\n        };\n\n    }(Highcharts));\n    return Highcharts\n}));\n"}])},"./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/base.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i=t("./node_modules/tinycolor2/tinycolor.js"),s=(o=i)&&o.__esModule?o:{default:o};var a={white:"#ffffff",gray98:"#f7f8fa",gray96:"#f2f4f5",gray92:"#e1e6eb",gray80:"#c3cbd4",gray60:"#818d99",gray45:"#5c6773",gray30:"#3c444d",gray25:"#31373e",gray22:"#2b3033",gray20:"#171d21",black:"#000000"},l={accentColorL50:"#ecf8ff",accentColorL40:"#bfe9ff",accentColorL30:"#7ed2ff",accentColorL20:"#3ebcff",accentColorL10:"#00a4fd",accentColor:"#007abd",accentColorD10:"#006eaa",accentColorD20:"#006297",accentColorD30:"#005684",accentColorD40:"#004a71",accentColorD50:"#003d5e"},c={textColor:a.gray30,textGray:"#6b7785",textDisabledColor:a.gray80,linkColor:l.accentColorD10,linkColorHover:l.accentColor,borderLightColor:a.gray92,borderColor:a.gray80,focusColor:l.accentColorL10,backgroundColorHover:a.gray96,backgroundColor:a.white},d={focusShadow:"0 0 1px 2px "+(0,s.default)(c.focusColor).setAlpha(.6).toRgbString(),focusShadowInset:"inset 0 0 2px 1px "+a.white+", inset 0 0 0 2px "+c.focusColor,overlayShadow:"0 4px 8px rgba(0, 0, 0, 0.2)"},h={draggableBackground:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAG0lEQVR4AWMAgioUjAoIyg9xAxBgFIymg1EAAD/iHoHfZJ8OAAAAAElFTkSuQmCC') 0 0 / 8px 8px repeat"},u={borderRadius:"3px",border:"1px solid "+c.borderColor},p="'Splunk Platform Sans', 'Proxima Nova', Roboto, Droid, 'Helvetica Neue', Helvetica, Arial, sans-serif",f={sansFontFamily:p,serifFontFamily:"Georgia, 'Times New Roman', Times, serif",monoFontFamily:"'Splunk Platform Mono', Inconsolata, Consolas, 'Droid Sans Mono', Monaco, 'Courier New', Courier, monospace",fontFamily:p,fontWeightSemiBold:"500"};n.default=r({},a,l,{errorColorL50:"#fcedec",errorColorL40:"#f8dcd9",errorColorL30:"#f1b9b3",errorColorL20:"#ea958d",errorColorL10:"#e37267",errorColor:"#dc4e41",errorColorD10:"#c84535",errorColorD20:"#b23d30",errorColorD30:"#9c3529",errorColorD40:"#852d24",errorColorD50:"#6f261d"},{alertColorL50:"#fef3ec",alertColorL40:"#fde6d9",alertColorL30:"#facdb3",alertColorL20:"#f7b48c",alertColorL10:"#f49b66",alertColor:"#f1813f",alertColorD10:"#da742e",alertColorD20:"#c2672a",alertColorD30:"#aa5a25",alertColorD40:"#914d1f",alertColorD50:"#79401a"},{warningColorL50:"#fff9eb",warningColorL40:"#fef2d7",warningColorL30:"#fde5ae",warningColorL20:"#fbd886",warningColorL10:"#facb5d",warningColor:"#f8be34",warningColorD10:"#e0ac16",warningColorD20:"#c79915",warningColorD30:"#ae8613",warningColorD40:"#957312",warningColorD50:"#7d600f"},{successColorL50:"#eef6ee",successColorL40:"#ddecdd",successColorL30:"#bbd9ba",successColorL20:"#98c697",successColorL10:"#76b374",successColor:"#53a051",successColorD10:"#479144",successColorD20:"#40813d",successColorD30:"#387135",successColorD40:"#2f612e",successColorD50:"#275126"},{infoColorL50:"#e5f0f5",infoColorL40:"#cce2eb",infoColorL30:"#99c5d7",infoColorL20:"#66a7c4",infoColorL10:"#338ab0",infoColor:"#006d9c",infoColorD10:"#00577c",infoColorD20:"#004c6c",infoColorD30:"#00415d",infoColorD40:"#00364d",infoColorD50:"#002b3e"},{cat1Color:"#297ba5",cat1ColorL:"#78b9d6",cat2Color:"#4fa484",cat2ColorL:"#74d5c2",cat3Color:"#b6c75a",cat3ColorL:"#dce6a5",cat4Color:"#3c6188",cat4ColorL:"#a0b2ca",cat5Color:"#ec9960",cat5ColorL:"#fac9a7",cat6Color:"#a65c7d",cat6ColorL:"#d3a7ba",cat7Color:"#708794",cat7ColorL:"#b2c0c8",cat8Color:"#38b8bf",cat8ColorL:"#92dde2",cat9Color:"#ffde63",cat9ColorL:"#ffeeae",cat10Color:"#c19975",cat10ColorL:"#d7bfab",cat11Color:"#5a4575",cat11ColorL:"#b7acca",cat12Color:"#7ea77b",cat12ColorL:"#b2cab0",cat13Color:"#576d83",cat13ColorL:"#a5b2bf",cat14Color:"#d7c6b7",cat14ColorL:"#e9ddd4",cat15Color:"#339bb2",cat15ColorL:"#66c3d0",cat16Color:"#236d9b",cat16ColorL:"#66a7c2",cat17Color:"#e5dc80",cat17ColorL:"#f1eab7",cat18Color:"#96907f",cat18ColorL:"#c1bcb3",cat19Color:"#87bc65",cat19ColorL:"#b6d7a3",cat20Color:"#cf7e60",cat20ColorL:"#e1b2a1",cat21Color:"#7b5547",cat21ColorL:"#dec4ba",cat22Color:"#77d6d8",cat22ColorL:"#abe6e8",cat23Color:"#4a7f2c",cat23ColorL:"#91b282",cat24Color:"#f589ad",cat24ColorL:"#f8b7ce",cat25Color:"#6a2c5d",cat25ColorL:"#cba3c2",cat26Color:"#aaabae",cat26ColorL:"#cccdce",cat27Color:"#9a7438",cat27ColorL:"#c3ab89",cat28Color:"#a4d563",cat28ColorL:"#c7e6a3",cat29Color:"#7672a4",cat29ColorL:"#ada9c8",cat30Color:"#184b81",cat30ColorL:"#a4bbe0"},{diverging1ColorA:"#006d9c",diverging1ColorB:"#ec9960",diverging2ColorA:"#af575a",diverging2ColorB:"#62b3b2",diverging3ColorA:"#4fa484",diverging3ColorB:"#f8be34",diverging4ColorA:"#5a4575",diverging4ColorB:"#708794",diverging5ColorA:"#294e70",diverging5ColorB:"#b6c75a"},{syntaxBlue:"#2662fc",syntaxBlueLight:"#006d9c",syntaxBrown:"#a67f59",syntaxGray:"#8293a7",syntaxGreen:"#5ca300",syntaxGreenLight:"#5ba383",syntaxOrange:"#f58220",syntaxPink:"#cf00cf",syntaxPurple:"#7738ff",syntaxPurpleLight:"#b19cd9",syntaxRed:"#d90700",syntaxRedLight:"#af575a",syntaxTeal:"#00a8ab"},{spacing:"20px",spacingHalf:"10px",spacingQuarter:"5px",fontSize:"14px",fontSizeXSmall:"11px",fontSizeSmall:"12px",fontSizeLarge:"16px",fontSizeXLarge:"18px",fontSizeXXLarge:"24px",lineHeight:"20px",inputHeight:"32px",inputHeightSmall:"28px",inputHeightLarge:"38px",toastContainerWidth:"500px"},f,c,h,d,u,{zindexFixedNavbar:1030,zindexModalBackdrop:1040,zindexModal:1050,zindexPopover:1060,zindexToastMessages:2e3})},"./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/enterprise.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/base.js"),s=(o=i)&&o.__esModule?o:{default:o},a=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/mixins.js");var l=r({},s.default,{brandColorL50:"#f5fbf5",brandColorL40:"#dff2df",brandColorL30:"#bee6be",brandColorL20:"#9ed99e",brandColorL10:"#7ecd7e",brandColor:"#5cc05c",brandColorD10:"#49b849",brandColorD20:"#40a540",brandColorD30:"#389038",brandColorD40:"#307b30",brandColorD50:"#286728"});n.default=r({},l,{mixins:{reset:(0,a.createReset)(l),clearfix:a.clearfix,ellipsis:a.ellipsis,printWidth100Percent:a.printWidth100Percent,printHide:a.printHide,printNoBackground:a.printNoBackground,printWrapAll:a.printWrapAll}})},"./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/enterpriseDark.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/enterprise.js"),s=(o=i)&&o.__esModule?o:{default:o},a=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/mixins.js");var l={backgroundColor:s.default.gray25,backgroundColorHover:s.default.gray30,borderColor:s.default.gray22,borderDarkColor:s.default.black,borderLightColor:s.default.gray60,textColor:s.default.white,textGray:s.default.gray92,textDisabledColor:s.default.gray45,linkColor:s.default.accentColorL10,linkColorHover:s.default.accentColorL20,border:"1px solid "+s.default.gray22,borderDark:"1px solid "+s.default.black,borderLight:"1px solid "+s.default.gray60,focusShadowInset:"inset 0 0 2px 1px "+s.default.gray25+", inset 0 0 0 2px "+s.default.focusColor,draggableBackground:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAXEgAAFxIBZ5/SUgAAAW5pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KICAgICAgICAgPGRjOnN1YmplY3Q+CiAgICAgICAgICAgIDxyZGY6QmFnLz4KICAgICAgICAgPC9kYzpzdWJqZWN0PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K72CKvQAAADdJREFUOBFj/PDp00cGJCDAx8ePxGUgJM+ErJgc9sAbQI6rh5seRkLxTEh+4KORYhcMtzglxz8AtKEQD3hiWXMAAAAASUVORK5CYII=') 0 0 / 8px 8px repeat"},c=r({},s.default,l);n.default=r({},c,{mixins:r({},c.mixins,{reset:(0,a.createReset)(c)})})},"./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/lite.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o,r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/base.js"),s=(o=i)&&o.__esModule?o:{default:o},a=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/mixins.js");var l=r({},s.default,{brandColorL50:"#fef8f2",brandColorL40:"#fde6d2",brandColorL30:"#fbcda5",brandColorL20:"#f9b479",brandColorL10:"#f79b4c",brandColor:"#f58220",brandColorD10:"#ed740b",brandColorD20:"#d2670a",brandColorD30:"#b85b09",brandColorD40:"#9e4e07",brandColorD50:"#844106"});n.default=r({},l,{mixins:{reset:(0,a.createReset)(l),clearfix:a.clearfix,ellipsis:a.ellipsis,printWidth100Percent:a.printWidth100Percent,printHide:a.printHide,printNoBackground:a.printNoBackground,printWrapAll:a.printWrapAll}})},"./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/mixins.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e};n.createReset=function(e){var n={animation:"none 0s ease 0s 1 normal none running",backfaceVisibility:"visible",background:"transparent none repeat 0 0 / auto auto padding-box border-box scroll",border:"medium none currentColor",borderCollapse:"separate",borderImage:"none",borderRadius:0,borderSpacing:0,bottom:"auto",boxShadow:"none",captionSide:"top",clear:"none",clip:"auto",columns:"auto",columnCount:"auto",columnFill:"balance",columnGap:"normal",columnRule:"medium none currentColor",columnSpan:1,columnWidth:"auto",content:"normal",counterIncrement:"none",counterReset:"none",cursor:"auto",emptyCells:"show",float:"none",fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",fontStretch:"normal",height:"auto",hyphens:"none",left:"auto",letterSpacing:"normal",listStyle:"disc outside none",margin:0,maxHeight:"none",maxWidth:"none",minHeight:0,minWidth:0,opacity:1,orphans:2,overflow:"visible",overflowX:"visible",overflowY:"visible",padding:0,pageBreakAfter:"auto",pageBreakBefore:"auto",pageBreakInside:"auto",perspective:"none",perspectiveOrigin:"50% 50%",pointerEvents:"auto",position:"static",right:"auto",tabSize:8,tableLayout:"auto",textAlign:"left",textAlignLast:"auto",textDecoration:"none",textIndent:0,textShadow:"none",textTransform:"none",top:"auto",transform:"none",transformOrigin:"50% 50% 0",transformStyle:"flat",transition:"none 0s ease 0s",userSelect:"auto",verticalAlign:"baseline",whiteSpace:"normal",widows:2,width:"auto",wordSpacing:"normal",zIndex:"auto"};return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"inline",r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return o({},r?n:{},{all:"initial",fontFamily:e.fontFamily,fontSize:e.fontSize,lineHeight:e.lineHeight,color:e.textColor,boxSizing:"border-box",display:t,borderWidth:"1px",visibility:"inherit",outline:"medium none "+e.focusColor})}},n.clearfix=function(){return{"&::after":{display:"table",content:'""',clear:"both"}}},n.ellipsis=function(){return{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},n.printWidth100Percent=function(){return{maxWidth:"100% !important",width:"100% !important",overflow:"hidden !important"}},n.printHide=function(){return{display:"none !important"}},n.printNoBackground=function(){return{background:"none !important"}},n.printWrapAll=function(){return{wordBreak:"break-all !important",wordWrap:"break-word !important",overflowWrap:"break-word !important",whiteSpace:"normal !important"}}},"./node_modules/@splunk/react-time-range/themes.js":function(e,n,t){
/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or in part
 * without a valid written license from Splunk Inc. is PROHIBITED.
 */
e.exports=function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=34)}({27:function(e,n){e.exports=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/enterprise.js")},28:function(e,n){e.exports=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/enterpriseDark.js")},29:function(e,n){e.exports=t("./node_modules/@splunk/react-time-range/node_modules/@splunk/themes/lite.js")},34:function(e,n,t){"use strict";t.r(n),t.d(n,"enterprise",function(){return c}),t.d(n,"lite",function(){return d}),t.d(n,"enterpriseDark",function(){return h}),t.d(n,"variable",function(){return p}),t.d(n,"mixin",function(){return f}),t.d(n,"themes",function(){return m});var o=t(27),r=t.n(o),i=t(28),s=t.n(i),a=t(29),l=t.n(a),c={"react-time-range":{id:"enterprise",base:r.a,AbsoluteValue:{backgroundColor:r.a.gray96}}},d={"react-time-range":{id:"lite",base:l.a,AbsoluteValue:{backgroundColor:l.a.gray96}}},h={"react-time-range":{id:"enterpriseDark",base:s.a,AbsoluteValue:{backgroundColor:s.a.gray22}}},u=function(e){return e.theme&&e.theme["react-time-range"]?e.theme["react-time-range"]:c["react-time-range"]},p=function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return function(e){return 1===n.length?u(e).base[n[0]]:n.reduce(function(e,n){return e&&e[n]?e[n]:null},u(e))}},f=function(e){return function(){for(var n=arguments.length,t=Array(n),o=0;o<n;o++)t[o]=arguments[o];return function(n){var o;return(o=u(n).base.mixins)[e].apply(o,t)}}},m={enterprise:c,enterpriseDark:h,lite:d}}})},"./node_modules/@splunk/react-ui/themes.js":function(e,n,t){e.exports=function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=93)}({12:function(e,n){e.exports=t("./node_modules/tinycolor2/tinycolor.js")},3:function(e,n){e.exports=t("./node_modules/styled-components/dist/styled-components.browser.esm.js")},48:function(e,n){e.exports=t("./node_modules/lodash/merge.js")},5:function(e,n){e.exports=t("./node_modules/@splunk/themes/scp.js")},6:function(e,n){e.exports=t("./node_modules/@splunk/themes/enterpriseDark.js")},84:function(e,n){e.exports=t("./node_modules/@splunk/themes/enterprise.js")},85:function(e,n){e.exports=t("./node_modules/@splunk/themes/lite.js")},93:function(e,n,t){"use strict";t.r(n);var o=t(3),r=t.n(o),i=t(84),s=t.n(i),a=t(12),l=t.n(a),c=function(e){return{"react-ui":{base:e,Button:{iconPaddingRight:"3px",iconOnlyPadding:e.spacingQuarter,paddingSmall:e.spacingQuarter,paddingLarge:e.fontSize},ButtonSimple:{Primary:{shadow:"inset 0 -2px 0 ".concat(l()("black").setAlpha(.1).toRgbString()),selectedShadow:"inset 0 2px 0 ".concat(l()("black").setAlpha(.1).toRgbString()),focusShadow:"inset 0 -2px 0 ".concat(l()("black").setAlpha(.1).toRgbString(),", ").concat(e.focusShadow),selectedFocusShadow:"inset 0 2px 0 ".concat(l()("black").setAlpha(.1).toRgbString(),", ").concat(e.focusShadow),color:e.white,backgroundColor:e.brandColor,hoverBackgroundColor:e.brandColorD20,activeBackgroundColor:e.brandColorD30,selectedBackgroundColor:e.brandColorD20,disabledBackgroundColor:e.brandColorL10,disabledTextColor:e.brandColorL30,disabledSelectedBackgroundColor:e.brandColorD20,disabledSelectedBorderColor:e.borderColor,prependBorderLeftColor:e.brandColorD20},Error:{shadow:"inset 0 -2px 0 ".concat(l()("black").setAlpha(.1).toRgbString()),selectedShadow:"inset 0 2px 0 ".concat(l()("black").setAlpha(.1).toRgbString()),focusShadow:"inset 0 -2px 0 ".concat(l()("black").setAlpha(.1).toRgbString(),", ").concat(e.focusShadow),selectedFocusShadow:"inset 0 2px 0 ".concat(l()("black").setAlpha(.1).toRgbString(),", ").concat(e.focusShadow),color:e.white,backgroundColor:e.errorColor,activeBackgroundColor:e.errorColorD30,hoverBackgroundColor:e.errorColorD20,selectedBackgroundColor:e.errorColorD20,disabledBackgroundColor:e.errorColorL10,disabledTextColor:e.errorColorL30,disabledSelectedBackgroundColor:e.errorColorD20,disabledSelectedBorderColor:e.borderColor,prependBorderLeftColor:e.errorColorD20},Default:{shadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",hoverShadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",activeShadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",selectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1)",focusShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusHoverShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusActiveShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusSelectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusAppendShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow,", inset -1px 0 0 ").concat(e.borderColor),focusAppendSelectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1), inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow,", inset -1px 0 0 ").concat(e.borderColor),color:e.gray45,border:e.border,backgroundColor:e.gray98,selectedBackgroundColor:e.gray92,hoverBackgroundColor:l()(e.gray96).darken(2.5).toHexString(),activeBackgroundColor:e.gray92,disabledBackgroundColor:e.gray96,disabledBorderColor:e.borderLightColor,disabledSelectedBackgroundColor:e.gray92,disabledSelectedBorderColor:e.borderColor,disabledTextColor:e.textDisabledColor,activePrependLeftBorderColor:e.borderColor},Secondary:{shadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",hoverShadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",activeShadow:"inset 0 -1px 0 rgba(0,0,0,0.1)",selectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1)",focusShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusHoverShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusActiveShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusSelectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow),focusAppendShadow:"inset 0 -1px 0 rgba(0,0,0,0.1), inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow,", inset -1px 0 0 ").concat(e.borderColor),focusAppendSelectedShadow:"inset 0 1px 0 rgba(0,0,0,0.1), inset 0 -1px 0 rgba(0,0,0,0.1), ".concat(e.focusShadow,", inset -1px 0 0 ").concat(e.borderColor),color:e.gray45,border:e.border,backgroundColor:e.gray98,selectedBackgroundColor:e.gray92,hoverBackgroundColor:l()(e.gray96).darken(2.5).toHexString(),activeBackgroundColor:e.gray92,disabledBackgroundColor:e.gray96,disabledBorderColor:e.borderLightColor,disabledSelectedBackgroundColor:e.gray92,disabledSelectedBorderColor:e.borderColor,disabledTextColor:e.textDisabledColor,activePrependLeftBorderColor:e.borderColor},Pill:{color:e.gray45,hoverBackgroundColor:e.backgroundColorHover,hoverBorderColor:e.borderColor,hoverColor:e.linkColor,focusColor:e.linkColor,expandedBackgroundColor:e.gray92,invalidColor:e.errorColor,selectedBorderColor:e.accentColor,selectedDisabledBorderColor:e.borderLightColor,disabledTextColor:e.textDisabledColor}},Calendar:{width:"220px",padding:"8px",DateTable:{tableHeaderColor:e.textGray,paddingBottom:"2px",fontSize:e.fontSizeSmall},Day:{buttonColor:e.gray45,buttonHoverColor:e.linkColor,buttonHoverBackgroundColor:e.backgroundColorHover,buttonSelectedBorderColor:e.accentColor,buttonSelectedBorderHoverColor:e.linkColor,buttonSelectedBackgroundColor:"transparent",width:"2em",lineHeight:"2em",border:"1px solid transparent",borderRadius:e.borderRadius,focusShadow:e.focusShadow},MonthHeader:{textTransform:"capitalize"}},Card:{backgroundColor:e.backgroundColor,clickableSelectedBorderColor:e.focusColor,borderColor:e.borderLightColor,hoverShadow:e.overlayShadow,focusShadow:e.focusShadow,Header:{subtitleColor:e.textGray,padding:e.spacing},Body:{padding:e.spacing,firstChildPaddingTop:"0"},Footer:{boxColor:e.textGray,padding:e.spacing,borderTop:"1px solid ".concat(e.gray92)}},Chip:{clickableBackgroundColor:e.gray92,clickableColor:e.textGray,clickableHoverBackgroundColor:e.gray96,clickableDisabledBackgroundColor:"rgba(0, 0, 0, 0.05)",errorColorBackgroundColor:e.errorColorL10,labelColor:e.textColor,iconColor:e.textColor,infoColorBackgroundColor:e.infoColorL10,successColorBackgroundColor:e.successColorL10,warningColorBackgroundColor:e.warningColorL10},Clickable:{disabledColor:e.textDisabledColor},Code:{commentToken:e.syntaxGray,prologToken:e.syntaxGray,doctypeToken:e.syntaxGray,cdataToken:e.syntaxGray,punctuationToken:e.syntaxGray,propertyToken:e.syntaxPurple,tagToken:e.syntaxPurple,booleanToken:e.syntaxPurple,numberToken:e.syntaxPurple,constantToken:e.syntaxPurple,symbolToken:e.syntaxPurple,deletedToken:e.syntaxPurple,selectorToken:e.syntaxGreen,"attr-nameToken":e.syntaxGreen,stringToken:e.syntaxGreen,charToken:e.syntaxGreen,builtinToken:e.syntaxGreen,insertedToken:e.syntaxGreen,operatorToken:e.syntaxBrown,entityToken:e.syntaxBrown,urlToken:e.syntaxBrown,atruleToken:e.syntaxBlue,"attr-valueToken":e.syntaxBlue,keywordToken:e.syntaxBlue,functionToken:e.syntaxRed,regexToken:e.syntaxOrange,importantToken:e.syntaxOrange,variableToken:e.syntaxOrange},CollapsiblePanel:{minHeight:"calc(".concat(e.lineHeight," + 12px)"),marginTop:"2px",iconTransition:"transform 300ms",iconPosition:"12px",iconTransfromClose:"rotate(90deg)",titleLineHeight:e.lineHeight,titlePadding:"6px calc(".concat(e.spacing," + ").concat(e.spacingHalf,")"),titleClickableColor:e.textColor,titleClickableCollapsedBackgroundColor:e.gray96,titleClickableHoverBackgroundColor:e.gray92,titleFocusShadow:e.focusShadowInset},Color:{width:"180px",clickableInvalidBorderColor:e.errorColor,swatchesListMarginRight:"-6px",swatchesListMarginBottom:"6px",Swatch:{marginRight:e.spacingQuarter,marginBottom:e.spacingQuarter,nullLineColor:"#ed1e24",transparentPatternEvenColor:"transparent",transparentPatternOddColor:e.gray80,border:e.border,focusBorderColor:l()(e.focusColor).setAlpha(.8).toRgbString(),boxShadow:e.focusShadow,smallSize:e.inputHeightSmall},Input:{width:"100%"}},Concertina:{panelBodyErrorBackgroundColor:e.errorColorL50,panelBodyWarningBackgroundColor:e.warningColorL50,Heading:{clickableColor:e.textColor,clickableBackgroundColor:e.gray96,clickableHoverBackgroundColor:e.gray92,clickableDisabledBackgroundColor:e.gray96}},ControlGroup:{boxInvalidColor:e.errorColor,helpColor:e.textGray},Date:{width:"105px",widthLarge:"130px",widthSmall:"80px"},File:{mediumDropTargetBoxBorderColor:e.borderColor,mediumDropTargetBoxDisabledColor:e.textGray,mediumDropTargetBoxDisabledFileCount0BackgroundColor:e.gray96,largeDropTargetBoxDisabledColor:e.textGray,linkColor:e.linkColor,linkFocusShadow:e.focusShadowInset,iconFill:e.gray60,padding:e.spacingQuarter,borderDragOver:"1px solid ".concat(e.accentColorL10),disabledBorder:"none",windowDropBorder:"5px solid ".concat(e.accentColorL10),Item:{backgroundColor:"transparent",boxBackgroundColor:e.gray92,boxColor:e.textGray,labelColor:e.textColor,labelErrorTextColor:e.errorColor,labelDisabledBackgroundColor:e.gray96,labelDisabledTextColor:e.textGray,removeClickableFocusColor:e.linkColor,removeClickableHoverBackgroundColor:e.gray96,removeClickableHoverColor:e.linkColor,borderRadius:"2px",padding:"3px 0 3px ".concat(e.spacingHalf),flex:"0 0 ".concat(e.inputHeight),removeClickableBorderRadius:"0 2px 2px 0",removeClickablePadding:"3px 0",removeClickableErrorBorder:"1px solid ".concat(e.errorColor),removeClickableFocusShadow:e.focusShadow,removeClickableSmallFlexBasis:e.inputHeightSmall}},Heading:{sectionColor:e.gray45,fontWeight:e.fontWeightSemiBold,fontSize:e.fontSize,h1FontSize:e.fontSizeXXLarge,h2FontSize:e.fontSizeXLarge,h3FontSize:e.fontSizeLarge,h4FontSize:e.fontSize,h5FontSize:"12px"},Image:{boxBackgroundColor:e.gray92,boxColor:e.textGray,labelColor:e.textColor,labelDisabledBackgroundColor:e.gray96,removeClickableFocusColor:e.linkColor,removeClickableHoverBackgroundColor:e.gray96,removeClickableHoverColor:e.linkColor,padding:"3px 0 3px ".concat(e.spacingHalf),removeClickableColor:"inherit",removeClickableFlex:"0 0 ".concat(e.inputHeight),removeClickableFocusShadow:e.focusShadow},JSONTree:{TreeNode:{expandLinkClickableColor:e.linkColor,propertyColor:e.syntaxRed,typeColorString:e.syntaxTeal,typeColorNumber:e.syntaxBlue,typeColorBoolean:e.syntaxPurple,typeColorNull:e.syntaxBrown,typeColorObject:e.textColor}},Link:{clickableColor:e.linkColor,focusShadow:"0 0 1px 2px ".concat(l()(e.focusColor).setAlpha(.6).toRgbString()),disabledColor:e.textDisabledColor,focusTextDecoration:"none",externalMargin:"0 0 0 3px"},Logo:{svgTextFill:e.gray20,svgInvertedTextFill:e.white},Markdown:{codeBlockBackgroundColor:e.gray96,codeInlineBackgroundColor:e.gray92},Menu:{backgroundColor:e.backgroundColor,Item:{backgroundColorHover:e.backgroundColorHover,clickableColor:e.gray45,disabledSelectedIconColor:e.gray80,focusShadowInset:e.focusShadowInset,matchColor:e.accentColor,descriptionColor:e.textGray,itemSelectedIconColor:e.accentColorL10,itemSelectedIconLeft:"8px",itemSelectedIconTop:"5px",itemIconVertical:"middle",submenuColor:e.textGray,padding:"6px ".concat(e.spacingHalf),lineHeight:e.lineHeight,selectablePaddingLeft:"28px",selectablePaddingRight:e.spacingHalf,selectablePosition:"left",checkboxPaddingLeft:"32px"},Heading:{padding:"".concat(e.spacingQuarter," ").concat(e.spacingHalf," 6px")}},Message:{iconColor:e.white,iconInfoColor:e.infoColor,iconSuccessColor:e.successColor,iconWarningColor:e.warningColor,iconErrorColor:e.errorColor,boxInfoBackgroundColor:e.infoColorL50,boxSuccessBackgroundColor:e.successColorL50,boxWarningBackgroundColor:e.warningColorL50,boxErrorBackgroundColor:e.errorColorL50},Modal:{boxShadow:"0 1px 5px ".concat(e.black),transform:"translateX(-50%)",Body:{boxBackgroundColor:e.backgroundColor},Footer:{boxBackgroundColor:e.backgroundColor,boxBorderTopColor:e.borderColor},Header:{boxBackgroundColor:e.backgroundColor,boxBorderBottomColor:e.borderColor,boxPadding:"25px 28px",closeAndPeekPaddingRight:"94px",closeOrPeekPaddingRight:"54px",titleFontWeightSemiBold:e.fontWeightSemiBold,titleLineHeight:"22px",subTitleLineHeight:e.lineHeight}},ModalLayer:{backgroundColor:e.gray30},Monogram:{color:e.white,clickableFocusHoverBoxShadow:e.focusShadowInset,backgroundColors:["#006d9c","#ec9960","#af575a","#62b3b2","#4fa484","#f8be34","#5a4575","#708794","#294e70","#b6c75a","#5cc05c","#007abd","#dc4e41","#f1813f","#f8be34","#53a051","#006d9c","#77d6d8","#f589ad","#6a2c5d"]},Multiselect:{Normal:{boxBackgroundColor:e.white,boxDisabledBackgroundColor:e.gray96,boxInvalidBorderColor:e.errorColor,boxInvalidColor:e.errorColor}},Number:{incrementorWidth:"20px",mediumWidth:"100px",minusButtonBorderRightColor:e.borderColor,plusButtonBorderRightColor:e.borderColor},Paragraph:{marginBottom:"calc(".concat(e.lineHeight," / 2)")},Popover:{align:"center",lightBackgroundColor:e.backgroundColor,lightBorder:e.border,lightBoxShadow:"0 2px 2px ".concat(l()(e.gray20).setAlpha(.1).toRgbString()),lightColor:e.textColor,arrowBorderBottomColor:e.borderColor,darkBackgroundColor:e.gray20,darkColor:e.white,darkArrowBorderBottomColor:e.gray20,arrowHeightPixel:8,paddingPixel:8},Progress:{tooltipBackgroundColor:e.accentColorD10},Resize:{resizeColor:e.borderColor},ResultsMenu:{footerColor:e.textGray,loadingMessageColor:e.textGray},SidePanel:{panelBackgroundColor:e.backgroundColor},Slider:{sliderBarDisabledBackgroundColor:e.gray92,sliderBarLeftSideColor:e.gray45,sliderBarRightSideColor:e.gray80,sliderBarStepMarksColor:e.gray96,sliderThumbBackgroundColor:e.gray45,sliderThumbDisabledBackgroundColor:e.gray92,labelDisabledColor:e.textDisabledColor},StepBar:{Step:{color:e.textDisabledColor,grayFill:e.gray80,nextStroke:e.gray80,prevOrActiveFillColor:e.brandColor}},Switch:{wrapperErrorColor:e.errorColor,labelPaddingLeft:e.spacingQuarter,Checkbox:{color:e.gray45,focusShadow:e.focusShadow,selectedBorderColor:e.gray45,disabledBorderColor:e.gray80,disabledColor:e.gray80,errorColor:e.errorColor,errorBorderColor:e.errorColorL30,selectedErrorBorderColor:e.errorColor},Radio:{color:e.gray45,selectedLeft:"4px",selectedTop:"4px",focusShadow:e.focusShadow,selectedBorderColor:e.gray45,disabledBorderColor:e.gray80,disabledColor:e.gray80,errorColor:e.errorColor,errorBorderColor:e.errorColorL30,selectedErrorBorderColor:e.errorColor},Toggle:{shadow:"inset 0 2px 0 rgba(0, 0, 0, 0.1)",toggleFocusShadow:"".concat(e.focusShadow,", inset 0 2px 0 rgba(0, 0, 0, 0.1)"),backgroundColor:e.gray98,borderColor:e.borderColor,indicatorBackgroundColor:e.gray98,indicatorBorderColor:e.borderColor,indicatorHoverBackgroundColor:e.gray96,toggleIndicatorBorderStyle:"solid",selectedBackgroundColor:e.accentColorL10,selectedBorderColor:e.accentColorL10,disabledBorderColor:e.borderLightColor,disabledBackgroundColor:e.gray96,disabledIndBorderColor:l()(e.borderLightColor).setAlpha(.8).toRgbString(),selectedDisabledBackgroundColor:e.accentColorL40,errorToggleOutlineBorderColor:e.errorColor}},TabBar:{Tab:{clickableColor:e.textColor,focusShadowInset:e.focusShadowInset,underlineSelectedBackgroundColor:e.accentColor}},Table:{focusShadowInset:e.focusShadowInset,Cell:{linkColor:e.linkColor,clickableBackgroundColor:e.accentColorL50,padding:"6px 12px",expandPadding:0,verticalAlign:"top"},Head:{toggleAllWidth:"42px",infoWidth:"32px"},HeadCell:{backgroundColor:e.gray92,borderLeftColor:e.backgroundColor,draggingBackgroundColor:e.gray80,guideLineBackgroundColor:e.linkColor,focusShadow:e.focusShadowInset,moreInfoHeadCellPadding:"5px 0 0 0"},HeadInner:{hoverColor:e.linkColorHover,helperBackgroundColor:e.accentColorL50,sortIconColor:e.textGray,sortIconPosition:"absolute",sortedIconColor:e.accentColor,menuIconColor:e.textGray,menuIconPadding:"1px 0 0 4px",padding:"6px 12px",dragContainerTop:"0px",dragContainerLeft:"0px",menuIconRight:"0",dragContainerPadding:"9px 12px"},Row:{stripeNoneClickableHoverBackgroundColor:e.accentColorL50,stripeEvenBackgroundColor:e.gray96,expandContainerWidth:"8px"},RowDragCell:{draggablePadding:"9px 0",draggingBackgroundColor:e.gray80,guideLineBackgroundColor:e.linkColor,helperBackgroundColor:e.accentColorL50,width:"32px"},Toggle:{inHeadMargin:"-6px 0",margin:"-6px 0"}},Text:{clearIconRight:"1px",clearIconTop:"2px",clearIconPadding:"8px",inputFocusShadow:e.focusShadow,inputColor:e.textColor,inputBackgroundColor:e.white,inputFocusColor:e.textColor,inputErrorBorderColor:e.errorColor,inputErrorColor:e.errorColor,inputDisabledBackgroundColor:e.gray96,inputDisabledBorderColor:e.gray92,inputDisabledColor:e.textDisabledColor,inputClearOrSearchPaddingRight:"28px",placeholderMediumSize:"11px",placeholderWithSearchLeft:"11px",spacingHalf:e.spacingHalf,spacingQuarter:e.spacingQuarter,searchIconWrapperColor:e.gray60,searchIconWrapperRight:"8px",searchIconWrapperTop:"8px",clearColor:e.gray60,placeholderColor:e.textGray,searchIconPosition:"right"},Tooltip:{linkColor:e.linkColor},WaitSpinner:{circleStroke:e.gray60}}}},d=c(s.a),h=t(48),u=t.n(h),p=t(6),f=t.n(p),m=u()({},c(f.a),{"react-ui":{ButtonSimple:{Default:{shadow:"inset 0 -1px 0 ".concat(f.a.gray30),hoverShadow:"inset 0 -1px 0 ".concat(f.a.gray25),activeShadow:"inset 0 -1px 0 ".concat(f.a.gray22),selectedShadow:"inset 0 1px 0 ".concat(f.a.black),focusShadow:"inset 0 -1px 0 ".concat(f.a.gray30,", ").concat(f.a.focusShadow),focusHoverShadow:"inset 0 -1px 0 ".concat(f.a.gray25,", ").concat(f.a.focusShadow),focusActiveShadow:"inset 0 -1px 0 ".concat(f.a.gray22,", ").concat(f.a.focusShadow),focusSelectedShadow:"inset 0 1px 0 ".concat(f.a.black,", ").concat(f.a.focusShadow),focusAppendShadow:"inset 0 -1px 0 ".concat(f.a.gray30,", ").concat(f.a.focusShadow,", inset -1px 0 0 ").concat(f.a.borderColor),focusAppendSelectedShadow:"inset 0 1px 0 ".concat(f.a.black,", ").concat(f.a.focusShadow,", inset -1px 0 0 ").concat(f.a.borderColor),backgroundColor:f.a.gray45,color:f.a.white,selectedBackgroundColor:f.a.gray22,hoverBackgroundColor:f.a.gray30,selectedBorderColor:f.a.gray20,activeBorderColor:f.a.gray20,activeBackgroundColor:f.a.gray22,disabledBackgroundColor:f.a.gray30,disabledBorderColor:f.a.gray30,disabledSelectedBackgroundColor:f.a.gray22,disabledSelectedBorderColor:f.a.gray20},Secondary:{shadow:"inset 0 -1px 0 ".concat(f.a.gray30),hoverShadow:"inset 0 -1px 0 ".concat(f.a.gray25),activeShadow:"inset 0 -1px 0 ".concat(f.a.gray22),selectedShadow:"inset 0 1px 0 ".concat(f.a.black),focusShadow:"inset 0 -1px 0 ".concat(f.a.gray30,", ").concat(f.a.focusShadow),focusHoverShadow:"inset 0 -1px 0 ".concat(f.a.gray25,", ").concat(f.a.focusShadow),focusActiveShadow:"inset 0 -1px 0 ".concat(f.a.gray22,", ").concat(f.a.focusShadow),focusSelectedShadow:"inset 0 1px 0 ".concat(f.a.black,", ").concat(f.a.focusShadow),focusAppendShadow:"inset 0 -1px 0 ".concat(f.a.gray30,", ").concat(f.a.focusShadow,", inset -1px 0 0 ").concat(f.a.borderColor),focusAppendSelectedShadow:"inset 0 1px 0 ".concat(f.a.black,", ").concat(f.a.focusShadow,", inset -1px 0 0 ").concat(f.a.borderColor),backgroundColor:f.a.gray45,color:f.a.white,selectedBackgroundColor:f.a.gray22,hoverBackgroundColor:f.a.gray30,selectedBorderColor:f.a.gray20,activeBorderColor:f.a.gray20,activeBackgroundColor:f.a.gray22,disabledBackgroundColor:f.a.gray30,disabledBorderColor:f.a.gray30,disabledSelectedBackgroundColor:f.a.gray22,disabledSelectedBorderColor:f.a.gray20},Pill:{color:f.a.white,hoverColor:f.a.white,focusColor:f.a.white,expandedBackgroundColor:f.a.gray22}},Calendar:{Day:{buttonColor:f.a.gray98}},Chip:{clickableBackgroundColor:f.a.gray45,clickableHoverBackgroundColor:f.a.gray30,clickableDisabledBackgroundColor:"rgba(0, 0, 0, 0.15)"},Code:{color:f.a.gray92,commentToken:f.a.gray60,prologToken:f.a.gray60,doctypeToken:f.a.gray60,cdataToken:f.a.gray60,punctuationToken:f.a.gray60,propertyToken:f.a.syntaxPurpleLight,tagToken:f.a.syntaxPurpleLight,booleanToken:f.a.syntaxPurpleLight,numberToken:f.a.syntaxPurpleLight,constantToken:f.a.syntaxPurpleLight,symbolToken:f.a.syntaxPurpleLight,deletedToken:f.a.syntaxPurpleLight,selectorToken:f.a.syntaxGreenLight,"attr-nameToken":f.a.syntaxGreenLight,stringToken:f.a.syntaxGreenLight,charToken:f.a.syntaxGreenLight,builtinToken:f.a.syntaxGreenLight,insertedToken:f.a.syntaxGreenLight,operatorToken:f.a.syntaxBrown,entityToken:f.a.syntaxBrown,urlToken:f.a.syntaxBrown,atruleToken:f.a.syntaxBlueLight,"attr-valueToken":f.a.syntaxBlueLight,keywordToken:f.a.syntaxBlueLight,functionToken:f.a.syntaxRedLight,regexToken:f.a.syntaxOrange,importantToken:f.a.syntaxOrange,variableToken:f.a.syntaxOrange},CollapsiblePanel:{titleClickableCollapsedBackgroundColor:f.a.gray45,titleClickableHoverBackgroundColor:f.a.gray30},Concertina:{panelBodyErrorBackgroundColor:l()(f.a.errorColor).setAlpha(.5).toRgbString(),panelBodyWarningBackgroundColor:l()(f.a.warningColor).setAlpha(.5).toRgbString(),Heading:{clickableBackgroundColor:f.a.gray45,clickableHoverBackgroundColor:f.a.gray30,clickableDisabledBackgroundColor:f.a.gray80}},File:{mediumDropTargetBoxBorderColor:f.a.textGray,mediumDropTargetBoxDisabledFileCount0BackgroundColor:f.a.gray60,iconFill:f.a.gray80,Item:{boxBackgroundColor:f.a.gray45,removeClickableHoverBackgroundColor:f.a.gray30,labelDisabledBackgroundColor:f.a.gray60}},Heading:{sectionColor:f.a.gray80},JSONTree:{TreeNode:{propertyColor:f.a.syntaxRedLight,expandLinkClickableColor:f.a.accentColorL40,typeColorNumber:f.a.syntaxBlueLight,typeColorBoolean:f.a.syntaxPurpleLight}},Logo:{svgTextFill:f.a.white,svgInvertedTextFill:f.a.gray20},Markdown:{codeBlockBackgroundColor:f.a.gray22,codeInlineBackgroundColor:f.a.gray22},Menu:{Item:{clickableColor:f.a.gray96}},Message:{boxInfoBackgroundColor:l()(f.a.infoColor).setAlpha(.5).toRgbString(),boxSuccessBackgroundColor:l()(f.a.successColor).setAlpha(.5).toRgbString(),boxWarningBackgroundColor:l()(f.a.warningColor).setAlpha(.5).toRgbString(),boxErrorBackgroundColor:l()(f.a.errorColor).setAlpha(.5).toRgbString()},Modal:{Footer:{boxBorderTopColor:f.a.gray20},Header:{boxBorderBottomColor:f.a.gray20}},Multiselect:{Normal:{boxBackgroundColor:f.a.gray22,boxBorderColor:f.a.gray20,boxDisabledBackgroundColor:f.a.gray22,boxDisabledBorderColor:f.a.gray30}},Number:{incrementorBorderColor:f.a.gray20,incrementorDisabledBorderColor:f.a.gray22},Popover:{lightBorder:f.a.borderDark,lightBoxShadow:"0 1px 2px #000",arrowBorderBottomColor:f.a.borderDarkColor,darkBackgroundColor:f.a.white,darkColor:f.a.gray20,darkArrowBorderBottomColor:f.a.white},Resize:{resizeColor:f.a.gray92},Slider:{sliderBarStepMarksColor:f.a.gray20},Switch:{Checkbox:{color:f.a.gray80,borderColor:f.a.gray80,selectedBorderColor:f.a.gray80,disabledBorderColor:f.a.gray45,disabledColor:f.a.gray45,errorBorderColor:f.a.errorColor},Radio:{color:f.a.gray80,borderColor:f.a.gray80,selectedBorderColor:f.a.gray80,disabledBorderColor:f.a.gray45,disabledColor:f.a.gray45,errorBorderColor:f.a.errorColor},Toggle:{backgroundColor:f.a.gray45,indicatorBackgroundColor:f.a.gray80,indicatorHoverBackgroundColor:l()(f.a.gray80).darken(6).toRgbString(),disabledBorderColor:f.a.borderColor,disabledBackgroundColor:f.a.gray30,disabledIndBackgroundColor:f.a.gray45,disabledIndBorderColor:f.a.gray22,selectedDisabledBackgroundColor:f.a.accentColorD20}},Table:{Cell:{clickableBackgroundColor:f.a.accentColorD50},HeadCell:{backgroundColor:"#212527",draggingBackgroundColor:f.a.gray20},HeadInner:{helperBackgroundColor:f.a.accentColorD50},Row:{stripeNoneClickableHoverBackgroundColor:f.a.accentColorD50,stripeEvenBackgroundColor:f.a.gray25,stripeOddBackgroundColor:f.a.gray22},RowDragCell:{draggingBackgroundColor:f.a.gray20,helperBackgroundColor:f.a.accentColorD50}},Text:{inputBackgroundColor:f.a.gray22,inputBorderColor:f.a.gray20,inputDisabledBackgroundColor:f.a.gray22,inputDisabledBorderColor:f.a.gray30,searchIconWrapperColor:f.a.white,clearColor:f.a.white},WaitSpinner:{circleStroke:f.a.white}}}),g=t(85),y=c(t.n(g).a),b=t(5),x=t.n(b),v=c(x.a);delete v["react-ui"].ButtonSimple.Pill,delete v["react-ui"].Table.Cell.clickableBackgroundColor;var j=u()({},v,{"react-ui":{Button:{disabledIconColor:x.a.textDisabledColor,iconColor:x.a.gray68,iconOnlyColor:x.a.gray96,iconOnlyDisabledColor:x.a.textDisabledColor,iconPaddingRight:"8px",iconOnlyPadding:"0px",paddingSmall:"6px",paddingLarge:"16px",primaryIconColor:x.a.gray96},ButtonSimple:{Primary:{shadow:"none",selectedShadow:"none",focusShadow:"none",selectedFocusShadow:"none",borderRadius:"24px",border:"1px solid ".concat(x.a.blue1),hoverBorder:"1px solid ".concat(x.a.blue2),activeBorder:"1px solid ".concat(x.a.blue3),focusBorder:"1px solid ".concat(x.a.blue2),disabledBorder:"1px solid ".concat(x.a.gray35),disabledSelectedBorder:"1px solid ".concat(x.a.gray29),color:x.a.gray96,backgroundColor:x.a.blue1,activeBackgroundColor:x.a.blue3,focusBackgroundColor:x.a.blue2,hoverBackgroundColor:x.a.blue2,selectedBackgroundColor:x.a.blue2,disabledBackgroundColor:x.a.gray35,disabledSelectedBackgroundColor:x.a.gray29,disabledTextColor:x.a.gray68,prependBorderLeftColor:x.a.blue2},Error:{shadow:"none",selectedShadow:"none",focusShadow:"none",selectedFocusShadow:"none",disabledTextColor:x.a.gray68,focusBackgroundColor:l()(x.a.errorColor).setAlpha(.7).toRgbString()},Default:{shadow:"none",hoverShadow:"none",activeShadow:"none",selectedShadow:"none",focusShadow:"none",focusHoverShadow:"none",focusActiveShadow:"none",focusSelectedShadow:"none",focusAppendShadow:"none",focusAppendSelectedShadow:"none",color:x.a.gray96,border:x.a.borderLight,borderRadius:"24px",backgroundColor:x.a.transparent,activeBackgroundColor:x.a.gray29,focusBackgroundColor:x.a.gray35,hoverBackgroundColor:x.a.gray35,selectedBackgroundColor:x.a.gray29,disabledBackgroundColor:x.a.transparent,disabledBorderColor:x.a.borderColor,disabledSelectedBackgroundColor:x.a.gray20,disabledTextColor:x.a.textDisabledColor,activePrependLeftBorderColor:x.a.borderLightColor},Secondary:{shadow:"none",hoverShadow:"none",activeShadow:"none",selectedShadow:"none",focusShadow:"none",focusHoverShadow:"none",focusActiveShadow:"none",focusSelectedShadow:"none",focusAppendShadow:"none",focusAppendSelectedShadow:"none",color:x.a.gray96,border:"1px solid ".concat(x.a.transparent),borderRadius:"24px",backgroundColor:x.a.transparent,activeBackgroundColor:x.a.gray17,focusBackgroundColor:x.a.gray35,hoverBackgroundColor:x.a.gray35,selectedBackgroundColor:x.a.gray29,disabledBackgroundColor:x.a.transparent,disabledBorderColor:x.a.transparent,disabledTextColor:x.a.textDisabledColor,disabledSelectedBackgroundColor:x.a.gray20,activePrependLeftBorderColor:x.a.transparent,disabledSelectedBorderColor:x.a.transparent,selectedPrependLeftBorderColor:x.a.transparent},Toggle:{border:x.a.border,color:x.a.gray96,activeBorderColor:x.a.gray35,activeBackgroundColor:x.a.gray20,focusBackgroundColor:x.a.gray35,hoverBackgroundColor:x.a.gray35,selectedBackgroundColor:x.a.gray35,disabledBorderColor:x.a.borderColor,disabledTextColor:x.a.textDisabledColor,disabledSelectedBackgroundColor:x.a.gray17},Flat:{border:"1px solid ".concat(x.a.transparent),color:x.a.gray96,backgroundColor:x.a.gray29,activeBackgroundColor:x.a.gray29,focusBackgroundColor:x.a.gray35,hoverBackgroundColor:x.a.gray35,selectedBackgroundColor:x.a.gray35,disabledBackgroundColor:x.a.gray20,disabledTextColor:x.a.textDisabledColor,disabledSelectedBackgroundColor:x.a.gray17}},Calendar:{width:"332px",padding:"16px",DateTable:{paddingBottom:"6px",fontSize:"14px"},Day:{buttonColor:x.a.gray96,buttonHoverColor:x.a.gray96,buttonHoverBackgroundColor:x.a.gray35,buttonFocusBackgroundColor:x.a.gray35,buttonSelectedBorderColor:"none",buttonSelectedColor:x.a.gray11,buttonSelectedBackgroundColor:x.a.gray96,buttonSelectedFontWeight:x.a.fontWeightBold,width:"36px",lineHeight:"36px",border:"none",borderRadius:"50%",focusShadow:"none"},MonthHeader:{fontSize:"20px",fontWeight:x.a.fontWeightBold,textTransform:"uppercase",wordSpacing:"32px",textColor:x.a.gray96,shortForm:!0}},Card:{backgroundColor:x.a.gray17,clickableSelectedBorderColor:x.a.transparent,borderColor:x.a.transparent,borderRadius:x.a.borderRadius,hoverShadow:"none",focusShadow:"none",hoverBackgroundColor:x.a.gray29,focusBackgroundColor:x.a.gray29,selectedBackgroundColor:x.a.gray29,Header:{padding:"12px 8px 12px 16px"},Body:{padding:"16px",firstChildPaddingTop:"16px"},Footer:{padding:"8px 16px 16px",borderTop:"none"}},Chip:{clickableColor:x.a.gray96,clickableBackgroundColor:x.a.gray29,clickableHoverBackgroundColor:x.a.gray35,clickableDisabledBackgroundColor:x.a.gray20,labelColor:x.a.gray96,iconColor:x.a.gray96,errorColorBackgroundColor:x.a.errorColor},Code:{commentToken:x.a.gray52,prologToken:x.a.gray52,doctypeToken:x.a.gray52,cdataToken:x.a.gray52,punctuationToken:x.a.gray52,propertyToken:x.a.syntaxPurpleLight,tagToken:x.a.syntaxPurpleLight,booleanToken:x.a.syntaxPurpleLight,numberToken:x.a.syntaxPurpleLight,constantToken:x.a.syntaxPurpleLight,symbolToken:x.a.syntaxPurpleLight,deletedToken:x.a.syntaxPurpleLight,selectorToken:x.a.syntaxGreenLight,"attr-nameToken":x.a.syntaxGreenLight,stringToken:x.a.syntaxGreenLight,charToken:x.a.syntaxGreenLight,builtinToken:x.a.syntaxGreenLight,insertedToken:x.a.syntaxGreenLight,operatorToken:x.a.syntaxBrown,entityToken:x.a.syntaxBrown,urlToken:x.a.syntaxBrown,atruleToken:x.a.syntaxBlueLight,"attr-valueToken":x.a.syntaxBlueLight,keywordToken:x.a.syntaxBlueLight,functionToken:x.a.syntaxRedLight,regexToken:x.a.syntaxOrange,importantToken:x.a.syntaxOrange,variableToken:x.a.syntaxOrange},CollapsiblePanel:{minHeight:"40px",backgroundColor:x.a.gray17,marginTop:"1px",iconTransition:"transform 200ms",iconPosition:"calc(100% - 24px);",iconTransfromOpen:"rotate(90deg)",iconTransfromClose:"translateY(-2px) rotate(-90deg)",iconTransfromOrigin:"center",paddingBottom:"2px",titleLineHeight:"24px",titlePadding:"8px 16px",titleBackgroundColor:x.a.backgroundColor,titleClickableCollapsedBackgroundColor:x.a.backgroundColor,titleClickableHoverBackgroundColor:x.a.backgroundColor,titleClickableColor:x.a.white,titleClickableCollapsedColor:x.a.textGray,titleBorder:"1px solid transparent",titleFocusBorder:"1px solid ".concat(x.a.gray68),titleShadow:"0px -1px 0px rgba(255, 255, 255, 0.1), 0px 1px 0px rgba(255, 255, 255, 0.1)",titleFocusShadow:"none",descriptionPosition:"relative",descriptionPositionRight:"20px"},Color:{inputTopLayout:!0,width:"214px",display:"flex",flexDirection:"column-reverse",borderRadius:"4px",swatchesListMarginRight:"-8px",swatchesListMarginBottom:"-8px",Swatch:{marginRight:"8px",marginBottom:"8px",borderRadius:"2px",border:"1px solid ".concat(x.a.gray35),transparentPatternEvenColor:x.a.transparent,transparentPatternOddColor:"rgba(0, 0, 0, 0.2)",transparentBackgroundColor:x.a.white,textBoxSwatch:!0,focusBorderColor:x.a.gray35,smallSize:"22px"},Input:{width:"calc(100% - 2px)",marginBottom:"8px",position:"relative"}},Date:{position:"relative",letterSpacing:"2px",spacedFormat:!0,width:"145px",widthLarge:"155px",widthSmall:"125px",shouldRenderIcon:!0},File:{cloudIcon:!0,mediumDropTargetBoxBorderColor:x.a.gray52,mediumDropTargetBoxDisabledFileCount0BackgroundColor:x.a.transparent,borderDragOver:"1px dashed ".concat(x.a.gray52),iconFill:x.a.white,iconErrorFill:x.a.errorColor,iconDisabledFill:x.a.gray52,padding:"8px",backgroundColorDragOver:x.a.gray35,errorTextColor:x.a.errorColor,disabledBorder:"1px solid ".concat(x.a.gray35),linkErrorColor:x.a.errorColor,linkFocusShadow:"none",windowDropBorder:"5px solid ".concat(x.a.blue2),Item:{itemRemoveable:!0,boxColor:x.a.white,labelColor:x.a.white,boxBackgroundColor:x.a.gray29,labelDisabledBackgroundColor:x.a.gray29,labelDisabledTextColor:x.a.textDisabledColor,borderRadius:x.a.borderRadius,fontSize:"12px",padding:"4px 0 3px 8px",cursor:"pointer",flex:"none",labelHoverBackgroundColor:x.a.gray35,labelErrorBackgroundColor:"rgba(254, 58, 58, 0.1)",labelErrorHoverBackgroundColor:"rgba(254, 58, 58, 0.2)",removeClickableBackgroundColor:x.a.gray35,removeClickableBorderRadius:"50%",removeClickableErrorBorder:"none",removeClickableErrorBackgroundColor:l()(x.a.errorColor).setAlpha(.7).toRgbString(),removeClickableErrorHoverBackgroundColor:x.a.errorColor,removeClickableErrorFocusBackgroundColor:x.a.errorColor,removeClickableFocusShadow:"none",removeClickableFocusBackgroundColor:x.a.gray52,removeClickableFocusColor:x.a.white,removeClickableHoverBackgroundColor:x.a.gray52,removeClickableHoverColor:x.a.white,removeClickableSmallFlexBasis:"auto",removeClickableSmallTop:"6px"}},Heading:{fontSize:x.a.fontSize,fontWeight:x.a.fontWeightBold,h1FontSize:"36px",h2FontSize:"24px",h3FontSize:"20px",h4FontSize:"16px",h5FontSize:"13px",h1LineHeight:"48px",h2LineHeight:"24px",h3LineHeight:"24px",h4LineHeight:"24px",h5LineHeight:"16px",headingColor:x.a.gray96,sectionColor:x.a.gray68},Image:{cloudIcon:!0,overflow:"hidden",borderRadius:x.a.borderRadius,boxBackgroundColor:x.a.gray29,boxBackgroundHoverColor:x.a.gray35,cursor:"pointer",labelColor:x.a.white,padding:"8px 10px",fontSize:"12px",lineHeight:"16px",removeClickableColor:x.a.white,removeClickableFlex:"none",removeClickableBorderRadius:"50%",removeClickableBackgroundColor:x.a.gray52,removeClickableHoverBackgroundColor:x.a.gray68,removeClickableHoverLabelBackgroundColor:x.a.gray68,removeClickableHoverColor:x.a.white,removeClickableFocusColor:x.a.white,removeClickableFocusShadow:"none",removeClickableFocusBackgroundColor:x.a.gray68},JSONTree:{TreeNode:{propertyColor:x.a.syntaxRedLight,expandLinkClickableColor:x.a.accentColorL40,typeColorNumber:x.a.syntaxBlueLight,typeColorBoolean:x.a.syntaxPurpleLight}},Link:{focusShadow:"none",disabledColor:x.a.textDisabledColor,focusTextDecoration:"underline",focusActiveTextDecoration:"none",externalMargin:"0 0 0 4px"},Logo:{svgTextFill:x.a.white,svgInvertedTextFill:x.a.gray20},Markdown:{codeBlockBackgroundColor:x.a.gray29,codeInlineBackgroundColor:x.a.gray29},Menu:{backgroundColor:x.a.gray29,Divider:{borderColor:x.a.gray35},Item:{clickableColor:x.a.gray96,matchColorBackground:x.a.gray96,matchColor:x.a.gray11,descriptionLineHeight:"16px",descriptionColor:x.a.gray68,backgroundColorHover:x.a.gray35,backgroundColorFocus:x.a.gray35,backgroundColorActive:x.a.gray35,focusShadowInset:"inset 0 0 0 0 ".concat(x.a.transparent),itemIconMarginRight:"16px",itemIconVertical:"initial",itemSelectedIconColor:x.a.gray96,itemSelectedIconLeft:"initial",itemSelectedIconTop:"11px",itemSelectedIconRight:"16px",disabledSelectedIconColor:x.a.gray52,lineHeight:"24px",spacingHalf:"16px",padding:"12px 16px",selectablePaddingLeft:"16px",selectablePaddingRight:"44px",selectablePosition:"right",checkboxPaddingLeft:"56px"},Heading:{padding:"13px 16px 10px 16px"}},Message:{boxInfoBackgroundColor:l()(x.a.infoColor).setAlpha(.5).toRgbString(),boxSuccessBackgroundColor:l()(x.a.successColor).setAlpha(.5).toRgbString(),boxWarningBackgroundColor:l()(x.a.warningColor).setAlpha(.5).toRgbString(),boxErrorBackgroundColor:l()(x.a.errorColor).setAlpha(.5).toRgbString()},Modal:{boxShadow:"0px 4px 8px 0px rgba(0,0,0,0.5)",verticalAlign:"center",transform:"translate(-50%, -50%)",Body:{boxBackgroundColor:x.a.gray20},Footer:{boxBackgroundColor:x.a.gray20,boxBorderTopColor:x.a.gray29},Header:{boxBackgroundColor:x.a.gray20,boxBorderBottomColor:x.a.gray29,titleColor:x.a.gray96,boxPadding:"24px",closeAndPeekPaddingRight:"88px",closeOrPeekPaddingRight:"52px",titleFontWeightSemiBold:"500",titleLineHeight:"24px",subTitleLineHeight:"24px",iconBackgroundColor:x.a.gray29}},ModalLayer:{backgroundColor:x.a.backgroundColor},Multiselect:{Normal:{boxBackgroundColor:x.a.gray17,boxBorderColor:x.a.gray29,boxDisabledBackgroundColor:x.a.gray29,boxDisabledBorderColor:x.a.gray23}},Number:{controlsBorder:"1px solid transparent",incrementorBackgroundColor:x.a.gray20,incrementorBorderColor:x.a.transparent,incrementorColor:x.a.gray68,incrementorDisabledBorderColor:x.a.transparent,incrementorDisabledColor:x.a.gray35,incrementorHoverColor:x.a.gray96,incrementorWidth:"22px",mediumWidth:"116px",minusButtonBorderRightColor:x.a.transparent,plusButtonBorderRightColor:x.a.transparent},Paragraph:{marginBottom:"14px"},Popover:{align:"edge",lightBorder:x.a.transparent,lightBoxShadow:"0px 4px 8px 0px rgba(0,0,0,0.5)",lightBackgroundColor:x.a.gray17,lightColor:x.a.gray96,darkBackgroundColor:x.a.gray96,darkColor:x.a.gray17,darkBorderRadius:x.a.borderRadius,arrowHeightPixel:0,paddingPixel:8},Resize:{resizeColor:x.a.gray96},Slider:{sliderBarStepMarksColor:x.a.gray20,sliderBarDisabledBackgroundColor:x.a.gray23,sliderBarLeftSideColor:x.a.gray35,sliderBarRightSideColor:x.a.gray68,sliderThumbBackgroundColor:x.a.gray35,sliderThumbDisabledBackgroundColor:x.a.gray23},StepBar:{Step:{currentStepColor:x.a.gray96,currentStepFontWeight:x.a.fontWeightSemiBold,grayFill:x.a.gray68,nextStroke:x.a.gray68,prevOrActiveFillColor:x.a.blue2}},Switch:{labelPaddingLeft:"12px",labelLineHeight:"24px",Checkbox:{color:x.a.white,borderColor:x.a.gray52,top:"3px",margin:"3px",focusShadow:"none",hasBackground:!0,selectedBorderColor:x.a.blue2,selectedBackgroundColor:x.a.blue2,disabledBorderColor:x.a.gray52,disabledColor:x.a.textDisabledColor,errorBorderColor:x.a.errorColor,someSize:"6px",someMargin:"0px"},Radio:{color:x.a.white,borderColor:x.a.gray52,margin:"3px",focusShadow:"none",hasBackground:!0,selectedBorderColor:x.a.white,disabledColor:x.a.gray35,disabledBorderColor:x.a.gray35,errorBorderColor:x.a.errorColor},Toggle:{top:"3px",width:"30px",toggleShadow:"none",toggleIndicatorShadowOn:"0px 3px 8px rgba(0, 0, 0, 0.25)",toggleIndicatorShadowOff:"0px 1px 3px rgba(0, 0, 0, 0.25)",toggleFocusShadow:"none",toggleFocusBorderColor:x.a.transparent,indicatorSize:"14px",indicatorMargin:"2px",toggleIndicatorBorderStyle:"none",backgroundColor:x.a.gray35,borderColor:x.a.transparent,selectedBorderColor:x.a.transparent,indicatorBackgroundColor:x.a.white,outlineMargin:"-6px",outlineBorderRadius:"15px",outlineHoverBackgroundColor:"rgba(255, 255, 255, 0.15)",outlineFocusBackgroundColor:"rgba(255, 255, 255, 0.15)",disabledBorderColor:x.a.gray20,disabledBackgroundColor:x.a.gray20,disabledIndBackgroundColor:x.a.gray35,disabledIndBorderColor:x.a.transparent,selectedBackgroundColor:x.a.blue2,selectedDisabledBackgroundColor:x.a.gray29,selectedDisabledIndBackgroundColor:x.a.gray52,errorToggleOutlineBorderColor:x.a.transparent,errorToggleBackgroundColor:x.a.errorColor}},TabBar:{Tab:{afterColor:"transparent",afterContent:"attr(title)",afterDisplay:"block",afterFontWeight:"bold",afterHeight:"0px",afterOverflow:"hidden",afterVisibility:"hidden",clickableColor:x.a.gray68,hoverColor:x.a.gray96,focusColor:x.a.gray96,focusShadowInset:"inset 0 0 0 0 ".concat(x.a.transparent),selectedColor:x.a.gray96,selectedFontWeight:"bold",underlineSelectedBackgroundColor:x.a.borderLightColor}},Table:{focusShadowInset:"none",Cell:{clickableHoverBackgroundColor:x.a.backgroundColorHover,clickableExpandIconColor:x.a.white,expandContainerHoverBackgroundColor:x.a.backgroundColorHover,padding:"12px 8px 11px 8px",firstChildColor:x.a.gray96,rowActionsPadding:"6px 8px 5px 0",expandPadding:"6px 2px 0 0",linkColor:x.a.gray68,linkFocusColor:x.a.white,fontSize:x.a.fontSize,lineHeight:"24px",verticalAlign:"middle",disabledTextColor:x.a.textDisabledColor},Head:{toggleAllWidth:"36px",infoWidth:"36px"},HeadCell:{backgroundColor:x.a.backgroundColor,draggingBackgroundColor:x.a.gray04,focusShadow:"none",borderLeftColor:x.a.transparent,moreInfoHeadCellPadding:"7px 9px 8px 6px",focusBackgroundColor:x.a.gray35,toggleAllFocusBorderColor:x.a.gray96},HeadInner:{sortIconColor:x.a.gray96,sortIconPosition:"relative",sortedIconColor:x.a.gray96,menuIconColor:x.a.gray96,menuIconPadding:"0 0 0 4px",helperBackgroundColor:x.a.accentColorD50,hoverColor:x.a.gray96,borderRadius:x.a.borderRadius,padding:"8px 0",toggleAllPadding:"6px 0",toggleAllFocusBorderColor:x.a.gray96,labelPadding:"4px 8px",menuIconRight:"16px",color:x.a.gray96,fontSize:x.a.fontSizeSmall,lineHeight:"16px",dragContainerTop:"8px",dragContainerLeft:"10px",dragContainerPadding:"5px 16px 5px 8px",focusBackgroundColor:x.a.gray35},Row:{backgroundColor:x.a.backgroundColor,stripeHoverBackgroundColor:x.a.backgroundColorHover,hoverColor:x.a.gray96,stripeNoneClickableHoverBackgroundColor:x.a.backgroundColorHover,stripeEvenBackgroundColor:x.a.backgroundColor,clickableHoverColor:x.a.gray96,borderBottom:"1px solid ".concat(x.a.gray29),toggleAllFocusBorderColor:x.a.gray96,toggleFocusBackgroundColor:x.a.gray35,toggleFocusBorderColor:x.a.transparent,expandContainerWidth:"36px",borderRadius:"18px",padding:"4px 0 8px",selectedTextColor:x.a.gray96,disabledBackgroundColor:x.a.gray17,linkHoverColor:x.a.gray96,linkFocusBackgroundColor:x.a.backgroundColorHover,linkActiveBackgroundColor:x.a.gray17},RowDragCell:{draggablePadding:"17px 0 16px 0",draggingBackgroundColor:x.a.gray04,helperBackgroundColor:x.a.accentColorD50,width:"36px",toggleAllFocusBorderColor:x.a.gray96},Toggle:{inHeadMargin:"-10px 0",margin:"-6px 0",position:"relative",top:"-3px"}},Text:{clearIconRight:"8px",clearIconTop:"6px",clearIconPadding:"6px",inputBackgroundColor:x.a.gray17,inputColor:x.a.gray96,inputDisabledColor:x.a.textDisabledColor,inputErrorBorderColor:x.a.errorColor,inputFocusBorderColor:x.a.gray52,inputFocusColor:x.a.gray96,inputFocusShadow:"none",inputDisabledBackgroundColor:x.a.gray17,inputDisabledBorderColor:x.a.gray17,inputErrorColor:x.a.gray96,inputClearOrSearchPaddingRight:"40px",placeholderMediumSize:"16px",placeholderWithSearchLeft:"40px",spacingHalf:"16px",spacingQuarter:"7px",searchIconWrapperColor:x.a.gray68,clearColor:x.a.gray68,disabledSearchIconColor:x.a.textDisabledColor,searchIconWrapperRight:"12px",searchIconWrapperTop:"10px",searchIconPosition:"left",searchIconPaddingLeft:"40px"},WaitSpinner:{circleStroke:x.a.white}}});var w=d,k=m,_=y,S=j,C={enterprise:w,enterpriseDark:k,lite:_,scp:S},A=function(e){return e.theme&&e.theme["react-ui"]?e.theme["react-ui"]:w["react-ui"]},T=function(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];return function(e){return 1===n.length?A(e).base[n[0]]:n.reduce(function(e,n){return e&&e[n]?e[n]:null},A(e))}},O=function(e){return function(){for(var n=arguments.length,t=new Array(n),o=0;o<n;o++)t[o]=arguments[o];return function(n){var o;return(o=A(n).base.mixins)[e].apply(o,t)}}},P=Object.prototype.hasOwnProperty.call(r.a.a.withConfig({displayName:"themes__isStyledComponents3",componentId:"mltk-viz-kb0ftx-0"})(""),"extend"),M=function(e){return o=e,(t=P?"innerRef":"ref")in(n={})?Object.defineProperty(n,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):n[t]=o,n;var n,t,o};t.d(n,"variable",function(){return T}),t.d(n,"mixin",function(){return O}),t.d(n,"enterprise",function(){return w}),t.d(n,"enterpriseDark",function(){return k}),t.d(n,"lite",function(){return _}),t.d(n,"scp",function(){return S}),t.d(n,"themes",function(){return C}),t.d(n,"ref",function(){return M})}})},"./node_modules/@splunk/splunk-utils/themes.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.defaultTheme=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"undefined"!=typeof window?window:null;if(!e)return"enterprise";var n=e.__splunkd_partials__&&e.__splunkd_partials__["/services/server/info"]&&e.__splunkd_partials__["/services/server/info"].entry[0].content.product_type,t=e.__splunk_ui_theme__,o=e.$C&&e.$C.SPLUNK_UI_THEME;return t||o||n||"enterprise"}},"./node_modules/@splunk/splunk-web-core/build_tools/web_loaders/splunk-public-path-injection-loader.js?/static/app/Splunk_ML_Toolkit/!./src/main/webapp/visualizations/BoxViz/visualization.es":function(e,n,t){var o,r;t.p=function(){function e(e,n){if(window.$C&&window.$C.hasOwnProperty(e))return window.$C[e];if(void 0!==n)return n;throw new Error("getConfigValue - "+e+" not set, no default provided")}return function(){for(var n,t,o="",r=0,i=arguments.length;r<i;r++)(t=(n=arguments[r].toString()).length)>1&&"/"==n.charAt(t-1)&&(n=n.substring(0,t-1)),"/"!=n.charAt(0)?o+="/"+n:o+=n;if("/"!=o){var s=o.split("/"),a=s[1];if("static"==a||"modules"==a){var l=o.substring(a.length+2,o.length);o="/"+a,window.$C.BUILD_NUMBER&&(o+="/@"+window.$C.BUILD_NUMBER),window.$C.BUILD_PUSH_NUMBER&&(o+="."+window.$C.BUILD_PUSH_NUMBER),"app"==s[2]&&(o+=":"+e("APP_BUILD",0)),o+="/"+l}}var c=e("MRSPARKLE_ROOT_PATH","/"),d="/"+e("LOCALE","en-US")+o;return""==c||"/"==c?d:c+d}("/static/app/Splunk_ML_Toolkit/")+"/"}(),t("./node_modules/core-js/modules/es.symbol.js"),t("./node_modules/core-js/modules/es.symbol.description.js"),t("./node_modules/core-js/modules/es.symbol.async-iterator.js"),t("./node_modules/core-js/modules/es.symbol.has-instance.js"),t("./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"),t("./node_modules/core-js/modules/es.symbol.iterator.js"),t("./node_modules/core-js/modules/es.symbol.match.js"),t("./node_modules/core-js/modules/es.symbol.replace.js"),t("./node_modules/core-js/modules/es.symbol.search.js"),t("./node_modules/core-js/modules/es.symbol.species.js"),t("./node_modules/core-js/modules/es.symbol.split.js"),t("./node_modules/core-js/modules/es.symbol.to-primitive.js"),t("./node_modules/core-js/modules/es.symbol.to-string-tag.js"),t("./node_modules/core-js/modules/es.symbol.unscopables.js"),t("./node_modules/core-js/modules/es.array.concat.js"),t("./node_modules/core-js/modules/es.array.copy-within.js"),t("./node_modules/core-js/modules/es.array.every.js"),t("./node_modules/core-js/modules/es.array.fill.js"),t("./node_modules/core-js/modules/es.array.filter.js"),t("./node_modules/core-js/modules/es.array.find.js"),t("./node_modules/core-js/modules/es.array.find-index.js"),t("./node_modules/core-js/modules/es.array.flat.js"),t("./node_modules/core-js/modules/es.array.flat-map.js"),t("./node_modules/core-js/modules/es.array.for-each.js"),t("./node_modules/core-js/modules/es.array.from.js"),t("./node_modules/core-js/modules/es.array.includes.js"),t("./node_modules/core-js/modules/es.array.index-of.js"),t("./node_modules/core-js/modules/es.array.iterator.js"),t("./node_modules/core-js/modules/es.array.join.js"),t("./node_modules/core-js/modules/es.array.last-index-of.js"),t("./node_modules/core-js/modules/es.array.map.js"),t("./node_modules/core-js/modules/es.array.of.js"),t("./node_modules/core-js/modules/es.array.reduce.js"),t("./node_modules/core-js/modules/es.array.reduce-right.js"),t("./node_modules/core-js/modules/es.array.reverse.js"),t("./node_modules/core-js/modules/es.array.slice.js"),t("./node_modules/core-js/modules/es.array.some.js"),t("./node_modules/core-js/modules/es.array.sort.js"),t("./node_modules/core-js/modules/es.array.species.js"),t("./node_modules/core-js/modules/es.array.splice.js"),t("./node_modules/core-js/modules/es.array.unscopables.flat.js"),t("./node_modules/core-js/modules/es.array.unscopables.flat-map.js"),t("./node_modules/core-js/modules/es.array-buffer.constructor.js"),t("./node_modules/core-js/modules/es.array-buffer.is-view.js"),t("./node_modules/core-js/modules/es.array-buffer.slice.js"),t("./node_modules/core-js/modules/es.data-view.js"),t("./node_modules/core-js/modules/es.date.to-iso-string.js"),t("./node_modules/core-js/modules/es.date.to-json.js"),t("./node_modules/core-js/modules/es.date.to-primitive.js"),t("./node_modules/core-js/modules/es.date.to-string.js"),t("./node_modules/core-js/modules/es.function.has-instance.js"),t("./node_modules/core-js/modules/es.function.name.js"),t("./node_modules/core-js/modules/es.json.to-string-tag.js"),t("./node_modules/core-js/modules/es.map.js"),t("./node_modules/core-js/modules/es.math.acosh.js"),t("./node_modules/core-js/modules/es.math.asinh.js"),t("./node_modules/core-js/modules/es.math.atanh.js"),t("./node_modules/core-js/modules/es.math.cbrt.js"),t("./node_modules/core-js/modules/es.math.clz32.js"),t("./node_modules/core-js/modules/es.math.cosh.js"),t("./node_modules/core-js/modules/es.math.expm1.js"),t("./node_modules/core-js/modules/es.math.fround.js"),t("./node_modules/core-js/modules/es.math.hypot.js"),t("./node_modules/core-js/modules/es.math.imul.js"),t("./node_modules/core-js/modules/es.math.log10.js"),t("./node_modules/core-js/modules/es.math.log1p.js"),t("./node_modules/core-js/modules/es.math.log2.js"),t("./node_modules/core-js/modules/es.math.sign.js"),t("./node_modules/core-js/modules/es.math.sinh.js"),t("./node_modules/core-js/modules/es.math.tanh.js"),t("./node_modules/core-js/modules/es.math.to-string-tag.js"),t("./node_modules/core-js/modules/es.math.trunc.js"),t("./node_modules/core-js/modules/es.number.constructor.js"),t("./node_modules/core-js/modules/es.number.epsilon.js"),t("./node_modules/core-js/modules/es.number.is-finite.js"),t("./node_modules/core-js/modules/es.number.is-integer.js"),t("./node_modules/core-js/modules/es.number.is-nan.js"),t("./node_modules/core-js/modules/es.number.is-safe-integer.js"),t("./node_modules/core-js/modules/es.number.max-safe-integer.js"),t("./node_modules/core-js/modules/es.number.min-safe-integer.js"),t("./node_modules/core-js/modules/es.number.parse-float.js"),t("./node_modules/core-js/modules/es.number.parse-int.js"),t("./node_modules/core-js/modules/es.number.to-fixed.js"),t("./node_modules/core-js/modules/es.number.to-precision.js"),t("./node_modules/core-js/modules/es.object.assign.js"),t("./node_modules/core-js/modules/es.object.define-getter.js"),t("./node_modules/core-js/modules/es.object.define-setter.js"),t("./node_modules/core-js/modules/es.object.entries.js"),t("./node_modules/core-js/modules/es.object.freeze.js"),t("./node_modules/core-js/modules/es.object.from-entries.js"),t("./node_modules/core-js/modules/es.object.get-own-property-descriptor.js"),t("./node_modules/core-js/modules/es.object.get-own-property-descriptors.js"),t("./node_modules/core-js/modules/es.object.get-own-property-names.js"),t("./node_modules/core-js/modules/es.object.get-prototype-of.js"),t("./node_modules/core-js/modules/es.object.is.js"),t("./node_modules/core-js/modules/es.object.is-extensible.js"),t("./node_modules/core-js/modules/es.object.is-frozen.js"),t("./node_modules/core-js/modules/es.object.is-sealed.js"),t("./node_modules/core-js/modules/es.object.keys.js"),t("./node_modules/core-js/modules/es.object.lookup-getter.js"),t("./node_modules/core-js/modules/es.object.lookup-setter.js"),t("./node_modules/core-js/modules/es.object.prevent-extensions.js"),t("./node_modules/core-js/modules/es.object.seal.js"),t("./node_modules/core-js/modules/es.object.set-prototype-of.js"),t("./node_modules/core-js/modules/es.object.to-string.js"),t("./node_modules/core-js/modules/es.object.values.js"),t("./node_modules/core-js/modules/es.parse-float.js"),t("./node_modules/core-js/modules/es.parse-int.js"),t("./node_modules/core-js/modules/es.promise.js"),t("./node_modules/core-js/modules/es.promise.finally.js"),t("./node_modules/core-js/modules/es.reflect.apply.js"),t("./node_modules/core-js/modules/es.reflect.construct.js"),t("./node_modules/core-js/modules/es.reflect.define-property.js"),t("./node_modules/core-js/modules/es.reflect.delete-property.js"),t("./node_modules/core-js/modules/es.reflect.get.js"),t("./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"),t("./node_modules/core-js/modules/es.reflect.get-prototype-of.js"),t("./node_modules/core-js/modules/es.reflect.has.js"),t("./node_modules/core-js/modules/es.reflect.is-extensible.js"),t("./node_modules/core-js/modules/es.reflect.own-keys.js"),t("./node_modules/core-js/modules/es.reflect.prevent-extensions.js"),t("./node_modules/core-js/modules/es.reflect.set.js"),t("./node_modules/core-js/modules/es.reflect.set-prototype-of.js"),t("./node_modules/core-js/modules/es.regexp.constructor.js"),t("./node_modules/core-js/modules/es.regexp.exec.js"),t("./node_modules/core-js/modules/es.regexp.flags.js"),t("./node_modules/core-js/modules/es.regexp.to-string.js"),t("./node_modules/core-js/modules/es.set.js"),t("./node_modules/core-js/modules/es.string.code-point-at.js"),t("./node_modules/core-js/modules/es.string.ends-with.js"),t("./node_modules/core-js/modules/es.string.from-code-point.js"),t("./node_modules/core-js/modules/es.string.includes.js"),t("./node_modules/core-js/modules/es.string.iterator.js"),t("./node_modules/core-js/modules/es.string.match.js"),t("./node_modules/core-js/modules/es.string.pad-end.js"),t("./node_modules/core-js/modules/es.string.pad-start.js"),t("./node_modules/core-js/modules/es.string.raw.js"),t("./node_modules/core-js/modules/es.string.repeat.js"),t("./node_modules/core-js/modules/es.string.replace.js"),t("./node_modules/core-js/modules/es.string.search.js"),t("./node_modules/core-js/modules/es.string.split.js"),t("./node_modules/core-js/modules/es.string.starts-with.js"),t("./node_modules/core-js/modules/es.string.trim.js"),t("./node_modules/core-js/modules/es.string.trim-end.js"),t("./node_modules/core-js/modules/es.string.trim-start.js"),t("./node_modules/core-js/modules/es.string.anchor.js"),t("./node_modules/core-js/modules/es.string.big.js"),t("./node_modules/core-js/modules/es.string.blink.js"),t("./node_modules/core-js/modules/es.string.bold.js"),t("./node_modules/core-js/modules/es.string.fixed.js"),t("./node_modules/core-js/modules/es.string.fontcolor.js"),t("./node_modules/core-js/modules/es.string.fontsize.js"),t("./node_modules/core-js/modules/es.string.italics.js"),t("./node_modules/core-js/modules/es.string.link.js"),t("./node_modules/core-js/modules/es.string.small.js"),t("./node_modules/core-js/modules/es.string.strike.js"),t("./node_modules/core-js/modules/es.string.sub.js"),t("./node_modules/core-js/modules/es.string.sup.js"),t("./node_modules/core-js/modules/es.typed-array.float32-array.js"),t("./node_modules/core-js/modules/es.typed-array.float64-array.js"),t("./node_modules/core-js/modules/es.typed-array.int8-array.js"),t("./node_modules/core-js/modules/es.typed-array.int16-array.js"),t("./node_modules/core-js/modules/es.typed-array.int32-array.js"),t("./node_modules/core-js/modules/es.typed-array.uint8-array.js"),t("./node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"),t("./node_modules/core-js/modules/es.typed-array.uint16-array.js"),t("./node_modules/core-js/modules/es.typed-array.uint32-array.js"),t("./node_modules/core-js/modules/es.typed-array.copy-within.js"),t("./node_modules/core-js/modules/es.typed-array.every.js"),t("./node_modules/core-js/modules/es.typed-array.fill.js"),t("./node_modules/core-js/modules/es.typed-array.filter.js"),t("./node_modules/core-js/modules/es.typed-array.find.js"),t("./node_modules/core-js/modules/es.typed-array.find-index.js"),t("./node_modules/core-js/modules/es.typed-array.for-each.js"),t("./node_modules/core-js/modules/es.typed-array.from.js"),t("./node_modules/core-js/modules/es.typed-array.includes.js"),t("./node_modules/core-js/modules/es.typed-array.index-of.js"),t("./node_modules/core-js/modules/es.typed-array.iterator.js"),t("./node_modules/core-js/modules/es.typed-array.join.js"),t("./node_modules/core-js/modules/es.typed-array.last-index-of.js"),t("./node_modules/core-js/modules/es.typed-array.map.js"),t("./node_modules/core-js/modules/es.typed-array.of.js"),t("./node_modules/core-js/modules/es.typed-array.reduce.js"),t("./node_modules/core-js/modules/es.typed-array.reduce-right.js"),t("./node_modules/core-js/modules/es.typed-array.reverse.js"),t("./node_modules/core-js/modules/es.typed-array.set.js"),t("./node_modules/core-js/modules/es.typed-array.slice.js"),t("./node_modules/core-js/modules/es.typed-array.some.js"),t("./node_modules/core-js/modules/es.typed-array.sort.js"),t("./node_modules/core-js/modules/es.typed-array.subarray.js"),t("./node_modules/core-js/modules/es.typed-array.to-locale-string.js"),t("./node_modules/core-js/modules/es.typed-array.to-string.js"),t("./node_modules/core-js/modules/es.weak-map.js"),t("./node_modules/core-js/modules/es.weak-set.js"),t("./node_modules/core-js/modules/esnext.aggregate-error.js"),t("./node_modules/core-js/modules/esnext.array.last-index.js"),t("./node_modules/core-js/modules/esnext.array.last-item.js"),t("./node_modules/core-js/modules/esnext.composite-key.js"),t("./node_modules/core-js/modules/esnext.composite-symbol.js"),t("./node_modules/core-js/modules/esnext.global-this.js"),t("./node_modules/core-js/modules/esnext.map.delete-all.js"),t("./node_modules/core-js/modules/esnext.map.every.js"),t("./node_modules/core-js/modules/esnext.map.filter.js"),t("./node_modules/core-js/modules/esnext.map.find.js"),t("./node_modules/core-js/modules/esnext.map.find-key.js"),t("./node_modules/core-js/modules/esnext.map.from.js"),t("./node_modules/core-js/modules/esnext.map.group-by.js"),t("./node_modules/core-js/modules/esnext.map.includes.js"),t("./node_modules/core-js/modules/esnext.map.key-by.js"),t("./node_modules/core-js/modules/esnext.map.key-of.js"),t("./node_modules/core-js/modules/esnext.map.map-keys.js"),t("./node_modules/core-js/modules/esnext.map.map-values.js"),t("./node_modules/core-js/modules/esnext.map.merge.js"),t("./node_modules/core-js/modules/esnext.map.of.js"),t("./node_modules/core-js/modules/esnext.map.reduce.js"),t("./node_modules/core-js/modules/esnext.map.some.js"),t("./node_modules/core-js/modules/esnext.map.update.js"),t("./node_modules/core-js/modules/esnext.math.clamp.js"),t("./node_modules/core-js/modules/esnext.math.deg-per-rad.js"),t("./node_modules/core-js/modules/esnext.math.degrees.js"),t("./node_modules/core-js/modules/esnext.math.fscale.js"),t("./node_modules/core-js/modules/esnext.math.iaddh.js"),t("./node_modules/core-js/modules/esnext.math.imulh.js"),t("./node_modules/core-js/modules/esnext.math.isubh.js"),t("./node_modules/core-js/modules/esnext.math.rad-per-deg.js"),t("./node_modules/core-js/modules/esnext.math.radians.js"),t("./node_modules/core-js/modules/esnext.math.scale.js"),t("./node_modules/core-js/modules/esnext.math.seeded-prng.js"),t("./node_modules/core-js/modules/esnext.math.signbit.js"),t("./node_modules/core-js/modules/esnext.math.umulh.js"),t("./node_modules/core-js/modules/esnext.number.from-string.js"),t("./node_modules/core-js/modules/esnext.observable.js"),t("./node_modules/core-js/modules/esnext.promise.all-settled.js"),t("./node_modules/core-js/modules/esnext.promise.any.js"),t("./node_modules/core-js/modules/esnext.promise.try.js"),t("./node_modules/core-js/modules/esnext.reflect.define-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.delete-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.get-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js"),t("./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js"),t("./node_modules/core-js/modules/esnext.reflect.has-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js"),t("./node_modules/core-js/modules/esnext.reflect.metadata.js"),t("./node_modules/core-js/modules/esnext.set.add-all.js"),t("./node_modules/core-js/modules/esnext.set.delete-all.js"),t("./node_modules/core-js/modules/esnext.set.difference.js"),t("./node_modules/core-js/modules/esnext.set.every.js"),t("./node_modules/core-js/modules/esnext.set.filter.js"),t("./node_modules/core-js/modules/esnext.set.find.js"),t("./node_modules/core-js/modules/esnext.set.from.js"),t("./node_modules/core-js/modules/esnext.set.intersection.js"),t("./node_modules/core-js/modules/esnext.set.is-disjoint-from.js"),t("./node_modules/core-js/modules/esnext.set.is-subset-of.js"),t("./node_modules/core-js/modules/esnext.set.is-superset-of.js"),t("./node_modules/core-js/modules/esnext.set.join.js"),t("./node_modules/core-js/modules/esnext.set.map.js"),t("./node_modules/core-js/modules/esnext.set.of.js"),t("./node_modules/core-js/modules/esnext.set.reduce.js"),t("./node_modules/core-js/modules/esnext.set.some.js"),t("./node_modules/core-js/modules/esnext.set.symmetric-difference.js"),t("./node_modules/core-js/modules/esnext.set.union.js"),t("./node_modules/core-js/modules/esnext.string.at.js"),t("./node_modules/core-js/modules/esnext.string.code-points.js"),t("./node_modules/core-js/modules/esnext.string.match-all.js"),t("./node_modules/core-js/modules/esnext.string.replace-all.js"),t("./node_modules/core-js/modules/esnext.symbol.dispose.js"),t("./node_modules/core-js/modules/esnext.symbol.observable.js"),t("./node_modules/core-js/modules/esnext.symbol.pattern-match.js"),t("./node_modules/core-js/modules/esnext.weak-map.delete-all.js"),t("./node_modules/core-js/modules/esnext.weak-map.from.js"),t("./node_modules/core-js/modules/esnext.weak-map.of.js"),t("./node_modules/core-js/modules/esnext.weak-set.add-all.js"),t("./node_modules/core-js/modules/esnext.weak-set.delete-all.js"),t("./node_modules/core-js/modules/esnext.weak-set.from.js"),t("./node_modules/core-js/modules/esnext.weak-set.of.js"),t("./node_modules/core-js/modules/web.dom-collections.for-each.js"),t("./node_modules/core-js/modules/web.dom-collections.iterator.js"),t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/web.immediate.js"),t("./node_modules/core-js/modules/web.queue-microtask.js"),t("./node_modules/core-js/modules/web.url.js"),t("./node_modules/core-js/modules/web.url.to-json.js"),t("./node_modules/core-js/modules/web.url-search-params.js"),o=[n,t("./node_modules/regenerator-runtime/runtime.js"),t("shim/jquery"),t("vizapi/SplunkVisualizationBase"),t("./src/main/webapp/plots/BoxPlot.es"),t("./src/main/webapp/util/formatters/formatBoxData.es")],void 0===(r=function(t,o,r,i,s,a){"use strict";function l(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,r=l(r),i=l(i),s=l(s),a=l(a);var c=i.default.extend({initialize:function(){i.default.prototype.initialize.apply(this,arguments)},getInitialDataParams:function(){return{count:0,outputMode:i.default.ROW_MAJOR_OUTPUT_MODE}},setupView:function(){this.plot=new s.default((0,r.default)(this.el))},updateView:function(e){if(e&&null!=e.fields&&e.fields.length>0){var n=(0,a.default)(e);this.plot.setSeries(n.series[0].data,{minValue:n.minValue,maxValue:n.maxValue,xAxisLabel:"Field Labels",yAxisLabel:"Data",xAxis:n.xAxis},n.invalidXAxisFields)}},reflow:function(){null!=this.plot&&this.plot.reflow()}});t.default=c,e.exports=n.default}.apply(n,o))||(e.exports=r)},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_a-function.js":function(e,n){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_an-object.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_is-object.js");e.exports=function(e){if(!o(e))throw TypeError(e+" is not an object!");return e}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_cof.js":function(e,n){var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_core.js":function(e,n){var t=e.exports={version:"2.6.9"};"number"==typeof __e&&(__e=t)},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_ctx.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_a-function.js");e.exports=function(e,n,t){if(o(e),void 0===n)return e;switch(t){case 1:return function(t){return e.call(n,t)};case 2:return function(t,o){return e.call(n,t,o)};case 3:return function(t,o,r){return e.call(n,t,o,r)}}return function(){return e.apply(n,arguments)}}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_descriptors.js":function(e,n,t){e.exports=!t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_fails.js")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_dom-create.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_is-object.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js").document,i=o(r)&&o(r.createElement);e.exports=function(e){return i?r.createElement(e):{}}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_export.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_core.js"),i=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_hide.js"),s=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_redefine.js"),a=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_ctx.js"),l=function(e,n,t){var c,d,h,u,p=e&l.F,f=e&l.G,m=e&l.S,g=e&l.P,y=e&l.B,b=f?o:m?o[n]||(o[n]={}):(o[n]||{}).prototype,x=f?r:r[n]||(r[n]={}),v=x.prototype||(x.prototype={});for(c in f&&(t=n),t)h=((d=!p&&b&&void 0!==b[c])?b:t)[c],u=y&&d?a(h,o):g&&"function"==typeof h?a(Function.call,h):h,b&&s(b,c,h,e&l.U),x[c]!=h&&i(x,c,u),g&&v[c]!=h&&(v[c]=h)};o.core=r,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,e.exports=l},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_fails.js":function(e,n){e.exports=function(e){try{return!!e()}catch(e){return!0}}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_function-to-string.js":function(e,n,t){e.exports=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_shared.js")("native-function-to-string",Function.toString)},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js":function(e,n){var t=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_has.js":function(e,n){var t={}.hasOwnProperty;e.exports=function(e,n){return t.call(e,n)}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_hide.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_object-dp.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_property-desc.js");e.exports=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_descriptors.js")?function(e,n,t){return o.f(e,n,r(1,t))}:function(e,n,t){return e[n]=t,e}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_html.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js").document;e.exports=o&&o.documentElement},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_ie8-dom-define.js":function(e,n,t){e.exports=!t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_descriptors.js")&&!t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_fails.js")(function(){return 7!=Object.defineProperty(t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_dom-create.js")("div"),"a",{get:function(){return 7}}).a})},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_invoke.js":function(e,n){e.exports=function(e,n,t){var o=void 0===t;switch(n.length){case 0:return o?e():e.call(t);case 1:return o?e(n[0]):e.call(t,n[0]);case 2:return o?e(n[0],n[1]):e.call(t,n[0],n[1]);case 3:return o?e(n[0],n[1],n[2]):e.call(t,n[0],n[1],n[2]);case 4:return o?e(n[0],n[1],n[2],n[3]):e.call(t,n[0],n[1],n[2],n[3])}return e.apply(t,n)}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_is-object.js":function(e,n){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_library.js":function(e,n){e.exports=!1},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_object-dp.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_an-object.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_ie8-dom-define.js"),i=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_to-primitive.js"),s=Object.defineProperty;n.f=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_descriptors.js")?Object.defineProperty:function(e,n,t){if(o(e),n=i(n,!0),o(t),r)try{return s(e,n,t)}catch(e){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(e[n]=t.value),e}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_property-desc.js":function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_redefine.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_hide.js"),i=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_has.js"),s=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_uid.js")("src"),a=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_function-to-string.js"),l=(""+a).split("toString");t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_core.js").inspectSource=function(e){return a.call(e)},(e.exports=function(e,n,t,a){var c="function"==typeof t;c&&(i(t,"name")||r(t,"name",n)),e[n]!==t&&(c&&(i(t,s)||r(t,s,e[n]?""+e[n]:l.join(String(n)))),e===o?e[n]=t:a?e[n]?e[n]=t:r(e,n,t):(delete e[n],r(e,n,t)))})(Function.prototype,"toString",function(){return"function"==typeof this&&this[s]||a.call(this)})},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_shared.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_core.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js"),i=r["__core-js_shared__"]||(r["__core-js_shared__"]={});(e.exports=function(e,n){return i[e]||(i[e]=void 0!==n?n:{})})("versions",[]).push({version:o.version,mode:t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_library.js")?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_task.js":function(e,n,t){var o,r,i,s=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_ctx.js"),a=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_invoke.js"),l=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_html.js"),c=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_dom-create.js"),d=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_global.js"),h=d.process,u=d.setImmediate,p=d.clearImmediate,f=d.MessageChannel,m=d.Dispatch,g=0,y={},b=function(){var e=+this;if(y.hasOwnProperty(e)){var n=y[e];delete y[e],n()}},x=function(e){b.call(e.data)};u&&p||(u=function(e){for(var n=[],t=1;arguments.length>t;)n.push(arguments[t++]);return y[++g]=function(){a("function"==typeof e?e:Function(e),n)},o(g),g},p=function(e){delete y[e]},"process"==t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_cof.js")(h)?o=function(e){h.nextTick(s(b,e,1))}:m&&m.now?o=function(e){m.now(s(b,e,1))}:f?(i=(r=new f).port2,r.port1.onmessage=x,o=s(i.postMessage,i,1)):d.addEventListener&&"function"==typeof postMessage&&!d.importScripts?(o=function(e){d.postMessage(e+"","*")},d.addEventListener("message",x,!1)):o="onreadystatechange"in c("script")?function(e){l.appendChild(c("script")).onreadystatechange=function(){l.removeChild(this),b.call(e)}}:function(e){setTimeout(s(b,e,1),0)}),e.exports={set:u,clear:p}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_to-primitive.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_is-object.js");e.exports=function(e,n){if(!o(e))return e;var t,r;if(n&&"function"==typeof(t=e.toString)&&!o(r=t.call(e)))return r;if("function"==typeof(t=e.valueOf)&&!o(r=t.call(e)))return r;if(!n&&"function"==typeof(t=e.toString)&&!o(r=t.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_uid.js":function(e,n){var t=0,o=Math.random();e.exports=function(e){return"Symbol(".concat(void 0===e?"":e,")_",(++t+o).toString(36))}},"./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/web.immediate.js":function(e,n,t){var o=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_export.js"),r=t("./node_modules/@splunk/splunk-web-core/node_modules/core-js/modules/_task.js");o(o.G+o.B,{setImmediate:r.set,clearImmediate:r.clear})},"./node_modules/@splunk/themes/base.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o,r=(o=t("./node_modules/tinycolor2/tinycolor.js"))&&o.__esModule?o:{default:o};function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var s={white:"#ffffff",gray98:"#f7f8fa",gray96:"#f2f4f5",gray92:"#e1e6eb",gray80:"#c3cbd4",gray60:"#818d99",gray45:"#5c6773",gray30:"#3c444d",gray25:"#31373e",gray22:"#2b3033",gray20:"#171d21",black:"#000000"},a={accentColorL50:"#ecf8ff",accentColorL40:"#bfe9ff",accentColorL30:"#7ed2ff",accentColorL20:"#3ebcff",accentColorL10:"#00a4fd",accentColor:"#007abd",accentColorD10:"#006eaa",accentColorD20:"#006297",accentColorD30:"#005684",accentColorD40:"#004a71",accentColorD50:"#003d5e"},l={textColor:s.gray30,textGray:"#6b7785",textDisabledColor:s.gray80,linkColor:a.accentColorD10,linkColorHover:a.accentColor,borderLightColor:s.gray92,borderColor:s.gray80,focusColor:a.accentColorL10,backgroundColorHover:s.gray96,backgroundColor:s.white},c={focusShadow:"0 0 1px 2px ".concat((0,r.default)(l.focusColor).setAlpha(.6).toRgbString()),focusShadowInset:"inset 0 0 2px 1px ".concat(s.white,", inset 0 0 0 2px ").concat(l.focusColor),overlayShadow:"0 4px 8px rgba(0, 0, 0, 0.2)"},d="'Splunk Platform Sans', 'Proxima Nova', Roboto, Droid, 'Helvetica Neue', Helvetica, Arial, sans-serif",h=function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach(function(n){i(e,n,t[n])})}return e}({},s,a,{errorColorL50:"#fcedec",errorColorL40:"#f8dcd9",errorColorL30:"#f1b9b3",errorColorL20:"#ea958d",errorColorL10:"#e37267",errorColor:"#dc4e41",errorColorD10:"#c84535",errorColorD20:"#b23d30",errorColorD30:"#9c3529",errorColorD40:"#852d24",errorColorD50:"#6f261d"},{alertColorL50:"#fef3ec",alertColorL40:"#fde6d9",alertColorL30:"#facdb3",alertColorL20:"#f7b48c",alertColorL10:"#f49b66",alertColor:"#f1813f",alertColorD10:"#da742e",alertColorD20:"#c2672a",alertColorD30:"#aa5a25",alertColorD40:"#914d1f",alertColorD50:"#79401a"},{warningColorL50:"#fff9eb",warningColorL40:"#fef2d7",warningColorL30:"#fde5ae",warningColorL20:"#fbd886",warningColorL10:"#facb5d",warningColor:"#f8be34",warningColorD10:"#e0ac16",warningColorD20:"#c79915",warningColorD30:"#ae8613",warningColorD40:"#957312",warningColorD50:"#7d600f"},{successColorL50:"#eef6ee",successColorL40:"#ddecdd",successColorL30:"#bbd9ba",successColorL20:"#98c697",successColorL10:"#76b374",successColor:"#53a051",successColorD10:"#479144",successColorD20:"#40813d",successColorD30:"#387135",successColorD40:"#2f612e",successColorD50:"#275126"},{infoColorL50:"#e5f0f5",infoColorL40:"#cce2eb",infoColorL30:"#99c5d7",infoColorL20:"#66a7c4",infoColorL10:"#338ab0",infoColor:"#006d9c",infoColorD10:"#00577c",infoColorD20:"#004c6c",infoColorD30:"#00415d",infoColorD40:"#00364d",infoColorD50:"#002b3e"},{cat1Color:"#297ba5",cat1ColorL:"#78b9d6",cat2Color:"#4fa484",cat2ColorL:"#74d5c2",cat3Color:"#b6c75a",cat3ColorL:"#dce6a5",cat4Color:"#3c6188",cat4ColorL:"#a0b2ca",cat5Color:"#ec9960",cat5ColorL:"#fac9a7",cat6Color:"#a65c7d",cat6ColorL:"#d3a7ba",cat7Color:"#708794",cat7ColorL:"#b2c0c8",cat8Color:"#38b8bf",cat8ColorL:"#92dde2",cat9Color:"#ffde63",cat9ColorL:"#ffeeae",cat10Color:"#c19975",cat10ColorL:"#d7bfab",cat11Color:"#5a4575",cat11ColorL:"#b7acca",cat12Color:"#7ea77b",cat12ColorL:"#b2cab0",cat13Color:"#576d83",cat13ColorL:"#a5b2bf",cat14Color:"#d7c6b7",cat14ColorL:"#e9ddd4",cat15Color:"#339bb2",cat15ColorL:"#66c3d0",cat16Color:"#236d9b",cat16ColorL:"#66a7c2",cat17Color:"#e5dc80",cat17ColorL:"#f1eab7",cat18Color:"#96907f",cat18ColorL:"#c1bcb3",cat19Color:"#87bc65",cat19ColorL:"#b6d7a3",cat20Color:"#cf7e60",cat20ColorL:"#e1b2a1",cat21Color:"#7b5547",cat21ColorL:"#dec4ba",cat22Color:"#77d6d8",cat22ColorL:"#abe6e8",cat23Color:"#4a7f2c",cat23ColorL:"#91b282",cat24Color:"#f589ad",cat24ColorL:"#f8b7ce",cat25Color:"#6a2c5d",cat25ColorL:"#cba3c2",cat26Color:"#aaabae",cat26ColorL:"#cccdce",cat27Color:"#9a7438",cat27ColorL:"#c3ab89",cat28Color:"#a4d563",cat28ColorL:"#c7e6a3",cat29Color:"#7672a4",cat29ColorL:"#ada9c8",cat30Color:"#184b81",cat30ColorL:"#a4bbe0"},{diverging1ColorA:"#006d9c",diverging1ColorB:"#ec9960",diverging2ColorA:"#af575a",diverging2ColorB:"#62b3b2",diverging3ColorA:"#4fa484",diverging3ColorB:"#f8be34",diverging4ColorA:"#5a4575",diverging4ColorB:"#708794",diverging5ColorA:"#294e70",diverging5ColorB:"#b6c75a"},{syntaxBlue:"#2662fc",syntaxBlueLight:"#006d9c",syntaxBrown:"#a67f59",syntaxGray:"#8293a7",syntaxGreen:"#5ca300",syntaxGreenLight:"#5ba383",syntaxOrange:"#f58220",syntaxPink:"#cf00cf",syntaxPurple:"#7738ff",syntaxPurpleLight:"#b19cd9",syntaxRed:"#d90700",syntaxRedLight:"#af575a",syntaxTeal:"#00a8ab"},{spacing:"20px",spacingHalf:"10px",spacingQuarter:"5px",fontSize:"14px",fontSizeXSmall:"11px",fontSizeSmall:"12px",fontSizeLarge:"16px",fontSizeXLarge:"18px",fontSizeXXLarge:"24px",lineHeight:"20px",inputHeight:"32px",inputHeightSmall:"28px",inputHeightLarge:"38px",toastContainerWidth:"500px"},{sansFontFamily:d,serifFontFamily:"Georgia, 'Times New Roman', Times, serif",monoFontFamily:"'Splunk Platform Mono', Inconsolata, Consolas, 'Droid Sans Mono', Monaco, 'Courier New', Courier, monospace",fontFamily:d,fontWeightBold:"700",fontWeightSemiBold:"500"},l,{draggableBackground:"url('data:image/png;base64,".concat("iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAG0lEQVR4AWMAgioUjAoIyg9xAxBgFIymg1EAAD/iHoHfZJ8OAAAAAElFTkSuQmCC","') 0 0 / 8px 8px repeat")},c,{borderRadius:"3px",border:"1px solid ".concat(l.borderColor)},{zindexFixedNavbar:1030,zindexModalBackdrop:1040,zindexModal:1050,zindexPopover:1060,zindexToastMessages:2e3});n.default=h},"./node_modules/@splunk/themes/enterprise.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o,r=(o=t("./node_modules/@splunk/themes/base.js"))&&o.__esModule?o:{default:o},i=t("./node_modules/@splunk/themes/mixins.js");function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach(function(n){a(e,n,t[n])})}return e}function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var l=s({},r.default,{brandColorL50:"#f5fbf5",brandColorL40:"#dff2df",brandColorL30:"#bee6be",brandColorL20:"#9ed99e",brandColorL10:"#7ecd7e",brandColor:"#5cc05c",brandColorD10:"#49b849",brandColorD20:"#40a540",brandColorD30:"#389038",brandColorD40:"#307b30",brandColorD50:"#286728"}),c=s({},l,{mixins:{reset:(0,i.createReset)(l),clearfix:i.clearfix,ellipsis:i.ellipsis,printWidth100Percent:i.printWidth100Percent,printHide:i.printHide,printNoBackground:i.printNoBackground,printWrapAll:i.printWrapAll}});n.default=c},"./node_modules/@splunk/themes/enterpriseDark.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o,r=(o=t("./node_modules/@splunk/themes/enterprise.js"))&&o.__esModule?o:{default:o},i=t("./node_modules/@splunk/themes/mixins.js");function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach(function(n){a(e,n,t[n])})}return e}function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var l={backgroundColor:r.default.gray25,backgroundColorHover:r.default.gray30,borderColor:r.default.gray22,borderDarkColor:r.default.black,borderLightColor:r.default.gray60,textColor:r.default.white,textGray:r.default.gray92,textDisabledColor:r.default.gray45,linkColor:r.default.accentColorL10,linkColorHover:r.default.accentColorL20,border:"1px solid ".concat(r.default.gray22),borderDark:"1px solid ".concat(r.default.black),borderLight:"1px solid ".concat(r.default.gray60),focusShadowInset:"inset 0 0 2px 1px ".concat(r.default.gray25,", inset 0 0 0 2px ").concat(r.default.focusColor),draggableBackground:"url('data:image/png;base64,".concat("iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAXEgAAFxIBZ5/SUgAAAW5pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KICAgICAgICAgPGRjOnN1YmplY3Q+CiAgICAgICAgICAgIDxyZGY6QmFnLz4KICAgICAgICAgPC9kYzpzdWJqZWN0PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K72CKvQAAADdJREFUOBFj/PDp00cGJCDAx8ePxGUgJM+ErJgc9sAbQI6rh5seRkLxTEh+4KORYhcMtzglxz8AtKEQD3hiWXMAAAAASUVORK5CYII=","') 0 0 / 8px 8px repeat")},c=s({},r.default,l),d=s({},c,{mixins:s({},c.mixins,{reset:(0,i.createReset)(c)})});n.default=d},"./node_modules/@splunk/themes/lite.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o,r=(o=t("./node_modules/@splunk/themes/base.js"))&&o.__esModule?o:{default:o},i=t("./node_modules/@splunk/themes/mixins.js");function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach(function(n){a(e,n,t[n])})}return e}function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var l=s({},r.default,{brandColorL50:"#fef8f2",brandColorL40:"#fde6d2",brandColorL30:"#fbcda5",brandColorL20:"#f9b479",brandColorL10:"#f79b4c",brandColor:"#f58220",brandColorD10:"#ed740b",brandColorD20:"#d2670a",brandColorD30:"#b85b09",brandColorD40:"#9e4e07",brandColorD50:"#844106"}),c=s({},l,{mixins:{reset:(0,i.createReset)(l),clearfix:i.clearfix,ellipsis:i.ellipsis,printWidth100Percent:i.printWidth100Percent,printHide:i.printHide,printNoBackground:i.printNoBackground,printWrapAll:i.printWrapAll}});n.default=c},"./node_modules/@splunk/themes/mixins.js":function(e,n,t){"use strict";function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}Object.defineProperty(n,"__esModule",{value:!0}),n.createReset=function(e){var n={animation:"none 0s ease 0s 1 normal none running",backfaceVisibility:"visible",background:"transparent none repeat 0 0 / auto auto padding-box border-box scroll",border:"medium none currentColor",borderCollapse:"separate",borderImage:"none",borderRadius:0,borderSpacing:0,bottom:"auto",boxShadow:"none",captionSide:"top",clear:"none",clip:"auto",columns:"auto",columnCount:"auto",columnFill:"balance",columnGap:"normal",columnRule:"medium none currentColor",columnSpan:1,columnWidth:"auto",content:"normal",counterIncrement:"none",counterReset:"none",cursor:"auto",emptyCells:"show",float:"none",fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",fontStretch:"normal",height:"auto",hyphens:"none",left:"auto",letterSpacing:"normal",listStyle:"disc outside none",margin:0,maxHeight:"none",maxWidth:"none",minHeight:0,minWidth:0,opacity:1,orphans:2,overflow:"visible",overflowX:"visible",overflowY:"visible",padding:0,pageBreakAfter:"auto",pageBreakBefore:"auto",pageBreakInside:"auto",perspective:"none",perspectiveOrigin:"50% 50%",pointerEvents:"auto",position:"static",right:"auto",tabSize:8,tableLayout:"auto",textAlign:"left",textAlignLast:"auto",textDecoration:"none",textIndent:0,textShadow:"none",textTransform:"none",top:"auto",transform:"none",transformOrigin:"50% 50% 0",transformStyle:"flat",transition:"none 0s ease 0s",userSelect:"auto",verticalAlign:"baseline",whiteSpace:"normal",widows:2,width:"auto",wordSpacing:"normal",zIndex:"auto"};return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"inline",r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){o(e,n,t[n])})}return e}({},r?n:{},i?{all:i}:{},{fontFamily:e.fontFamily,fontSize:e.fontSize,lineHeight:e.lineHeight,color:e.textColor,boxSizing:"border-box",display:t,borderWidth:"1px",visibility:"inherit",outline:"medium none ".concat(e.focusColor)})}},n.clearfix=function(){return{"&::after":{display:"table",content:'""',clear:"both"}}},n.ellipsis=function(){return{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},n.printWidth100Percent=function(){return{maxWidth:"100% !important",width:"100% !important",overflow:"hidden !important"}},n.printHide=function(){return{display:"none !important"}},n.printNoBackground=function(){return{background:"none !important"}},n.printWrapAll=function(){return{wordBreak:"break-all !important",wordWrap:"break-word !important",overflowWrap:"break-word !important",whiteSpace:"normal !important"}}},"./node_modules/@splunk/themes/scp.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o,r=(o=t("./node_modules/tinycolor2/tinycolor.js"))&&o.__esModule?o:{default:o},i=t("./node_modules/@splunk/themes/mixins.js");function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach(function(n){a(e,n,t[n])})}return e}function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var l={white:"#ffffff",gray96:"#f5f5f5",gray68:"#acacad",gray52:"#818285",gray35:"#505158",gray29:"#43454b",gray23:"#33343b",gray20:"#2b2c33",gray17:"#23242b",gray11:"#15161b",gray04:"#08080a",black:"#000000"},c={blue1:"#0070f3",blue2:"#0084ff",blue3:"#4ba8ff",green1:"#08e045",red1:"#fe3a3a",orange1:"#ff761d",yellow1:"#ffc500",transparent:"transparent"},d={errorColorL50:"#ffecec",errorColorL40:"#ffc8c8",errorColorL30:"#ffa5a5",errorColorL20:"#fe8181",errorColorL10:"#fe5d5d",errorColor:c.red1,errorColorD10:"#fe1616",errorColorD20:"#ef0101",errorColorD30:"#cc0101",errorColorD40:"#a80101",errorColorD50:"#850101"},h={alertColorL50:"#ffe2cf",alertColorL40:"#ffcdac",alertColorL30:"#ffb788",alertColorL20:"#ffa164",alertColorL10:"#ff8c41",alertColor:c.orange1,alertColorD10:"#f86200",alertColorD20:"#d55400",alertColorD30:"#b14600",alertColorD40:"#8d3800",alertColorD50:"#692a00"},u={warningColorL50:"#ffeeb3",warningColorL40:"#ffe58f",warningColorL30:"#ffdd6b",warningColorL20:"#ffd547",warningColorL10:"#ffcd24",warningColor:c.yellow1,warningColorD10:"#dba900",warningColorD20:"#b88e00",warningColorD30:"#947200",warningColorD40:"#705700",warningColorD50:"#4d3b00"},p={textColor:l.gray68,textGray:l.gray52,textDisabledColor:l.gray52,linkColor:c.blue3,linkColorHover:c.blue3,borderLightColor:l.gray68,borderColor:l.gray29,borderDarkColor:l.black,focusColor:c.blue3,backgroundColorHover:l.gray20,backgroundColor:l.gray11},f={focusShadow:"0 0 1px 2px ".concat((0,r.default)(p.focusColor).setAlpha(.6).toRgbString()),focusShadowInset:"inset 0 0 2px 1px ".concat(l.gray29,", inset 0 0 0 2px ").concat(p.focusColor),overlayShadow:"0 4px 8px rgba(0, 0, 0, 0.2)"},m="'Splunk Platform Sans', 'Splunk Data Sans', Roboto, Droid, 'Helvetica Neue', Helvetica, Arial, sans-serif",g=s({},l,c,{accentColorL50:"#ecf8ff",accentColorL40:"#bfe9ff",accentColorL30:"#7ed2ff",accentColorL20:"#3ebcff",accentColorL10:"#00a4fd",accentColor:"#007abd",accentColorD10:"#006eaa",accentColorD20:"#006297",accentColorD30:"#005684",accentColorD40:"#004a71",accentColorD50:"#003d5e"},d,h,u,{successColorL50:"#eef6ee",successColorL40:"#ddecdd",successColorL30:"#bbd9ba",successColorL20:"#98c697",successColorL10:"#76b374",successColor:"#53a051",successColorD10:"#479144",successColorD20:"#40813d",successColorD30:"#387135",successColorD40:"#2f612e",successColorD50:"#275126"},{infoColorL50:"#e5f0f5",infoColorL40:"#cce2eb",infoColorL30:"#99c5d7",infoColorL20:"#66a7c4",infoColorL10:"#338ab0",infoColor:"#006d9c",infoColorD10:"#00577c",infoColorD20:"#004c6c",infoColorD30:"#00415d",infoColorD40:"#00364d",infoColorD50:"#002b3e"},{syntaxBlue:"#2662fc",syntaxBlueLight:"#006d9c",syntaxBrown:"#a67f59",syntaxGray:"#8293a7",syntaxGreen:"#5ca300",syntaxGreenLight:"#5ba383",syntaxOrange:"#f58220",syntaxPink:"#cf00cf",syntaxPurple:"#7738ff",syntaxPurpleLight:"#b19cd9",syntaxRed:"#d90700",syntaxRedLight:"#af575a",syntaxTeal:"#00a8ab"},{spacing:"20px",spacingHalf:"10px",spacingQuarter:"5px",fontSize:"14px",fontSizeXSmall:"11px",fontSizeSmall:"12px",fontSizeLarge:"16px",fontSizeXLarge:"18px",fontSizeXXLarge:"24px",lineHeight:"20px",inputHeight:"36px",inputHeightSmall:"28px",inputHeightLarge:"38px",toastContainerWidth:"500px"},{sansFontFamily:m,serifFontFamily:"Georgia, 'Times New Roman', Times, serif",monoFontFamily:"'Splunk Platform Mono', 'Roboto Mono', Consolas, 'Droid Sans Mono', Monaco, 'Courier New', Courier, monospace",fontFamily:m,fontWeightBold:"700",fontWeightSemiBold:"500"},p,{draggableBackground:"url('data:image/png;base64,".concat("iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAXEgAAFxIBZ5/SUgAAAW5pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KICAgICAgICAgPGRjOnN1YmplY3Q+CiAgICAgICAgICAgIDxyZGY6QmFnLz4KICAgICAgICAgPC9kYzpzdWJqZWN0PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K72CKvQAAADdJREFUOBFj/PDp00cGJCDAx8ePxGUgJM+ErJgc9sAbQI6rh5seRkLxTEh+4KORYhcMtzglxz8AtKEQD3hiWXMAAAAASUVORK5CYII=","') 0 0 / 8px 8px repeat")},f,{borderRadius:"4px",borderLight:"1px solid ".concat(l.gray68),border:"1px solid ".concat(p.borderColor),borderDark:"1px solid ".concat(l.black)},{zindexFixedNavbar:1030,zindexModalBackdrop:1040,zindexModal:1050,zindexPopover:1060,zindexToastMessages:2e3}),y=s({},g,{mixins:{reset:(0,i.createReset)(g),clearfix:i.clearfix,ellipsis:i.ellipsis,printWidth100Percent:i.printWidth100Percent,printHide:i.printHide,printNoBackground:i.printNoBackground,printWrapAll:i.printWrapAll}});n.default=y},"./node_modules/core-js/internals/a-function.js":function(e,n){e.exports=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e}},"./node_modules/core-js/internals/a-possible-prototype.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js");e.exports=function(e){if(!o(e)&&null!==e)throw TypeError("Can't set "+String(e)+" as a prototype");return e}},"./node_modules/core-js/internals/add-to-unscopables.js":function(e,n,t){var o=t("./node_modules/core-js/internals/well-known-symbol.js"),r=t("./node_modules/core-js/internals/object-create.js"),i=t("./node_modules/core-js/internals/hide.js"),s=o("unscopables"),a=Array.prototype;null==a[s]&&i(a,s,r(null)),e.exports=function(e){a[s][e]=!0}},"./node_modules/core-js/internals/advance-string-index.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/string-multibyte.js").charAt;e.exports=function(e,n,t){return n+(t?o(e,n).length:1)}},"./node_modules/core-js/internals/an-instance.js":function(e,n){e.exports=function(e,n,t){if(!(e instanceof n))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return e}},"./node_modules/core-js/internals/an-object.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js");e.exports=function(e){if(!o(e))throw TypeError(String(e)+" is not an object");return e}},"./node_modules/core-js/internals/array-buffer-view-core.js":function(e,n,t){"use strict";var o,r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/global.js"),s=t("./node_modules/core-js/internals/is-object.js"),a=t("./node_modules/core-js/internals/has.js"),l=t("./node_modules/core-js/internals/classof.js"),c=t("./node_modules/core-js/internals/hide.js"),d=t("./node_modules/core-js/internals/redefine.js"),h=t("./node_modules/core-js/internals/object-define-property.js").f,u=t("./node_modules/core-js/internals/object-get-prototype-of.js"),p=t("./node_modules/core-js/internals/object-set-prototype-of.js"),f=t("./node_modules/core-js/internals/well-known-symbol.js"),m=t("./node_modules/core-js/internals/uid.js"),g=i.DataView,y=g&&g.prototype,b=i.Int8Array,x=b&&b.prototype,v=i.Uint8ClampedArray,j=v&&v.prototype,w=b&&u(b),k=x&&u(x),_=Object.prototype,S=_.isPrototypeOf,C=f("toStringTag"),A=m("TYPED_ARRAY_TAG"),T=!(!i.ArrayBuffer||!g),O=T&&!!p&&"Opera"!==l(i.opera),P=!1,M={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},L=function(e){return s(e)&&a(M,l(e))};for(o in M)i[o]||(O=!1);if((!O||"function"!=typeof w||w===Function.prototype)&&(w=function(){throw TypeError("Incorrect invocation")},O))for(o in M)i[o]&&p(i[o],w);if((!O||!k||k===_)&&(k=w.prototype,O))for(o in M)i[o]&&p(i[o].prototype,k);if(O&&u(j)!==k&&p(j,k),r&&!a(k,C))for(o in P=!0,h(k,C,{get:function(){return s(this)?this[A]:void 0}}),M)i[o]&&c(i[o],A,o);T&&p&&u(y)!==_&&p(y,_),e.exports={NATIVE_ARRAY_BUFFER:T,NATIVE_ARRAY_BUFFER_VIEWS:O,TYPED_ARRAY_TAG:P&&A,aTypedArray:function(e){if(L(e))return e;throw TypeError("Target is not a typed array")},aTypedArrayConstructor:function(e){if(p){if(S.call(w,e))return e}else for(var n in M)if(a(M,o)){var t=i[n];if(t&&(e===t||S.call(t,e)))return e}throw TypeError("Target is not a typed array constructor")},exportProto:function(e,n,t){if(r){if(t)for(var o in M){var s=i[o];s&&a(s.prototype,e)&&delete s.prototype[e]}k[e]&&!t||d(k,e,t?n:O&&x[e]||n)}},exportStatic:function(e,n,t){var o,s;if(r){if(p){if(t)for(o in M)(s=i[o])&&a(s,e)&&delete s[e];if(w[e]&&!t)return;try{return d(w,e,t?n:O&&b[e]||n)}catch(e){}}for(o in M)!(s=i[o])||s[e]&&!t||d(s,e,n)}},isView:function(e){var n=l(e);return"DataView"===n||a(M,n)},isTypedArray:L,TypedArray:w,TypedArrayPrototype:k}},"./node_modules/core-js/internals/array-buffer.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER,s=t("./node_modules/core-js/internals/hide.js"),a=t("./node_modules/core-js/internals/redefine-all.js"),l=t("./node_modules/core-js/internals/fails.js"),c=t("./node_modules/core-js/internals/an-instance.js"),d=t("./node_modules/core-js/internals/to-integer.js"),h=t("./node_modules/core-js/internals/to-length.js"),u=t("./node_modules/core-js/internals/to-index.js"),p=t("./node_modules/core-js/internals/object-get-own-property-names.js").f,f=t("./node_modules/core-js/internals/object-define-property.js").f,m=t("./node_modules/core-js/internals/array-fill.js"),g=t("./node_modules/core-js/internals/set-to-string-tag.js"),y=t("./node_modules/core-js/internals/internal-state.js"),b=y.get,x=y.set,v=o.ArrayBuffer,j=v,w=o.DataView,k=o.Math,_=o.RangeError,S=k.abs,C=k.pow,A=k.floor,T=k.log,O=k.LN2,P=function(e,n,t){var o,r,i,s=new Array(t),a=8*t-n-1,l=(1<<a)-1,c=l>>1,d=23===n?C(2,-24)-C(2,-77):0,h=e<0||0===e&&1/e<0?1:0,u=0;for((e=S(e))!=e||e===1/0?(r=e!=e?1:0,o=l):(o=A(T(e)/O),e*(i=C(2,-o))<1&&(o--,i*=2),(e+=o+c>=1?d/i:d*C(2,1-c))*i>=2&&(o++,i/=2),o+c>=l?(r=0,o=l):o+c>=1?(r=(e*i-1)*C(2,n),o+=c):(r=e*C(2,c-1)*C(2,n),o=0));n>=8;s[u++]=255&r,r/=256,n-=8);for(o=o<<n|r,a+=n;a>0;s[u++]=255&o,o/=256,a-=8);return s[--u]|=128*h,s},M=function(e,n){var t,o=e.length,r=8*o-n-1,i=(1<<r)-1,s=i>>1,a=r-7,l=o-1,c=e[l--],d=127&c;for(c>>=7;a>0;d=256*d+e[l],l--,a-=8);for(t=d&(1<<-a)-1,d>>=-a,a+=n;a>0;t=256*t+e[l],l--,a-=8);if(0===d)d=1-s;else{if(d===i)return t?NaN:c?-1/0:1/0;t+=C(2,n),d-=s}return(c?-1:1)*t*C(2,d-n)},L=function(e){return e[3]<<24|e[2]<<16|e[1]<<8|e[0]},H=function(e){return[255&e]},I=function(e){return[255&e,e>>8&255]},D=function(e){return[255&e,e>>8&255,e>>16&255,e>>24&255]},E=function(e){return P(e,23,4)},B=function(e){return P(e,52,8)},R=function(e,n){f(e.prototype,n,{get:function(){return b(this)[n]}})},N=function(e,n,t,o){var r=u(+t),i=b(e);if(r+n>i.byteLength)throw _("Wrong index");var s=b(i.buffer).bytes,a=r+i.byteOffset,l=s.slice(a,a+n);return o?l:l.reverse()},z=function(e,n,t,o,r,i){var s=u(+t),a=b(e);if(s+n>a.byteLength)throw _("Wrong index");for(var l=b(a.buffer).bytes,c=s+a.byteOffset,d=o(+r),h=0;h<n;h++)l[c+h]=d[i?h:n-h-1]};if(i){if(!l(function(){v(1)})||!l(function(){new v(-1)})||l(function(){return new v,new v(1.5),new v(NaN),"ArrayBuffer"!=v.name})){for(var G,W=(j=function(e){return c(this,j),new v(u(e))}).prototype=v.prototype,F=p(v),X=0;F.length>X;)(G=F[X++])in j||s(j,G,v[G]);W.constructor=j}var V=new w(new j(2)),Y=w.prototype.setInt8;V.setInt8(0,2147483648),V.setInt8(1,2147483649),!V.getInt8(0)&&V.getInt8(1)||a(w.prototype,{setInt8:function(e,n){Y.call(this,e,n<<24>>24)},setUint8:function(e,n){Y.call(this,e,n<<24>>24)}},{unsafe:!0})}else j=function(e){c(this,j,"ArrayBuffer");var n=u(e);x(this,{bytes:m.call(new Array(n),0),byteLength:n}),r||(this.byteLength=n)},w=function(e,n,t){c(this,w,"DataView"),c(e,j,"DataView");var o=b(e).byteLength,i=d(n);if(i<0||i>o)throw _("Wrong offset");if(i+(t=void 0===t?o-i:h(t))>o)throw _("Wrong length");x(this,{buffer:e,byteLength:t,byteOffset:i}),r||(this.buffer=e,this.byteLength=t,this.byteOffset=i)},r&&(R(j,"byteLength"),R(w,"buffer"),R(w,"byteLength"),R(w,"byteOffset")),a(w.prototype,{getInt8:function(e){return N(this,1,e)[0]<<24>>24},getUint8:function(e){return N(this,1,e)[0]},getInt16:function(e){var n=N(this,2,e,arguments.length>1?arguments[1]:void 0);return(n[1]<<8|n[0])<<16>>16},getUint16:function(e){var n=N(this,2,e,arguments.length>1?arguments[1]:void 0);return n[1]<<8|n[0]},getInt32:function(e){return L(N(this,4,e,arguments.length>1?arguments[1]:void 0))},getUint32:function(e){return L(N(this,4,e,arguments.length>1?arguments[1]:void 0))>>>0},getFloat32:function(e){return M(N(this,4,e,arguments.length>1?arguments[1]:void 0),23)},getFloat64:function(e){return M(N(this,8,e,arguments.length>1?arguments[1]:void 0),52)},setInt8:function(e,n){z(this,1,e,H,n)},setUint8:function(e,n){z(this,1,e,H,n)},setInt16:function(e,n){z(this,2,e,I,n,arguments.length>2?arguments[2]:void 0)},setUint16:function(e,n){z(this,2,e,I,n,arguments.length>2?arguments[2]:void 0)},setInt32:function(e,n){z(this,4,e,D,n,arguments.length>2?arguments[2]:void 0)},setUint32:function(e,n){z(this,4,e,D,n,arguments.length>2?arguments[2]:void 0)},setFloat32:function(e,n){z(this,4,e,E,n,arguments.length>2?arguments[2]:void 0)},setFloat64:function(e,n){z(this,8,e,B,n,arguments.length>2?arguments[2]:void 0)}});g(j,"ArrayBuffer"),g(w,"DataView"),n.ArrayBuffer=j,n.DataView=w},"./node_modules/core-js/internals/array-copy-within.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-object.js"),r=t("./node_modules/core-js/internals/to-absolute-index.js"),i=t("./node_modules/core-js/internals/to-length.js"),s=Math.min;e.exports=[].copyWithin||function(e,n){var t=o(this),a=i(t.length),l=r(e,a),c=r(n,a),d=arguments.length>2?arguments[2]:void 0,h=s((void 0===d?a:r(d,a))-c,a-l),u=1;for(c<l&&l<c+h&&(u=-1,c+=h-1,l+=h-1);h-- >0;)c in t?t[l]=t[c]:delete t[l],l+=u,c+=u;return t}},"./node_modules/core-js/internals/array-fill.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-object.js"),r=t("./node_modules/core-js/internals/to-absolute-index.js"),i=t("./node_modules/core-js/internals/to-length.js");e.exports=function(e){for(var n=o(this),t=i(n.length),s=arguments.length,a=r(s>1?arguments[1]:void 0,t),l=s>2?arguments[2]:void 0,c=void 0===l?t:r(l,t);c>a;)n[a++]=e;return n}},"./node_modules/core-js/internals/array-for-each.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-iteration.js").forEach,r=t("./node_modules/core-js/internals/sloppy-array-method.js");e.exports=r("forEach")?function(e){return o(this,e,arguments.length>1?arguments[1]:void 0)}:[].forEach},"./node_modules/core-js/internals/array-from.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/bind-context.js"),r=t("./node_modules/core-js/internals/to-object.js"),i=t("./node_modules/core-js/internals/call-with-safe-iteration-closing.js"),s=t("./node_modules/core-js/internals/is-array-iterator-method.js"),a=t("./node_modules/core-js/internals/to-length.js"),l=t("./node_modules/core-js/internals/create-property.js"),c=t("./node_modules/core-js/internals/get-iterator-method.js");e.exports=function(e){var n,t,d,h,u=r(e),p="function"==typeof this?this:Array,f=arguments.length,m=f>1?arguments[1]:void 0,g=void 0!==m,y=0,b=c(u);if(g&&(m=o(m,f>2?arguments[2]:void 0,2)),null==b||p==Array&&s(b))for(t=new p(n=a(u.length));n>y;y++)l(t,y,g?m(u[y],y):u[y]);else for(h=b.call(u),t=new p;!(d=h.next()).done;y++)l(t,y,g?i(h,m,[d.value,y],!0):d.value);return t.length=y,t}},"./node_modules/core-js/internals/array-includes.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-indexed-object.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/to-absolute-index.js"),s=function(e){return function(n,t,s){var a,l=o(n),c=r(l.length),d=i(s,c);if(e&&t!=t){for(;c>d;)if((a=l[d++])!=a)return!0}else for(;c>d;d++)if((e||d in l)&&l[d]===t)return e||d||0;return!e&&-1}};e.exports={includes:s(!0),indexOf:s(!1)}},"./node_modules/core-js/internals/array-iteration.js":function(e,n,t){var o=t("./node_modules/core-js/internals/bind-context.js"),r=t("./node_modules/core-js/internals/indexed-object.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/array-species-create.js"),l=[].push,c=function(e){var n=1==e,t=2==e,c=3==e,d=4==e,h=6==e,u=5==e||h;return function(p,f,m,g){for(var y,b,x=i(p),v=r(x),j=o(f,m,3),w=s(v.length),k=0,_=g||a,S=n?_(p,w):t?_(p,0):void 0;w>k;k++)if((u||k in v)&&(b=j(y=v[k],k,x),e))if(n)S[k]=b;else if(b)switch(e){case 3:return!0;case 5:return y;case 6:return k;case 2:l.call(S,y)}else if(d)return!1;return h?-1:c||d?d:S}};e.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6)}},"./node_modules/core-js/internals/array-last-index-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-indexed-object.js"),r=t("./node_modules/core-js/internals/to-integer.js"),i=t("./node_modules/core-js/internals/to-length.js"),s=t("./node_modules/core-js/internals/sloppy-array-method.js"),a=Math.min,l=[].lastIndexOf,c=!!l&&1/[1].lastIndexOf(1,-0)<0,d=s("lastIndexOf");e.exports=c||d?function(e){if(c)return l.apply(this,arguments)||0;var n=o(this),t=i(n.length),s=t-1;for(arguments.length>1&&(s=a(s,r(arguments[1]))),s<0&&(s=t+s);s>=0;s--)if(s in n&&n[s]===e)return s||0;return-1}:l},"./node_modules/core-js/internals/array-method-has-species-support.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js"),r=t("./node_modules/core-js/internals/well-known-symbol.js")("species");e.exports=function(e){return!o(function(){var n=[];return(n.constructor={})[r]=function(){return{foo:1}},1!==n[e](Boolean).foo})}},"./node_modules/core-js/internals/array-reduce.js":function(e,n,t){var o=t("./node_modules/core-js/internals/a-function.js"),r=t("./node_modules/core-js/internals/to-object.js"),i=t("./node_modules/core-js/internals/indexed-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=function(e){return function(n,t,a,l){o(t);var c=r(n),d=i(c),h=s(c.length),u=e?h-1:0,p=e?-1:1;if(a<2)for(;;){if(u in d){l=d[u],u+=p;break}if(u+=p,e?u<0:h<=u)throw TypeError("Reduce of empty array with no initial value")}for(;e?u>=0:h>u;u+=p)u in d&&(l=t(l,d[u],u,c));return l}};e.exports={left:a(!1),right:a(!0)}},"./node_modules/core-js/internals/array-species-create.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js"),r=t("./node_modules/core-js/internals/is-array.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("species");e.exports=function(e,n){var t;return r(e)&&("function"!=typeof(t=e.constructor)||t!==Array&&!r(t.prototype)?o(t)&&null===(t=t[i])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===n?0:n)}},"./node_modules/core-js/internals/bind-context.js":function(e,n,t){var o=t("./node_modules/core-js/internals/a-function.js");e.exports=function(e,n,t){if(o(e),void 0===n)return e;switch(t){case 0:return function(){return e.call(n)};case 1:return function(t){return e.call(n,t)};case 2:return function(t,o){return e.call(n,t,o)};case 3:return function(t,o,r){return e.call(n,t,o,r)}}return function(){return e.apply(n,arguments)}}},"./node_modules/core-js/internals/call-with-safe-iteration-closing.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js");e.exports=function(e,n,t,r){try{return r?n(o(t)[0],t[1]):n(t)}catch(n){var i=e.return;throw void 0!==i&&o(i.call(e)),n}}},"./node_modules/core-js/internals/check-correctness-of-iteration.js":function(e,n,t){var o=t("./node_modules/core-js/internals/well-known-symbol.js")("iterator"),r=!1;try{var i=0,s={next:function(){return{done:!!i++}},return:function(){r=!0}};s[o]=function(){return this},Array.from(s,function(){throw 2})}catch(e){}e.exports=function(e,n){if(!n&&!r)return!1;var t=!1;try{var i={};i[o]=function(){return{next:function(){return{done:t=!0}}}},e(i)}catch(e){}return t}},"./node_modules/core-js/internals/classof-raw.js":function(e,n){var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},"./node_modules/core-js/internals/classof.js":function(e,n,t){var o=t("./node_modules/core-js/internals/classof-raw.js"),r=t("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag"),i="Arguments"==o(function(){return arguments}());e.exports=function(e){var n,t,s;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(t=function(e,n){try{return e[n]}catch(e){}}(n=Object(e),r))?t:i?o(n):"Object"==(s=o(n))&&"function"==typeof n.callee?"Arguments":s}},"./node_modules/core-js/internals/collection-add-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/a-function.js");e.exports=function(){for(var e=o(this),n=r(e.add),t=0,i=arguments.length;t<i;t++)n.call(e,arguments[t]);return e}},"./node_modules/core-js/internals/collection-delete-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/a-function.js");e.exports=function(){for(var e,n=o(this),t=r(n.delete),i=!0,s=0,a=arguments.length;s<a;s++)e=t.call(n,arguments[s]),i=i&&e;return!!i}},"./node_modules/core-js/internals/collection-from.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/a-function.js"),r=t("./node_modules/core-js/internals/bind-context.js"),i=t("./node_modules/core-js/internals/iterate.js");e.exports=function(e){var n,t,s,a,l=arguments.length,c=l>1?arguments[1]:void 0;return o(this),(n=void 0!==c)&&o(c),null==e?new this:(t=[],n?(s=0,a=r(c,l>2?arguments[2]:void 0,2),i(e,function(e){t.push(a(e,s++))})):i(e,t.push,t),new this(t))}},"./node_modules/core-js/internals/collection-of.js":function(e,n,t){"use strict";e.exports=function(){for(var e=arguments.length,n=new Array(e);e--;)n[e]=arguments[e];return new this(n)}},"./node_modules/core-js/internals/collection-strong.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/object-define-property.js").f,r=t("./node_modules/core-js/internals/object-create.js"),i=t("./node_modules/core-js/internals/redefine-all.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/an-instance.js"),l=t("./node_modules/core-js/internals/iterate.js"),c=t("./node_modules/core-js/internals/define-iterator.js"),d=t("./node_modules/core-js/internals/set-species.js"),h=t("./node_modules/core-js/internals/descriptors.js"),u=t("./node_modules/core-js/internals/internal-metadata.js").fastKey,p=t("./node_modules/core-js/internals/internal-state.js"),f=p.set,m=p.getterFor;e.exports={getConstructor:function(e,n,t,c){var d=e(function(e,o){a(e,d,n),f(e,{type:n,index:r(null),first:void 0,last:void 0,size:0}),h||(e.size=0),null!=o&&l(o,e[c],e,t)}),p=m(n),g=function(e,n,t){var o,r,i=p(e),s=y(e,n);return s?s.value=t:(i.last=s={index:r=u(n,!0),key:n,value:t,previous:o=i.last,next:void 0,removed:!1},i.first||(i.first=s),o&&(o.next=s),h?i.size++:e.size++,"F"!==r&&(i.index[r]=s)),e},y=function(e,n){var t,o=p(e),r=u(n);if("F"!==r)return o.index[r];for(t=o.first;t;t=t.next)if(t.key==n)return t};return i(d.prototype,{clear:function(){for(var e=p(this),n=e.index,t=e.first;t;)t.removed=!0,t.previous&&(t.previous=t.previous.next=void 0),delete n[t.index],t=t.next;e.first=e.last=void 0,h?e.size=0:this.size=0},delete:function(e){var n=p(this),t=y(this,e);if(t){var o=t.next,r=t.previous;delete n.index[t.index],t.removed=!0,r&&(r.next=o),o&&(o.previous=r),n.first==t&&(n.first=o),n.last==t&&(n.last=r),h?n.size--:this.size--}return!!t},forEach:function(e){for(var n,t=p(this),o=s(e,arguments.length>1?arguments[1]:void 0,3);n=n?n.next:t.first;)for(o(n.value,n.key,this);n&&n.removed;)n=n.previous},has:function(e){return!!y(this,e)}}),i(d.prototype,t?{get:function(e){var n=y(this,e);return n&&n.value},set:function(e,n){return g(this,0===e?0:e,n)}}:{add:function(e){return g(this,e=0===e?0:e,e)}}),h&&o(d.prototype,"size",{get:function(){return p(this).size}}),d},setStrong:function(e,n,t){var o=n+" Iterator",r=m(n),i=m(o);c(e,n,function(e,n){f(this,{type:o,target:e,state:r(e),kind:n,last:void 0})},function(){for(var e=i(this),n=e.kind,t=e.last;t&&t.removed;)t=t.previous;return e.target&&(e.last=t=t?t.next:e.state.first)?"keys"==n?{value:t.key,done:!1}:"values"==n?{value:t.value,done:!1}:{value:[t.key,t.value],done:!1}:(e.target=void 0,{value:void 0,done:!0})},t?"entries":"values",!t,!0),d(n)}}},"./node_modules/core-js/internals/collection-weak.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/redefine-all.js"),r=t("./node_modules/core-js/internals/internal-metadata.js").getWeakData,i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/is-object.js"),a=t("./node_modules/core-js/internals/an-instance.js"),l=t("./node_modules/core-js/internals/iterate.js"),c=t("./node_modules/core-js/internals/array-iteration.js"),d=t("./node_modules/core-js/internals/has.js"),h=t("./node_modules/core-js/internals/internal-state.js"),u=h.set,p=h.getterFor,f=c.find,m=c.findIndex,g=0,y=function(e){return e.frozen||(e.frozen=new b)},b=function(){this.entries=[]},x=function(e,n){return f(e.entries,function(e){return e[0]===n})};b.prototype={get:function(e){var n=x(this,e);if(n)return n[1]},has:function(e){return!!x(this,e)},set:function(e,n){var t=x(this,e);t?t[1]=n:this.entries.push([e,n])},delete:function(e){var n=m(this.entries,function(n){return n[0]===e});return~n&&this.entries.splice(n,1),!!~n}},e.exports={getConstructor:function(e,n,t,c){var h=e(function(e,o){a(e,h,n),u(e,{type:n,id:g++,frozen:void 0}),null!=o&&l(o,e[c],e,t)}),f=p(n),m=function(e,n,t){var o=f(e),s=r(i(n),!0);return!0===s?y(o).set(n,t):s[o.id]=t,e};return o(h.prototype,{delete:function(e){var n=f(this);if(!s(e))return!1;var t=r(e);return!0===t?y(n).delete(e):t&&d(t,n.id)&&delete t[n.id]},has:function(e){var n=f(this);if(!s(e))return!1;var t=r(e);return!0===t?y(n).has(e):t&&d(t,n.id)}}),o(h.prototype,t?{get:function(e){var n=f(this);if(s(e)){var t=r(e);return!0===t?y(n).get(e):t?t[n.id]:void 0}},set:function(e,n){return m(this,e,n)}}:{add:function(e){return m(this,e,!0)}}),h}}},"./node_modules/core-js/internals/collection.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/is-forced.js"),s=t("./node_modules/core-js/internals/redefine.js"),a=t("./node_modules/core-js/internals/internal-metadata.js"),l=t("./node_modules/core-js/internals/iterate.js"),c=t("./node_modules/core-js/internals/an-instance.js"),d=t("./node_modules/core-js/internals/is-object.js"),h=t("./node_modules/core-js/internals/fails.js"),u=t("./node_modules/core-js/internals/check-correctness-of-iteration.js"),p=t("./node_modules/core-js/internals/set-to-string-tag.js"),f=t("./node_modules/core-js/internals/inherit-if-required.js");e.exports=function(e,n,t,m,g){var y=r[e],b=y&&y.prototype,x=y,v=m?"set":"add",j={},w=function(e){var n=b[e];s(b,e,"add"==e?function(e){return n.call(this,0===e?0:e),this}:"delete"==e?function(e){return!(g&&!d(e))&&n.call(this,0===e?0:e)}:"get"==e?function(e){return g&&!d(e)?void 0:n.call(this,0===e?0:e)}:"has"==e?function(e){return!(g&&!d(e))&&n.call(this,0===e?0:e)}:function(e,t){return n.call(this,0===e?0:e,t),this})};if(i(e,"function"!=typeof y||!(g||b.forEach&&!h(function(){(new y).entries().next()}))))x=t.getConstructor(n,e,m,v),a.REQUIRED=!0;else if(i(e,!0)){var k=new x,_=k[v](g?{}:-0,1)!=k,S=h(function(){k.has(1)}),C=u(function(e){new y(e)}),A=!g&&h(function(){for(var e=new y,n=5;n--;)e[v](n,n);return!e.has(-0)});C||((x=n(function(n,t){c(n,x,e);var o=f(new y,n,x);return null!=t&&l(t,o[v],o,m),o})).prototype=b,b.constructor=x),(S||A)&&(w("delete"),w("has"),m&&w("get")),(A||_)&&w(v),g&&b.clear&&delete b.clear}return j[e]=x,o({global:!0,forced:x!=y},j),p(x,e),g||t.setStrong(x,e,m),x}},"./node_modules/core-js/internals/composite-key.js":function(e,n,t){var o=t("./node_modules/core-js/modules/es.map.js"),r=t("./node_modules/core-js/modules/es.weak-map.js"),i=t("./node_modules/core-js/internals/object-create.js"),s=t("./node_modules/core-js/internals/is-object.js"),a=function(){this.object=null,this.symbol=null,this.primitives=null,this.objectsByIndex=i(null)};a.prototype.get=function(e,n){return this[e]||(this[e]=n())},a.prototype.next=function(e,n,t){var i=t?this.objectsByIndex[e]||(this.objectsByIndex[e]=new r):this.primitives||(this.primitives=new o),s=i.get(n);return s||i.set(n,s=new a),s};var l=new a;e.exports=function(){var e,n,t=l,o=arguments.length;for(e=0;e<o;e++)s(n=arguments[e])&&(t=t.next(e,n,!0));if(this===Object&&t===l)throw TypeError("Composite keys must contain a non-primitive component");for(e=0;e<o;e++)s(n=arguments[e])||(t=t.next(e,n,!1));return t}},"./node_modules/core-js/internals/copy-constructor-properties.js":function(e,n,t){var o=t("./node_modules/core-js/internals/has.js"),r=t("./node_modules/core-js/internals/own-keys.js"),i=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),s=t("./node_modules/core-js/internals/object-define-property.js");e.exports=function(e,n){for(var t=r(n),a=s.f,l=i.f,c=0;c<t.length;c++){var d=t[c];o(e,d)||a(e,d,l(n,d))}}},"./node_modules/core-js/internals/correct-is-regexp-logic.js":function(e,n,t){var o=t("./node_modules/core-js/internals/well-known-symbol.js")("match");e.exports=function(e){var n=/./;try{"/./"[e](n)}catch(t){try{return n[o]=!1,"/./"[e](n)}catch(e){}}return!1}},"./node_modules/core-js/internals/correct-prototype-getter.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js");e.exports=!o(function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})},"./node_modules/core-js/internals/create-html.js":function(e,n,t){var o=t("./node_modules/core-js/internals/require-object-coercible.js"),r=/"/g;e.exports=function(e,n,t,i){var s=String(o(e)),a="<"+n;return""!==t&&(a+=" "+t+'="'+String(i).replace(r,"&quot;")+'"'),a+">"+s+"</"+n+">"}},"./node_modules/core-js/internals/create-iterator-constructor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype,r=t("./node_modules/core-js/internals/object-create.js"),i=t("./node_modules/core-js/internals/create-property-descriptor.js"),s=t("./node_modules/core-js/internals/set-to-string-tag.js"),a=t("./node_modules/core-js/internals/iterators.js"),l=function(){return this};e.exports=function(e,n,t){var c=n+" Iterator";return e.prototype=r(o,{next:i(1,t)}),s(e,c,!1,!0),a[c]=l,e}},"./node_modules/core-js/internals/create-property-descriptor.js":function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},"./node_modules/core-js/internals/create-property.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-primitive.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/create-property-descriptor.js");e.exports=function(e,n,t){var s=o(n);s in e?r.f(e,s,i(0,t)):e[s]=t}},"./node_modules/core-js/internals/date-to-iso-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fails.js"),r=t("./node_modules/core-js/internals/string-pad.js").start,i=Math.abs,s=Date.prototype,a=s.getTime,l=s.toISOString;e.exports=o(function(){return"0385-07-25T07:06:39.999Z"!=l.call(new Date(-5e13-1))})||!o(function(){l.call(new Date(NaN))})?function(){if(!isFinite(a.call(this)))throw RangeError("Invalid time value");var e=this.getUTCFullYear(),n=this.getUTCMilliseconds(),t=e<0?"-":e>9999?"+":"";return t+r(i(e),t?6:4,0)+"-"+r(this.getUTCMonth()+1,2,0)+"-"+r(this.getUTCDate(),2,0)+"T"+r(this.getUTCHours(),2,0)+":"+r(this.getUTCMinutes(),2,0)+":"+r(this.getUTCSeconds(),2,0)+"."+r(n,3,0)+"Z"}:l},"./node_modules/core-js/internals/date-to-primitive.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/to-primitive.js");e.exports=function(e){if("string"!==e&&"number"!==e&&"default"!==e)throw TypeError("Incorrect hint");return r(o(this),"number"!==e)}},"./node_modules/core-js/internals/define-iterator.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-iterator-constructor.js"),i=t("./node_modules/core-js/internals/object-get-prototype-of.js"),s=t("./node_modules/core-js/internals/object-set-prototype-of.js"),a=t("./node_modules/core-js/internals/set-to-string-tag.js"),l=t("./node_modules/core-js/internals/hide.js"),c=t("./node_modules/core-js/internals/redefine.js"),d=t("./node_modules/core-js/internals/well-known-symbol.js"),h=t("./node_modules/core-js/internals/is-pure.js"),u=t("./node_modules/core-js/internals/iterators.js"),p=t("./node_modules/core-js/internals/iterators-core.js"),f=p.IteratorPrototype,m=p.BUGGY_SAFARI_ITERATORS,g=d("iterator"),y=function(){return this};e.exports=function(e,n,t,d,p,b,x){r(t,n,d);var v,j,w,k=function(e){if(e===p&&T)return T;if(!m&&e in C)return C[e];switch(e){case"keys":case"values":case"entries":return function(){return new t(this,e)}}return function(){return new t(this)}},_=n+" Iterator",S=!1,C=e.prototype,A=C[g]||C["@@iterator"]||p&&C[p],T=!m&&A||k(p),O="Array"==n&&C.entries||A;if(O&&(v=i(O.call(new e)),f!==Object.prototype&&v.next&&(h||i(v)===f||(s?s(v,f):"function"!=typeof v[g]&&l(v,g,y)),a(v,_,!0,!0),h&&(u[_]=y))),"values"==p&&A&&"values"!==A.name&&(S=!0,T=function(){return A.call(this)}),h&&!x||C[g]===T||l(C,g,T),u[n]=T,p)if(j={values:k("values"),keys:b?T:k("keys"),entries:k("entries")},x)for(w in j)!m&&!S&&w in C||c(C,w,j[w]);else o({target:n,proto:!0,forced:m||S},j);return j}},"./node_modules/core-js/internals/define-well-known-symbol.js":function(e,n,t){var o=t("./node_modules/core-js/internals/path.js"),r=t("./node_modules/core-js/internals/has.js"),i=t("./node_modules/core-js/internals/wrapped-well-known-symbol.js"),s=t("./node_modules/core-js/internals/object-define-property.js").f;e.exports=function(e){var n=o.Symbol||(o.Symbol={});r(n,e)||s(n,e,{value:i.f(e)})}},"./node_modules/core-js/internals/descriptors.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js");e.exports=!o(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},"./node_modules/core-js/internals/document-create-element.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=o.document,s=r(i)&&r(i.createElement);e.exports=function(e){return s?i.createElement(e):{}}},"./node_modules/core-js/internals/dom-iterables.js":function(e,n){e.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},"./node_modules/core-js/internals/enum-bug-keys.js":function(e,n){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},"./node_modules/core-js/internals/export.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f,i=t("./node_modules/core-js/internals/hide.js"),s=t("./node_modules/core-js/internals/redefine.js"),a=t("./node_modules/core-js/internals/set-global.js"),l=t("./node_modules/core-js/internals/copy-constructor-properties.js"),c=t("./node_modules/core-js/internals/is-forced.js");e.exports=function(e,n){var t,d,h,u,p,f=e.target,m=e.global,g=e.stat;if(t=m?o:g?o[f]||a(f,{}):(o[f]||{}).prototype)for(d in n){if(u=n[d],h=e.noTargetGet?(p=r(t,d))&&p.value:t[d],!c(m?d:f+(g?".":"#")+d,e.forced)&&void 0!==h){if(typeof u==typeof h)continue;l(u,h)}(e.sham||h&&h.sham)&&i(u,"sham",!0),s(t,d,u,e)}}},"./node_modules/core-js/internals/fails.js":function(e,n){e.exports=function(e){try{return!!e()}catch(e){return!0}}},"./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/hide.js"),r=t("./node_modules/core-js/internals/redefine.js"),i=t("./node_modules/core-js/internals/fails.js"),s=t("./node_modules/core-js/internals/well-known-symbol.js"),a=t("./node_modules/core-js/internals/regexp-exec.js"),l=s("species"),c=!i(function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}),d=!i(function(){var e=/(?:)/,n=e.exec;e.exec=function(){return n.apply(this,arguments)};var t="ab".split(e);return 2!==t.length||"a"!==t[0]||"b"!==t[1]});e.exports=function(e,n,t,h){var u=s(e),p=!i(function(){var n={};return n[u]=function(){return 7},7!=""[e](n)}),f=p&&!i(function(){var n=!1,t=/a/;return t.exec=function(){return n=!0,null},"split"===e&&(t.constructor={},t.constructor[l]=function(){return t}),t[u](""),!n});if(!p||!f||"replace"===e&&!c||"split"===e&&!d){var m=/./[u],g=t(u,""[e],function(e,n,t,o,r){return n.exec===a?p&&!r?{done:!0,value:m.call(n,t,o)}:{done:!0,value:e.call(t,n,o)}:{done:!1}}),y=g[0],b=g[1];r(String.prototype,e,y),r(RegExp.prototype,u,2==n?function(e,n){return b.call(e,this,n)}:function(e){return b.call(e,this)}),h&&o(RegExp.prototype[u],"sham",!0)}}},"./node_modules/core-js/internals/flatten-into-array.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/is-array.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/bind-context.js"),s=function(e,n,t,a,l,c,d,h){for(var u,p=l,f=0,m=!!d&&i(d,h,3);f<a;){if(f in t){if(u=m?m(t[f],f,n):t[f],c>0&&o(u))p=s(e,n,u,r(u.length),p,c-1)-1;else{if(p>=9007199254740991)throw TypeError("Exceed the acceptable array length");e[p]=u}p++}f++}return p};e.exports=s},"./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/is-pure.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/fails.js");e.exports=o||!i(function(){var e=Math.random();__defineSetter__.call(null,e,function(){}),delete r[e]})},"./node_modules/core-js/internals/forced-string-html-method.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js");e.exports=function(e){return o(function(){var n=""[e]('"');return n!==n.toLowerCase()||n.split('"').length>3})}},"./node_modules/core-js/internals/forced-string-trim-method.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js"),r=t("./node_modules/core-js/internals/whitespaces.js");e.exports=function(e){return o(function(){return!!r[e]()||"​᠎"!="​᠎"[e]()||r[e].name!==e})}},"./node_modules/core-js/internals/freezing.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js");e.exports=!o(function(){return Object.isExtensible(Object.preventExtensions({}))})},"./node_modules/core-js/internals/function-bind.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/a-function.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=[].slice,s={};e.exports=Function.bind||function(e){var n=o(this),t=i.call(arguments,1),a=function(){var o=t.concat(i.call(arguments));return this instanceof a?function(e,n,t){if(!(n in s)){for(var o=[],r=0;r<n;r++)o[r]="a["+r+"]";s[n]=Function("C,a","return new C("+o.join(",")+")")}return s[n](e,t)}(n,o.length,o):n.apply(e,o)};return r(n.prototype)&&(a.prototype=n.prototype),a}},"./node_modules/core-js/internals/function-to-string.js":function(e,n,t){var o=t("./node_modules/core-js/internals/shared.js");e.exports=o("native-function-to-string",Function.toString)},"./node_modules/core-js/internals/get-built-in.js":function(e,n,t){var o=t("./node_modules/core-js/internals/path.js"),r=t("./node_modules/core-js/internals/global.js"),i=function(e){return"function"==typeof e?e:void 0};e.exports=function(e,n){return arguments.length<2?i(o[e])||i(r[e]):o[e]&&o[e][n]||r[e]&&r[e][n]}},"./node_modules/core-js/internals/get-iterator-method.js":function(e,n,t){var o=t("./node_modules/core-js/internals/classof.js"),r=t("./node_modules/core-js/internals/iterators.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("iterator");e.exports=function(e){if(null!=e)return e[i]||e["@@iterator"]||r[o(e)]}},"./node_modules/core-js/internals/get-iterator.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/get-iterator-method.js");e.exports=function(e){var n=r(e);if("function"!=typeof n)throw TypeError(String(e)+" is not iterable");return o(n.call(e))}},"./node_modules/core-js/internals/get-map-iterator.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-pure.js"),r=t("./node_modules/core-js/internals/get-iterator.js");e.exports=o?r:function(e){return Map.prototype.entries.call(e)}},"./node_modules/core-js/internals/get-set-iterator.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-pure.js"),r=t("./node_modules/core-js/internals/get-iterator.js");e.exports=o?r:function(e){return Set.prototype.values.call(e)}},"./node_modules/core-js/internals/global.js":function(e,n,t){(function(n){var t="object",o=function(e){return e&&e.Math==Math&&e};e.exports=o(typeof globalThis==t&&globalThis)||o(typeof window==t&&window)||o(typeof self==t&&self)||o(typeof n==t&&n)||Function("return this")()}).call(this,t("./node_modules/webpack/buildin/global.js"))},"./node_modules/core-js/internals/has.js":function(e,n){var t={}.hasOwnProperty;e.exports=function(e,n){return t.call(e,n)}},"./node_modules/core-js/internals/hidden-keys.js":function(e,n){e.exports={}},"./node_modules/core-js/internals/hide.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/create-property-descriptor.js");e.exports=o?function(e,n,t){return r.f(e,n,i(1,t))}:function(e,n,t){return e[n]=t,e}},"./node_modules/core-js/internals/host-report-errors.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js");e.exports=function(e,n){var t=o.console;t&&t.error&&(1===arguments.length?t.error(e):t.error(e,n))}},"./node_modules/core-js/internals/html.js":function(e,n,t){var o=t("./node_modules/core-js/internals/get-built-in.js");e.exports=o("document","documentElement")},"./node_modules/core-js/internals/ie8-dom-define.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/document-create-element.js");e.exports=!o&&!r(function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a})},"./node_modules/core-js/internals/indexed-object.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js"),r=t("./node_modules/core-js/internals/classof-raw.js"),i="".split;e.exports=o(function(){return!Object("z").propertyIsEnumerable(0)})?function(e){return"String"==r(e)?i.call(e,""):Object(e)}:Object},"./node_modules/core-js/internals/inherit-if-required.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js"),r=t("./node_modules/core-js/internals/object-set-prototype-of.js");e.exports=function(e,n,t){var i,s;return r&&"function"==typeof(i=n.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&r(e,s),e}},"./node_modules/core-js/internals/internal-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/hidden-keys.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/has.js"),s=t("./node_modules/core-js/internals/object-define-property.js").f,a=t("./node_modules/core-js/internals/uid.js"),l=t("./node_modules/core-js/internals/freezing.js"),c=a("meta"),d=0,h=Object.isExtensible||function(){return!0},u=function(e){s(e,c,{value:{objectID:"O"+ ++d,weakData:{}}})},p=e.exports={REQUIRED:!1,fastKey:function(e,n){if(!r(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!i(e,c)){if(!h(e))return"F";if(!n)return"E";u(e)}return e[c].objectID},getWeakData:function(e,n){if(!i(e,c)){if(!h(e))return!0;if(!n)return!1;u(e)}return e[c].weakData},onFreeze:function(e){return l&&p.REQUIRED&&h(e)&&!i(e,c)&&u(e),e}};o[c]=!0},"./node_modules/core-js/internals/internal-state.js":function(e,n,t){var o,r,i,s=t("./node_modules/core-js/internals/native-weak-map.js"),a=t("./node_modules/core-js/internals/global.js"),l=t("./node_modules/core-js/internals/is-object.js"),c=t("./node_modules/core-js/internals/hide.js"),d=t("./node_modules/core-js/internals/has.js"),h=t("./node_modules/core-js/internals/shared-key.js"),u=t("./node_modules/core-js/internals/hidden-keys.js"),p=a.WeakMap;if(s){var f=new p,m=f.get,g=f.has,y=f.set;o=function(e,n){return y.call(f,e,n),n},r=function(e){return m.call(f,e)||{}},i=function(e){return g.call(f,e)}}else{var b=h("state");u[b]=!0,o=function(e,n){return c(e,b,n),n},r=function(e){return d(e,b)?e[b]:{}},i=function(e){return d(e,b)}}e.exports={set:o,get:r,has:i,enforce:function(e){return i(e)?r(e):o(e,{})},getterFor:function(e){return function(n){var t;if(!l(n)||(t=r(n)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return t}}}},"./node_modules/core-js/internals/is-array-iterator-method.js":function(e,n,t){var o=t("./node_modules/core-js/internals/well-known-symbol.js"),r=t("./node_modules/core-js/internals/iterators.js"),i=o("iterator"),s=Array.prototype;e.exports=function(e){return void 0!==e&&(r.Array===e||s[i]===e)}},"./node_modules/core-js/internals/is-array.js":function(e,n,t){var o=t("./node_modules/core-js/internals/classof-raw.js");e.exports=Array.isArray||function(e){return"Array"==o(e)}},"./node_modules/core-js/internals/is-forced.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js"),r=/#|\.prototype\./,i=function(e,n){var t=a[s(e)];return t==c||t!=l&&("function"==typeof n?o(n):!!n)},s=i.normalize=function(e){return String(e).replace(r,".").toLowerCase()},a=i.data={},l=i.NATIVE="N",c=i.POLYFILL="P";e.exports=i},"./node_modules/core-js/internals/is-integer.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js"),r=Math.floor;e.exports=function(e){return!o(e)&&isFinite(e)&&r(e)===e}},"./node_modules/core-js/internals/is-object.js":function(e,n){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},"./node_modules/core-js/internals/is-pure.js":function(e,n){e.exports=!1},"./node_modules/core-js/internals/is-regexp.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js"),r=t("./node_modules/core-js/internals/classof-raw.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("match");e.exports=function(e){var n;return o(e)&&(void 0!==(n=e[i])?!!n:"RegExp"==r(e))}},"./node_modules/core-js/internals/iterate.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/is-array-iterator-method.js"),i=t("./node_modules/core-js/internals/to-length.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-iterator-method.js"),l=t("./node_modules/core-js/internals/call-with-safe-iteration-closing.js"),c=function(e,n){this.stopped=e,this.result=n};(e.exports=function(e,n,t,d,h){var u,p,f,m,g,y,b=s(n,t,d?2:1);if(h)u=e;else{if("function"!=typeof(p=a(e)))throw TypeError("Target is not iterable");if(r(p)){for(f=0,m=i(e.length);m>f;f++)if((g=d?b(o(y=e[f])[0],y[1]):b(e[f]))&&g instanceof c)return g;return new c(!1)}u=p.call(e)}for(;!(y=u.next()).done;)if((g=l(u,b,y.value,d))&&g instanceof c)return g;return new c(!1)}).stop=function(e){return new c(!0,e)}},"./node_modules/core-js/internals/iterators-core.js":function(e,n,t){"use strict";var o,r,i,s=t("./node_modules/core-js/internals/object-get-prototype-of.js"),a=t("./node_modules/core-js/internals/hide.js"),l=t("./node_modules/core-js/internals/has.js"),c=t("./node_modules/core-js/internals/well-known-symbol.js"),d=t("./node_modules/core-js/internals/is-pure.js"),h=c("iterator"),u=!1;[].keys&&("next"in(i=[].keys())?(r=s(s(i)))!==Object.prototype&&(o=r):u=!0),null==o&&(o={}),d||l(o,h)||a(o,h,function(){return this}),e.exports={IteratorPrototype:o,BUGGY_SAFARI_ITERATORS:u}},"./node_modules/core-js/internals/iterators.js":function(e,n){e.exports={}},"./node_modules/core-js/internals/math-expm1.js":function(e,n){var t=Math.expm1,o=Math.exp;e.exports=!t||t(10)>22025.465794806718||t(10)<22025.465794806718||-2e-17!=t(-2e-17)?function(e){return 0==(e=+e)?e:e>-1e-6&&e<1e-6?e+e*e/2:o(e)-1}:t},"./node_modules/core-js/internals/math-fround.js":function(e,n,t){var o=t("./node_modules/core-js/internals/math-sign.js"),r=Math.abs,i=Math.pow,s=i(2,-52),a=i(2,-23),l=i(2,127)*(2-a),c=i(2,-126);e.exports=Math.fround||function(e){var n,t,i=r(e),d=o(e);return i<c?d*(i/c/a+1/s-1/s)*c*a:(t=(n=(1+a/s)*i)-(n-i))>l||t!=t?d*(1/0):d*t}},"./node_modules/core-js/internals/math-log1p.js":function(e,n){var t=Math.log;e.exports=Math.log1p||function(e){return(e=+e)>-1e-8&&e<1e-8?e-e*e/2:t(1+e)}},"./node_modules/core-js/internals/math-scale.js":function(e,n){e.exports=Math.scale||function(e,n,t,o,r){return 0===arguments.length||e!=e||n!=n||t!=t||o!=o||r!=r?NaN:e===1/0||e===-1/0?e:(e-n)*(r-o)/(t-n)+o}},"./node_modules/core-js/internals/math-sign.js":function(e,n){e.exports=Math.sign||function(e){return 0==(e=+e)||e!=e?e:e<0?-1:1}},"./node_modules/core-js/internals/microtask.js":function(e,n,t){var o,r,i,s,a,l,c,d,h=t("./node_modules/core-js/internals/global.js"),u=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f,p=t("./node_modules/core-js/internals/classof-raw.js"),f=t("./node_modules/core-js/internals/task.js").set,m=t("./node_modules/core-js/internals/user-agent.js"),g=h.MutationObserver||h.WebKitMutationObserver,y=h.process,b=h.Promise,x="process"==p(y),v=u(h,"queueMicrotask"),j=v&&v.value;j||(o=function(){var e,n;for(x&&(e=y.domain)&&e.exit();r;){n=r.fn,r=r.next;try{n()}catch(e){throw r?s():i=void 0,e}}i=void 0,e&&e.enter()},x?s=function(){y.nextTick(o)}:g&&!/(iphone|ipod|ipad).*applewebkit/i.test(m)?(a=!0,l=document.createTextNode(""),new g(o).observe(l,{characterData:!0}),s=function(){l.data=a=!a}):b&&b.resolve?(c=b.resolve(void 0),d=c.then,s=function(){d.call(c,o)}):s=function(){f.call(h,o)}),e.exports=j||function(e){var n={fn:e,next:void 0};i&&(i.next=n),r||(r=n,s()),i=n}},"./node_modules/core-js/internals/native-promise-constructor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js");e.exports=o.Promise},"./node_modules/core-js/internals/native-symbol.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js");e.exports=!!Object.getOwnPropertySymbols&&!o(function(){return!String(Symbol())})},"./node_modules/core-js/internals/native-url.js":function(e,n,t){var o=t("./node_modules/core-js/internals/fails.js"),r=t("./node_modules/core-js/internals/well-known-symbol.js"),i=t("./node_modules/core-js/internals/is-pure.js"),s=r("iterator");e.exports=!o(function(){var e=new URL("b?e=1","http://a"),n=e.searchParams;return e.pathname="c%20d",i&&!e.toJSON||!n.sort||"http://a/c%20d?e=1"!==e.href||"1"!==n.get("e")||"a=1"!==String(new URLSearchParams("?a=1"))||!n[s]||"a"!==new URL("https://a@b").username||"b"!==new URLSearchParams(new URLSearchParams("a=b")).get("a")||"xn--e1aybc"!==new URL("http://тест").host||"#%D0%B1"!==new URL("http://a#б").hash})},"./node_modules/core-js/internals/native-weak-map.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/function-to-string.js"),i=o.WeakMap;e.exports="function"==typeof i&&/native code/.test(r.call(i))},"./node_modules/core-js/internals/new-promise-capability.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/a-function.js"),r=function(e){var n,t;this.promise=new e(function(e,o){if(void 0!==n||void 0!==t)throw TypeError("Bad Promise constructor");n=e,t=o}),this.resolve=o(n),this.reject=o(t)};e.exports.f=function(e){return new r(e)}},"./node_modules/core-js/internals/not-a-regexp.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-regexp.js");e.exports=function(e){if(o(e))throw TypeError("The method doesn't accept regular expressions");return e}},"./node_modules/core-js/internals/number-is-finite.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js").isFinite;e.exports=Number.isFinite||function(e){return"number"==typeof e&&o(e)}},"./node_modules/core-js/internals/object-assign.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/object-keys.js"),s=t("./node_modules/core-js/internals/object-get-own-property-symbols.js"),a=t("./node_modules/core-js/internals/object-property-is-enumerable.js"),l=t("./node_modules/core-js/internals/to-object.js"),c=t("./node_modules/core-js/internals/indexed-object.js"),d=Object.assign;e.exports=!d||r(function(){var e={},n={},t=Symbol();return e[t]=7,"abcdefghijklmnopqrst".split("").forEach(function(e){n[e]=e}),7!=d({},e)[t]||"abcdefghijklmnopqrst"!=i(d({},n)).join("")})?function(e,n){for(var t=l(e),r=arguments.length,d=1,h=s.f,u=a.f;r>d;)for(var p,f=c(arguments[d++]),m=h?i(f).concat(h(f)):i(f),g=m.length,y=0;g>y;)p=m[y++],o&&!u.call(f,p)||(t[p]=f[p]);return t}:d},"./node_modules/core-js/internals/object-create.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/object-define-properties.js"),i=t("./node_modules/core-js/internals/enum-bug-keys.js"),s=t("./node_modules/core-js/internals/hidden-keys.js"),a=t("./node_modules/core-js/internals/html.js"),l=t("./node_modules/core-js/internals/document-create-element.js"),c=t("./node_modules/core-js/internals/shared-key.js")("IE_PROTO"),d=function(){},h=function(){var e,n=l("iframe"),t=i.length;for(n.style.display="none",a.appendChild(n),n.src=String("javascript:"),(e=n.contentWindow.document).open(),e.write("<script>document.F=Object<\/script>"),e.close(),h=e.F;t--;)delete h.prototype[i[t]];return h()};e.exports=Object.create||function(e,n){var t;return null!==e?(d.prototype=o(e),t=new d,d.prototype=null,t[c]=e):t=h(),void 0===n?t:r(t,n)},s[c]=!0},"./node_modules/core-js/internals/object-define-properties.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/object-keys.js");e.exports=o?Object.defineProperties:function(e,n){i(e);for(var t,o=s(n),a=o.length,l=0;a>l;)r.f(e,t=o[l++],n[t]);return e}},"./node_modules/core-js/internals/object-define-property.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/ie8-dom-define.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/to-primitive.js"),a=Object.defineProperty;n.f=o?a:function(e,n,t){if(i(e),n=s(n,!0),i(t),r)try{return a(e,n,t)}catch(e){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(e[n]=t.value),e}},"./node_modules/core-js/internals/object-get-own-property-descriptor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-property-is-enumerable.js"),i=t("./node_modules/core-js/internals/create-property-descriptor.js"),s=t("./node_modules/core-js/internals/to-indexed-object.js"),a=t("./node_modules/core-js/internals/to-primitive.js"),l=t("./node_modules/core-js/internals/has.js"),c=t("./node_modules/core-js/internals/ie8-dom-define.js"),d=Object.getOwnPropertyDescriptor;n.f=o?d:function(e,n){if(e=s(e),n=a(n,!0),c)try{return d(e,n)}catch(e){}if(l(e,n))return i(!r.f.call(e,n),e[n])}},"./node_modules/core-js/internals/object-get-own-property-names-external.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-indexed-object.js"),r=t("./node_modules/core-js/internals/object-get-own-property-names.js").f,i={}.toString,s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];e.exports.f=function(e){return s&&"[object Window]"==i.call(e)?function(e){try{return r(e)}catch(e){return s.slice()}}(e):r(o(e))}},"./node_modules/core-js/internals/object-get-own-property-names.js":function(e,n,t){var o=t("./node_modules/core-js/internals/object-keys-internal.js"),r=t("./node_modules/core-js/internals/enum-bug-keys.js").concat("length","prototype");n.f=Object.getOwnPropertyNames||function(e){return o(e,r)}},"./node_modules/core-js/internals/object-get-own-property-symbols.js":function(e,n){n.f=Object.getOwnPropertySymbols},"./node_modules/core-js/internals/object-get-prototype-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/has.js"),r=t("./node_modules/core-js/internals/to-object.js"),i=t("./node_modules/core-js/internals/shared-key.js"),s=t("./node_modules/core-js/internals/correct-prototype-getter.js"),a=i("IE_PROTO"),l=Object.prototype;e.exports=s?Object.getPrototypeOf:function(e){return e=r(e),o(e,a)?e[a]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?l:null}},"./node_modules/core-js/internals/object-keys-internal.js":function(e,n,t){var o=t("./node_modules/core-js/internals/has.js"),r=t("./node_modules/core-js/internals/to-indexed-object.js"),i=t("./node_modules/core-js/internals/array-includes.js").indexOf,s=t("./node_modules/core-js/internals/hidden-keys.js");e.exports=function(e,n){var t,a=r(e),l=0,c=[];for(t in a)!o(s,t)&&o(a,t)&&c.push(t);for(;n.length>l;)o(a,t=n[l++])&&(~i(c,t)||c.push(t));return c}},"./node_modules/core-js/internals/object-keys.js":function(e,n,t){var o=t("./node_modules/core-js/internals/object-keys-internal.js"),r=t("./node_modules/core-js/internals/enum-bug-keys.js");e.exports=Object.keys||function(e){return o(e,r)}},"./node_modules/core-js/internals/object-property-is-enumerable.js":function(e,n,t){"use strict";var o={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!o.call({1:2},1);n.f=i?function(e){var n=r(this,e);return!!n&&n.enumerable}:o},"./node_modules/core-js/internals/object-set-prototype-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/a-possible-prototype.js");e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,n=!1,t={};try{(e=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),n=t instanceof Array}catch(e){}return function(t,i){return o(t),r(i),n?e.call(t,i):t.__proto__=i,t}}():void 0)},"./node_modules/core-js/internals/object-to-array.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-keys.js"),i=t("./node_modules/core-js/internals/to-indexed-object.js"),s=t("./node_modules/core-js/internals/object-property-is-enumerable.js").f,a=function(e){return function(n){for(var t,a=i(n),l=r(a),c=l.length,d=0,h=[];c>d;)t=l[d++],o&&!s.call(a,t)||h.push(e?[t,a[t]]:a[t]);return h}};e.exports={entries:a(!0),values:a(!1)}},"./node_modules/core-js/internals/object-to-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/classof.js"),r={};r[t("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag")]="z",e.exports="[object z]"!==String(r)?function(){return"[object "+o(this)+"]"}:r.toString},"./node_modules/core-js/internals/own-keys.js":function(e,n,t){var o=t("./node_modules/core-js/internals/get-built-in.js"),r=t("./node_modules/core-js/internals/object-get-own-property-names.js"),i=t("./node_modules/core-js/internals/object-get-own-property-symbols.js"),s=t("./node_modules/core-js/internals/an-object.js");e.exports=o("Reflect","ownKeys")||function(e){var n=r.f(s(e)),t=i.f;return t?n.concat(t(e)):n}},"./node_modules/core-js/internals/parse-float.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/string-trim.js").trim,i=t("./node_modules/core-js/internals/whitespaces.js"),s=o.parseFloat,a=1/s(i+"-0")!=-1/0;e.exports=a?function(e){var n=r(String(e)),t=s(n);return 0===t&&"-"==n.charAt(0)?-0:t}:s},"./node_modules/core-js/internals/parse-int.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/string-trim.js").trim,i=t("./node_modules/core-js/internals/whitespaces.js"),s=o.parseInt,a=/^[+-]?0[Xx]/,l=8!==s(i+"08")||22!==s(i+"0x16");e.exports=l?function(e,n){var t=r(String(e));return s(t,n>>>0||(a.test(t)?16:10))}:s},"./node_modules/core-js/internals/path.js":function(e,n,t){e.exports=t("./node_modules/core-js/internals/global.js")},"./node_modules/core-js/internals/perform.js":function(e,n){e.exports=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}}},"./node_modules/core-js/internals/promise-resolve.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/new-promise-capability.js");e.exports=function(e,n){if(o(e),r(n)&&n.constructor===e)return n;var t=i.f(e);return(0,t.resolve)(n),t.promise}},"./node_modules/core-js/internals/punycode-to-ascii.js":function(e,n,t){"use strict";var o=/[^\0-\u007E]/,r=/[.\u3002\uFF0E\uFF61]/g,i="Overflow: input needs wider integers to process",s=Math.floor,a=String.fromCharCode,l=function(e){return e+22+75*(e<26)},c=function(e,n,t){var o=0;for(e=t?s(e/700):e>>1,e+=s(e/n);e>455;o+=36)e=s(e/35);return s(o+36*e/(e+38))},d=function(e){var n,t,o=[],r=(e=function(e){for(var n=[],t=0,o=e.length;t<o;){var r=e.charCodeAt(t++);if(r>=55296&&r<=56319&&t<o){var i=e.charCodeAt(t++);56320==(64512&i)?n.push(((1023&r)<<10)+(1023&i)+65536):(n.push(r),t--)}else n.push(r)}return n}(e)).length,d=128,h=0,u=72;for(n=0;n<e.length;n++)(t=e[n])<128&&o.push(a(t));var p=o.length,f=p;for(p&&o.push("-");f<r;){var m=2147483647;for(n=0;n<e.length;n++)(t=e[n])>=d&&t<m&&(m=t);var g=f+1;if(m-d>s((2147483647-h)/g))throw RangeError(i);for(h+=(m-d)*g,d=m,n=0;n<e.length;n++){if((t=e[n])<d&&++h>2147483647)throw RangeError(i);if(t==d){for(var y=h,b=36;;b+=36){var x=b<=u?1:b>=u+26?26:b-u;if(y<x)break;var v=y-x,j=36-x;o.push(a(l(x+v%j))),y=s(v/j)}o.push(a(l(y))),u=c(h,g,f==p),h=0,++f}}++h,++d}return o.join("")};e.exports=function(e){var n,t,i=[],s=e.toLowerCase().replace(r,".").split(".");for(n=0;n<s.length;n++)t=s[n],i.push(o.test(t)?"xn--"+d(t):t);return i.join(".")}},"./node_modules/core-js/internals/redefine-all.js":function(e,n,t){var o=t("./node_modules/core-js/internals/redefine.js");e.exports=function(e,n,t){for(var r in n)o(e,r,n[r],t);return e}},"./node_modules/core-js/internals/redefine.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/shared.js"),i=t("./node_modules/core-js/internals/hide.js"),s=t("./node_modules/core-js/internals/has.js"),a=t("./node_modules/core-js/internals/set-global.js"),l=t("./node_modules/core-js/internals/function-to-string.js"),c=t("./node_modules/core-js/internals/internal-state.js"),d=c.get,h=c.enforce,u=String(l).split("toString");r("inspectSource",function(e){return l.call(e)}),(e.exports=function(e,n,t,r){var l=!!r&&!!r.unsafe,c=!!r&&!!r.enumerable,d=!!r&&!!r.noTargetGet;"function"==typeof t&&("string"!=typeof n||s(t,"name")||i(t,"name",n),h(t).source=u.join("string"==typeof n?n:"")),e!==o?(l?!d&&e[n]&&(c=!0):delete e[n],c?e[n]=t:i(e,n,t)):c?e[n]=t:a(n,t)})(Function.prototype,"toString",function(){return"function"==typeof this&&d(this).source||l.call(this)})},"./node_modules/core-js/internals/reflect-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/modules/es.map.js"),r=t("./node_modules/core-js/modules/es.weak-map.js"),i=t("./node_modules/core-js/internals/shared.js")("metadata"),s=i.store||(i.store=new r),a=function(e,n,t){var r=s.get(e);if(!r){if(!t)return;s.set(e,r=new o)}var i=r.get(n);if(!i){if(!t)return;r.set(n,i=new o)}return i};e.exports={store:s,getMap:a,has:function(e,n,t){var o=a(n,t,!1);return void 0!==o&&o.has(e)},get:function(e,n,t){var o=a(n,t,!1);return void 0===o?void 0:o.get(e)},set:function(e,n,t,o){a(t,o,!0).set(e,n)},keys:function(e,n){var t=a(e,n,!1),o=[];return t&&t.forEach(function(e,n){o.push(n)}),o},toKey:function(e){return void 0===e||"symbol"==typeof e?e:String(e)}}},"./node_modules/core-js/internals/regexp-exec-abstract.js":function(e,n,t){var o=t("./node_modules/core-js/internals/classof-raw.js"),r=t("./node_modules/core-js/internals/regexp-exec.js");e.exports=function(e,n){var t=e.exec;if("function"==typeof t){var i=t.call(e,n);if("object"!=typeof i)throw TypeError("RegExp exec method returned something other than an Object or null");return i}if("RegExp"!==o(e))throw TypeError("RegExp#exec called on incompatible receiver");return r.call(e,n)}},"./node_modules/core-js/internals/regexp-exec.js":function(e,n,t){"use strict";var o,r,i=t("./node_modules/core-js/internals/regexp-flags.js"),s=RegExp.prototype.exec,a=String.prototype.replace,l=s,c=(o=/a/,r=/b*/g,s.call(o,"a"),s.call(r,"a"),0!==o.lastIndex||0!==r.lastIndex),d=void 0!==/()??/.exec("")[1];(c||d)&&(l=function(e){var n,t,o,r,l=this;return d&&(t=new RegExp("^"+l.source+"$(?!\\s)",i.call(l))),c&&(n=l.lastIndex),o=s.call(l,e),c&&o&&(l.lastIndex=l.global?o.index+o[0].length:n),d&&o&&o.length>1&&a.call(o[0],t,function(){for(r=1;r<arguments.length-2;r++)void 0===arguments[r]&&(o[r]=void 0)}),o}),e.exports=l},"./node_modules/core-js/internals/regexp-flags.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/an-object.js");e.exports=function(){var e=o(this),n="";return e.global&&(n+="g"),e.ignoreCase&&(n+="i"),e.multiline&&(n+="m"),e.dotAll&&(n+="s"),e.unicode&&(n+="u"),e.sticky&&(n+="y"),n}},"./node_modules/core-js/internals/require-object-coercible.js":function(e,n){e.exports=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e}},"./node_modules/core-js/internals/same-value-zero.js":function(e,n){e.exports=function(e,n){return e===n||e!=e&&n!=n}},"./node_modules/core-js/internals/same-value.js":function(e,n){e.exports=Object.is||function(e,n){return e===n?0!==e||1/e==1/n:e!=e&&n!=n}},"./node_modules/core-js/internals/set-global.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/hide.js");e.exports=function(e,n){try{r(o,e,n)}catch(t){o[e]=n}return n}},"./node_modules/core-js/internals/set-species.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/get-built-in.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js"),s=t("./node_modules/core-js/internals/descriptors.js"),a=i("species");e.exports=function(e){var n=o(e),t=r.f;s&&n&&!n[a]&&t(n,a,{configurable:!0,get:function(){return this}})}},"./node_modules/core-js/internals/set-to-string-tag.js":function(e,n,t){var o=t("./node_modules/core-js/internals/object-define-property.js").f,r=t("./node_modules/core-js/internals/has.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag");e.exports=function(e,n,t){e&&!r(e=t?e:e.prototype,i)&&o(e,i,{configurable:!0,value:n})}},"./node_modules/core-js/internals/shared-key.js":function(e,n,t){var o=t("./node_modules/core-js/internals/shared.js"),r=t("./node_modules/core-js/internals/uid.js"),i=o("keys");e.exports=function(e){return i[e]||(i[e]=r(e))}},"./node_modules/core-js/internals/shared.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/set-global.js"),i=t("./node_modules/core-js/internals/is-pure.js"),s=o["__core-js_shared__"]||r("__core-js_shared__",{});(e.exports=function(e,n){return s[e]||(s[e]=void 0!==n?n:{})})("versions",[]).push({version:"3.2.1",mode:i?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},"./node_modules/core-js/internals/sloppy-array-method.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fails.js");e.exports=function(e,n){var t=[][e];return!t||!o(function(){t.call(null,n||function(){throw 1},1)})}},"./node_modules/core-js/internals/species-constructor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/an-object.js"),r=t("./node_modules/core-js/internals/a-function.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("species");e.exports=function(e,n){var t,s=o(e).constructor;return void 0===s||null==(t=o(s)[i])?n:r(t)}},"./node_modules/core-js/internals/string-multibyte.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-integer.js"),r=t("./node_modules/core-js/internals/require-object-coercible.js"),i=function(e){return function(n,t){var i,s,a=String(r(n)),l=o(t),c=a.length;return l<0||l>=c?e?"":void 0:(i=a.charCodeAt(l))<55296||i>56319||l+1===c||(s=a.charCodeAt(l+1))<56320||s>57343?e?a.charAt(l):i:e?a.slice(l,l+2):s-56320+(i-55296<<10)+65536}};e.exports={codeAt:i(!1),charAt:i(!0)}},"./node_modules/core-js/internals/string-pad.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-length.js"),r=t("./node_modules/core-js/internals/string-repeat.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js"),s=Math.ceil,a=function(e){return function(n,t,a){var l,c,d=String(i(n)),h=d.length,u=void 0===a?" ":String(a),p=o(t);return p<=h||""==u?d:(l=p-h,(c=r.call(u,s(l/u.length))).length>l&&(c=c.slice(0,l)),e?d+c:c+d)}};e.exports={start:a(!1),end:a(!0)}},"./node_modules/core-js/internals/string-repeat.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-integer.js"),r=t("./node_modules/core-js/internals/require-object-coercible.js");e.exports="".repeat||function(e){var n=String(r(this)),t="",i=o(e);if(i<0||i==1/0)throw RangeError("Wrong number of repetitions");for(;i>0;(i>>>=1)&&(n+=n))1&i&&(t+=n);return t}},"./node_modules/core-js/internals/string-trim.js":function(e,n,t){var o=t("./node_modules/core-js/internals/require-object-coercible.js"),r="["+t("./node_modules/core-js/internals/whitespaces.js")+"]",i=RegExp("^"+r+r+"*"),s=RegExp(r+r+"*$"),a=function(e){return function(n){var t=String(o(n));return 1&e&&(t=t.replace(i,"")),2&e&&(t=t.replace(s,"")),t}};e.exports={start:a(1),end:a(2),trim:a(3)}},"./node_modules/core-js/internals/task.js":function(e,n,t){var o,r,i,s=t("./node_modules/core-js/internals/global.js"),a=t("./node_modules/core-js/internals/fails.js"),l=t("./node_modules/core-js/internals/classof-raw.js"),c=t("./node_modules/core-js/internals/bind-context.js"),d=t("./node_modules/core-js/internals/html.js"),h=t("./node_modules/core-js/internals/document-create-element.js"),u=s.location,p=s.setImmediate,f=s.clearImmediate,m=s.process,g=s.MessageChannel,y=s.Dispatch,b=0,x={},v=function(e){if(x.hasOwnProperty(e)){var n=x[e];delete x[e],n()}},j=function(e){return function(){v(e)}},w=function(e){v(e.data)},k=function(e){s.postMessage(e+"",u.protocol+"//"+u.host)};p&&f||(p=function(e){for(var n=[],t=1;arguments.length>t;)n.push(arguments[t++]);return x[++b]=function(){("function"==typeof e?e:Function(e)).apply(void 0,n)},o(b),b},f=function(e){delete x[e]},"process"==l(m)?o=function(e){m.nextTick(j(e))}:y&&y.now?o=function(e){y.now(j(e))}:g?(i=(r=new g).port2,r.port1.onmessage=w,o=c(i.postMessage,i,1)):!s.addEventListener||"function"!=typeof postMessage||s.importScripts||a(k)?o="onreadystatechange"in h("script")?function(e){d.appendChild(h("script")).onreadystatechange=function(){d.removeChild(this),v(e)}}:function(e){setTimeout(j(e),0)}:(o=k,s.addEventListener("message",w,!1))),e.exports={set:p,clear:f}},"./node_modules/core-js/internals/this-number-value.js":function(e,n,t){var o=t("./node_modules/core-js/internals/classof-raw.js");e.exports=function(e){if("number"!=typeof e&&"Number"!=o(e))throw TypeError("Incorrect invocation");return+e}},"./node_modules/core-js/internals/to-absolute-index.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-integer.js"),r=Math.max,i=Math.min;e.exports=function(e,n){var t=o(e);return t<0?r(t+n,0):i(t,n)}},"./node_modules/core-js/internals/to-index.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-integer.js"),r=t("./node_modules/core-js/internals/to-length.js");e.exports=function(e){if(void 0===e)return 0;var n=o(e),t=r(n);if(n!==t)throw RangeError("Wrong length or index");return t}},"./node_modules/core-js/internals/to-indexed-object.js":function(e,n,t){var o=t("./node_modules/core-js/internals/indexed-object.js"),r=t("./node_modules/core-js/internals/require-object-coercible.js");e.exports=function(e){return o(r(e))}},"./node_modules/core-js/internals/to-integer.js":function(e,n){var t=Math.ceil,o=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?o:t)(e)}},"./node_modules/core-js/internals/to-length.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-integer.js"),r=Math.min;e.exports=function(e){return e>0?r(o(e),9007199254740991):0}},"./node_modules/core-js/internals/to-object.js":function(e,n,t){var o=t("./node_modules/core-js/internals/require-object-coercible.js");e.exports=function(e){return Object(o(e))}},"./node_modules/core-js/internals/to-offset.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-integer.js");e.exports=function(e,n){var t=o(e);if(t<0||t%n)throw RangeError("Wrong offset");return t}},"./node_modules/core-js/internals/to-primitive.js":function(e,n,t){var o=t("./node_modules/core-js/internals/is-object.js");e.exports=function(e,n){if(!o(e))return e;var t,r;if(n&&"function"==typeof(t=e.toString)&&!o(r=t.call(e)))return r;if("function"==typeof(t=e.valueOf)&&!o(r=t.call(e)))return r;if(!n&&"function"==typeof(t=e.toString)&&!o(r=t.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},"./node_modules/core-js/internals/typed-array-constructor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/descriptors.js"),s=t("./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js"),a=t("./node_modules/core-js/internals/array-buffer-view-core.js"),l=t("./node_modules/core-js/internals/array-buffer.js"),c=t("./node_modules/core-js/internals/an-instance.js"),d=t("./node_modules/core-js/internals/create-property-descriptor.js"),h=t("./node_modules/core-js/internals/hide.js"),u=t("./node_modules/core-js/internals/to-length.js"),p=t("./node_modules/core-js/internals/to-index.js"),f=t("./node_modules/core-js/internals/to-offset.js"),m=t("./node_modules/core-js/internals/to-primitive.js"),g=t("./node_modules/core-js/internals/has.js"),y=t("./node_modules/core-js/internals/classof.js"),b=t("./node_modules/core-js/internals/is-object.js"),x=t("./node_modules/core-js/internals/object-create.js"),v=t("./node_modules/core-js/internals/object-set-prototype-of.js"),j=t("./node_modules/core-js/internals/object-get-own-property-names.js").f,w=t("./node_modules/core-js/internals/typed-array-from.js"),k=t("./node_modules/core-js/internals/array-iteration.js").forEach,_=t("./node_modules/core-js/internals/set-species.js"),S=t("./node_modules/core-js/internals/object-define-property.js"),C=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),A=t("./node_modules/core-js/internals/internal-state.js"),T=A.get,O=A.set,P=S.f,M=C.f,L=Math.round,H=r.RangeError,I=l.ArrayBuffer,D=l.DataView,E=a.NATIVE_ARRAY_BUFFER_VIEWS,B=a.TYPED_ARRAY_TAG,R=a.TypedArray,N=a.TypedArrayPrototype,z=a.aTypedArrayConstructor,G=a.isTypedArray,W=function(e,n){for(var t=0,o=n.length,r=new(z(e))(o);o>t;)r[t]=n[t++];return r},F=function(e,n){P(e,n,{get:function(){return T(this)[n]}})},X=function(e){var n;return e instanceof I||"ArrayBuffer"==(n=y(e))||"SharedArrayBuffer"==n},V=function(e,n){return G(e)&&"symbol"!=typeof n&&n in e&&String(+n)==String(n)},Y=function(e,n){return V(e,n=m(n,!0))?d(2,e[n]):M(e,n)},U=function(e,n,t){return!(V(e,n=m(n,!0))&&b(t)&&g(t,"value"))||g(t,"get")||g(t,"set")||t.configurable||g(t,"writable")&&!t.writable||g(t,"enumerable")&&!t.enumerable?P(e,n,t):(e[n]=t.value,e)};i?(E||(C.f=Y,S.f=U,F(N,"buffer"),F(N,"byteOffset"),F(N,"byteLength"),F(N,"length")),o({target:"Object",stat:!0,forced:!E},{getOwnPropertyDescriptor:Y,defineProperty:U}),e.exports=function(e,n,t,i){var a=e+(i?"Clamped":"")+"Array",l="get"+e,d="set"+e,m=r[a],g=m,y=g&&g.prototype,S={},C=function(e,t){P(e,t,{get:function(){return function(e,t){var o=T(e);return o.view[l](t*n+o.byteOffset,!0)}(this,t)},set:function(e){return function(e,t,o){var r=T(e);i&&(o=(o=L(o))<0?0:o>255?255:255&o),r.view[d](t*n+r.byteOffset,o,!0)}(this,t,e)},enumerable:!0})};E?s&&(g=t(function(e,t,o,r){return c(e,g,a),b(t)?X(t)?void 0!==r?new m(t,f(o,n),r):void 0!==o?new m(t,f(o,n)):new m(t):G(t)?W(g,t):w.call(g,t):new m(p(t))}),v&&v(g,R),k(j(m),function(e){e in g||h(g,e,m[e])}),g.prototype=y):(g=t(function(e,t,o,r){c(e,g,a);var i,s,l,d=0,h=0;if(b(t)){if(!X(t))return G(t)?W(g,t):w.call(g,t);i=t,h=f(o,n);var m=t.byteLength;if(void 0===r){if(m%n)throw H("Wrong length");if((s=m-h)<0)throw H("Wrong length")}else if((s=u(r)*n)+h>m)throw H("Wrong length");l=s/n}else l=p(t),i=new I(s=l*n);for(O(e,{buffer:i,byteOffset:h,byteLength:s,length:l,view:new D(i)});d<l;)C(e,d++)}),v&&v(g,R),y=g.prototype=x(N)),y.constructor!==g&&h(y,"constructor",g),B&&h(y,B,a),S[a]=g,o({global:!0,forced:g!=m,sham:!E},S),"BYTES_PER_ELEMENT"in g||h(g,"BYTES_PER_ELEMENT",n),"BYTES_PER_ELEMENT"in y||h(y,"BYTES_PER_ELEMENT",n),_(a)}):e.exports=function(){}},"./node_modules/core-js/internals/typed-array-from.js":function(e,n,t){var o=t("./node_modules/core-js/internals/to-object.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/get-iterator-method.js"),s=t("./node_modules/core-js/internals/is-array-iterator-method.js"),a=t("./node_modules/core-js/internals/bind-context.js"),l=t("./node_modules/core-js/internals/array-buffer-view-core.js").aTypedArrayConstructor;e.exports=function(e){var n,t,c,d,h,u=o(e),p=arguments.length,f=p>1?arguments[1]:void 0,m=void 0!==f,g=i(u);if(null!=g&&!s(g))for(h=g.call(u),u=[];!(d=h.next()).done;)u.push(d.value);for(m&&p>2&&(f=a(f,arguments[2],2)),t=r(u.length),c=new(l(this))(t),n=0;t>n;n++)c[n]=m?f(u[n],n):u[n];return c}},"./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/check-correctness-of-iteration.js"),s=t("./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER_VIEWS,a=o.ArrayBuffer,l=o.Int8Array;e.exports=!s||!r(function(){l(1)})||!r(function(){new l(-1)})||!i(function(e){new l,new l(null),new l(1.5),new l(e)},!0)||r(function(){return 1!==new l(new a(2),1,void 0).length})},"./node_modules/core-js/internals/uid.js":function(e,n){var t=0,o=Math.random();e.exports=function(e){return"Symbol("+String(void 0===e?"":e)+")_"+(++t+o).toString(36)}},"./node_modules/core-js/internals/user-agent.js":function(e,n,t){var o=t("./node_modules/core-js/internals/get-built-in.js");e.exports=o("navigator","userAgent")||""},"./node_modules/core-js/internals/webkit-string-pad-bug.js":function(e,n,t){var o=t("./node_modules/core-js/internals/user-agent.js");e.exports=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o)},"./node_modules/core-js/internals/well-known-symbol.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/shared.js"),i=t("./node_modules/core-js/internals/uid.js"),s=t("./node_modules/core-js/internals/native-symbol.js"),a=o.Symbol,l=r("wks");e.exports=function(e){return l[e]||(l[e]=s&&a[e]||(s?a:i)("Symbol."+e))}},"./node_modules/core-js/internals/whitespaces.js":function(e,n){e.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},"./node_modules/core-js/internals/wrapped-well-known-symbol.js":function(e,n,t){n.f=t("./node_modules/core-js/internals/well-known-symbol.js")},"./node_modules/core-js/modules/es.array-buffer.constructor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/array-buffer.js"),s=t("./node_modules/core-js/internals/set-species.js"),a=i.ArrayBuffer;o({global:!0,forced:r.ArrayBuffer!==a},{ArrayBuffer:a}),s("ArrayBuffer")},"./node_modules/core-js/modules/es.array-buffer.is-view.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-buffer-view-core.js");o({target:"ArrayBuffer",stat:!0,forced:!r.NATIVE_ARRAY_BUFFER_VIEWS},{isView:r.isView})},"./node_modules/core-js/modules/es.array-buffer.slice.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/array-buffer.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/to-absolute-index.js"),l=t("./node_modules/core-js/internals/to-length.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=i.ArrayBuffer,h=i.DataView,u=d.prototype.slice;o({target:"ArrayBuffer",proto:!0,unsafe:!0,forced:r(function(){return!new d(2).slice(1,void 0).byteLength})},{slice:function(e,n){if(void 0!==u&&void 0===n)return u.call(s(this),e);for(var t=s(this).byteLength,o=a(e,t),r=a(void 0===n?t:n,t),i=new(c(this,d))(l(r-o)),p=new h(this),f=new h(i),m=0;o<r;)f.setUint8(m++,p.getUint8(o++));return i}})},"./node_modules/core-js/modules/es.array.concat.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/is-array.js"),s=t("./node_modules/core-js/internals/is-object.js"),a=t("./node_modules/core-js/internals/to-object.js"),l=t("./node_modules/core-js/internals/to-length.js"),c=t("./node_modules/core-js/internals/create-property.js"),d=t("./node_modules/core-js/internals/array-species-create.js"),h=t("./node_modules/core-js/internals/array-method-has-species-support.js"),u=t("./node_modules/core-js/internals/well-known-symbol.js")("isConcatSpreadable"),p=!r(function(){var e=[];return e[u]=!1,e.concat()[0]!==e}),f=h("concat"),m=function(e){if(!s(e))return!1;var n=e[u];return void 0!==n?!!n:i(e)};o({target:"Array",proto:!0,forced:!p||!f},{concat:function(e){var n,t,o,r,i,s=a(this),h=d(s,0),u=0;for(n=-1,o=arguments.length;n<o;n++)if(i=-1===n?s:arguments[n],m(i)){if(u+(r=l(i.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<r;t++,u++)t in i&&c(h,u,i[t])}else{if(u>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(h,u++,i)}return h.length=u,h}})},"./node_modules/core-js/modules/es.array.copy-within.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-copy-within.js"),i=t("./node_modules/core-js/internals/add-to-unscopables.js");o({target:"Array",proto:!0},{copyWithin:r}),i("copyWithin")},"./node_modules/core-js/modules/es.array.every.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").every;o({target:"Array",proto:!0,forced:t("./node_modules/core-js/internals/sloppy-array-method.js")("every")},{every:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.fill.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-fill.js"),i=t("./node_modules/core-js/internals/add-to-unscopables.js");o({target:"Array",proto:!0},{fill:r}),i("fill")},"./node_modules/core-js/modules/es.array.filter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").filter;o({target:"Array",proto:!0,forced:!t("./node_modules/core-js/internals/array-method-has-species-support.js")("filter")},{filter:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.find-index.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").findIndex,i=t("./node_modules/core-js/internals/add-to-unscopables.js"),s=!0;"findIndex"in[]&&Array(1).findIndex(function(){s=!1}),o({target:"Array",proto:!0,forced:s},{findIndex:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),i("findIndex")},"./node_modules/core-js/modules/es.array.find.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").find,i=t("./node_modules/core-js/internals/add-to-unscopables.js"),s=!0;"find"in[]&&Array(1).find(function(){s=!1}),o({target:"Array",proto:!0,forced:s},{find:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),i("find")},"./node_modules/core-js/modules/es.array.flat-map.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/flatten-into-array.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/array-species-create.js");o({target:"Array",proto:!0},{flatMap:function(e){var n,t=i(this),o=s(t.length);return a(e),(n=l(t,0)).length=r(n,t,t,o,0,1,e,arguments.length>1?arguments[1]:void 0),n}})},"./node_modules/core-js/modules/es.array.flat.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/flatten-into-array.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/to-integer.js"),l=t("./node_modules/core-js/internals/array-species-create.js");o({target:"Array",proto:!0},{flat:function(){var e=arguments.length?arguments[0]:void 0,n=i(this),t=s(n.length),o=l(n,0);return o.length=r(o,n,n,t,0,void 0===e?1:a(e)),o}})},"./node_modules/core-js/modules/es.array.for-each.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-for-each.js");o({target:"Array",proto:!0,forced:[].forEach!=r},{forEach:r})},"./node_modules/core-js/modules/es.array.from.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-from.js");o({target:"Array",stat:!0,forced:!t("./node_modules/core-js/internals/check-correctness-of-iteration.js")(function(e){Array.from(e)})},{from:r})},"./node_modules/core-js/modules/es.array.includes.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-includes.js").includes,i=t("./node_modules/core-js/internals/add-to-unscopables.js");o({target:"Array",proto:!0},{includes:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}}),i("includes")},"./node_modules/core-js/modules/es.array.index-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-includes.js").indexOf,i=t("./node_modules/core-js/internals/sloppy-array-method.js"),s=[].indexOf,a=!!s&&1/[1].indexOf(1,-0)<0,l=i("indexOf");o({target:"Array",proto:!0,forced:a||l},{indexOf:function(e){return a?s.apply(this,arguments)||0:r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.iterator.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/to-indexed-object.js"),r=t("./node_modules/core-js/internals/add-to-unscopables.js"),i=t("./node_modules/core-js/internals/iterators.js"),s=t("./node_modules/core-js/internals/internal-state.js"),a=t("./node_modules/core-js/internals/define-iterator.js"),l=s.set,c=s.getterFor("Array Iterator");e.exports=a(Array,"Array",function(e,n){l(this,{type:"Array Iterator",target:o(e),index:0,kind:n})},function(){var e=c(this),n=e.target,t=e.kind,o=e.index++;return!n||o>=n.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:o,done:!1}:"values"==t?{value:n[o],done:!1}:{value:[o,n[o]],done:!1}},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},"./node_modules/core-js/modules/es.array.join.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/indexed-object.js"),i=t("./node_modules/core-js/internals/to-indexed-object.js"),s=t("./node_modules/core-js/internals/sloppy-array-method.js"),a=[].join,l=r!=Object,c=s("join",",");o({target:"Array",proto:!0,forced:l||c},{join:function(e){return a.call(i(this),void 0===e?",":e)}})},"./node_modules/core-js/modules/es.array.last-index-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-last-index-of.js");o({target:"Array",proto:!0,forced:r!==[].lastIndexOf},{lastIndexOf:r})},"./node_modules/core-js/modules/es.array.map.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").map;o({target:"Array",proto:!0,forced:!t("./node_modules/core-js/internals/array-method-has-species-support.js")("map")},{map:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/create-property.js");o({target:"Array",stat:!0,forced:r(function(){function e(){}return!(Array.of.call(e)instanceof e)})},{of:function(){for(var e=0,n=arguments.length,t=new("function"==typeof this?this:Array)(n);n>e;)i(t,e,arguments[e++]);return t.length=n,t}})},"./node_modules/core-js/modules/es.array.reduce-right.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-reduce.js").right;o({target:"Array",proto:!0,forced:t("./node_modules/core-js/internals/sloppy-array-method.js")("reduceRight")},{reduceRight:function(e){return r(this,e,arguments.length,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.reduce.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-reduce.js").left;o({target:"Array",proto:!0,forced:t("./node_modules/core-js/internals/sloppy-array-method.js")("reduce")},{reduce:function(e){return r(this,e,arguments.length,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.reverse.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-array.js"),i=[].reverse,s=[1,2];o({target:"Array",proto:!0,forced:String(s)===String(s.reverse())},{reverse:function(){return r(this)&&(this.length=this.length),i.call(this)}})},"./node_modules/core-js/modules/es.array.slice.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/is-array.js"),s=t("./node_modules/core-js/internals/to-absolute-index.js"),a=t("./node_modules/core-js/internals/to-length.js"),l=t("./node_modules/core-js/internals/to-indexed-object.js"),c=t("./node_modules/core-js/internals/create-property.js"),d=t("./node_modules/core-js/internals/array-method-has-species-support.js"),h=t("./node_modules/core-js/internals/well-known-symbol.js")("species"),u=[].slice,p=Math.max;o({target:"Array",proto:!0,forced:!d("slice")},{slice:function(e,n){var t,o,d,f=l(this),m=a(f.length),g=s(e,m),y=s(void 0===n?m:n,m);if(i(f)&&("function"!=typeof(t=f.constructor)||t!==Array&&!i(t.prototype)?r(t)&&null===(t=t[h])&&(t=void 0):t=void 0,t===Array||void 0===t))return u.call(f,g,y);for(o=new(void 0===t?Array:t)(p(y-g,0)),d=0;g<y;g++,d++)g in f&&c(o,d,f[g]);return o.length=d,o}})},"./node_modules/core-js/modules/es.array.some.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-iteration.js").some;o({target:"Array",proto:!0,forced:t("./node_modules/core-js/internals/sloppy-array-method.js")("some")},{some:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.array.sort.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/a-function.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/fails.js"),a=t("./node_modules/core-js/internals/sloppy-array-method.js"),l=[].sort,c=[1,2,3],d=s(function(){c.sort(void 0)}),h=s(function(){c.sort(null)}),u=a("sort");o({target:"Array",proto:!0,forced:d||!h||u},{sort:function(e){return void 0===e?l.call(i(this)):l.call(i(this),r(e))}})},"./node_modules/core-js/modules/es.array.species.js":function(e,n,t){t("./node_modules/core-js/internals/set-species.js")("Array")},"./node_modules/core-js/modules/es.array.splice.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-absolute-index.js"),i=t("./node_modules/core-js/internals/to-integer.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/to-object.js"),l=t("./node_modules/core-js/internals/array-species-create.js"),c=t("./node_modules/core-js/internals/create-property.js"),d=t("./node_modules/core-js/internals/array-method-has-species-support.js"),h=Math.max,u=Math.min;o({target:"Array",proto:!0,forced:!d("splice")},{splice:function(e,n){var t,o,d,p,f,m,g=a(this),y=s(g.length),b=r(e,y),x=arguments.length;if(0===x?t=o=0:1===x?(t=0,o=y-b):(t=x-2,o=u(h(i(n),0),y-b)),y+t-o>9007199254740991)throw TypeError("Maximum allowed length exceeded");for(d=l(g,o),p=0;p<o;p++)(f=b+p)in g&&c(d,p,g[f]);if(d.length=o,t<o){for(p=b;p<y-o;p++)m=p+t,(f=p+o)in g?g[m]=g[f]:delete g[m];for(p=y;p>y-o+t;p--)delete g[p-1]}else if(t>o)for(p=y-o;p>b;p--)m=p+t-1,(f=p+o-1)in g?g[m]=g[f]:delete g[m];for(p=0;p<t;p++)g[p+b]=arguments[p+2];return g.length=y-o+t,d}})},"./node_modules/core-js/modules/es.array.unscopables.flat-map.js":function(e,n,t){t("./node_modules/core-js/internals/add-to-unscopables.js")("flatMap")},"./node_modules/core-js/modules/es.array.unscopables.flat.js":function(e,n,t){t("./node_modules/core-js/internals/add-to-unscopables.js")("flat")},"./node_modules/core-js/modules/es.data-view.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/array-buffer.js");o({global:!0,forced:!t("./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER},{DataView:r.DataView})},"./node_modules/core-js/modules/es.date.to-iso-string.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/date-to-iso-string.js");o({target:"Date",proto:!0,forced:Date.prototype.toISOString!==r},{toISOString:r})},"./node_modules/core-js/modules/es.date.to-json.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-primitive.js");o({target:"Date",proto:!0,forced:r(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})})},{toJSON:function(e){var n=i(this),t=s(n);return"number"!=typeof t||isFinite(t)?n.toISOString():null}})},"./node_modules/core-js/modules/es.date.to-primitive.js":function(e,n,t){var o=t("./node_modules/core-js/internals/hide.js"),r=t("./node_modules/core-js/internals/date-to-primitive.js"),i=t("./node_modules/core-js/internals/well-known-symbol.js")("toPrimitive"),s=Date.prototype;i in s||o(s,i,r)},"./node_modules/core-js/modules/es.date.to-string.js":function(e,n,t){var o=t("./node_modules/core-js/internals/redefine.js"),r=Date.prototype,i=r.toString,s=r.getTime;new Date(NaN)+""!="Invalid Date"&&o(r,"toString",function(){var e=s.call(this);return e==e?i.call(this):"Invalid Date"})},"./node_modules/core-js/modules/es.function.has-instance.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/is-object.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/object-get-prototype-of.js"),s=t("./node_modules/core-js/internals/well-known-symbol.js")("hasInstance"),a=Function.prototype;s in a||r.f(a,s,{value:function(e){if("function"!=typeof this||!o(e))return!1;if(!o(this.prototype))return e instanceof this;for(;e=i(e);)if(this.prototype===e)return!0;return!1}})},"./node_modules/core-js/modules/es.function.name.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-define-property.js").f,i=Function.prototype,s=i.toString,a=/^\s*function ([^ (]*)/;!o||"name"in i||r(i,"name",{configurable:!0,get:function(){try{return s.call(this).match(a)[1]}catch(e){return""}}})},"./node_modules/core-js/modules/es.json.to-string-tag.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js");t("./node_modules/core-js/internals/set-to-string-tag.js")(o.JSON,"JSON",!0)},"./node_modules/core-js/modules/es.map.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/collection.js"),r=t("./node_modules/core-js/internals/collection-strong.js");e.exports=o("Map",function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},r,!0)},"./node_modules/core-js/modules/es.math.acosh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-log1p.js"),i=Math.acosh,s=Math.log,a=Math.sqrt,l=Math.LN2;o({target:"Math",stat:!0,forced:!i||710!=Math.floor(i(Number.MAX_VALUE))||i(1/0)!=1/0},{acosh:function(e){return(e=+e)<1?NaN:e>94906265.62425156?s(e)+l:r(e-1+a(e-1)*a(e+1))}})},"./node_modules/core-js/modules/es.math.asinh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.asinh,i=Math.log,s=Math.sqrt;o({target:"Math",stat:!0,forced:!(r&&1/r(0)>0)},{asinh:function e(n){return isFinite(n=+n)&&0!=n?n<0?-e(-n):i(n+s(n*n+1)):n}})},"./node_modules/core-js/modules/es.math.atanh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.atanh,i=Math.log;o({target:"Math",stat:!0,forced:!(r&&1/r(-0)<0)},{atanh:function(e){return 0==(e=+e)?e:i((1+e)/(1-e))/2}})},"./node_modules/core-js/modules/es.math.cbrt.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-sign.js"),i=Math.abs,s=Math.pow;o({target:"Math",stat:!0},{cbrt:function(e){return r(e=+e)*s(i(e),1/3)}})},"./node_modules/core-js/modules/es.math.clz32.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.floor,i=Math.log,s=Math.LOG2E;o({target:"Math",stat:!0},{clz32:function(e){return(e>>>=0)?31-r(i(e+.5)*s):32}})},"./node_modules/core-js/modules/es.math.cosh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-expm1.js"),i=Math.cosh,s=Math.abs,a=Math.E;o({target:"Math",stat:!0,forced:!i||i(710)===1/0},{cosh:function(e){var n=r(s(e)-1)+1;return(n+1/(n*a*a))*(a/2)}})},"./node_modules/core-js/modules/es.math.expm1.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-expm1.js");o({target:"Math",stat:!0,forced:r!=Math.expm1},{expm1:r})},"./node_modules/core-js/modules/es.math.fround.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{fround:t("./node_modules/core-js/internals/math-fround.js")})},"./node_modules/core-js/modules/es.math.hypot.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.hypot,i=Math.abs,s=Math.sqrt;o({target:"Math",stat:!0,forced:!!r&&r(1/0,NaN)!==1/0},{hypot:function(e,n){for(var t,o,r=0,a=0,l=arguments.length,c=0;a<l;)c<(t=i(arguments[a++]))?(r=r*(o=c/t)*o+1,c=t):r+=t>0?(o=t/c)*o:t;return c===1/0?1/0:c*s(r)}})},"./node_modules/core-js/modules/es.math.imul.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=Math.imul;o({target:"Math",stat:!0,forced:r(function(){return-5!=i(4294967295,5)||2!=i.length})},{imul:function(e,n){var t=+e,o=+n,r=65535&t,i=65535&o;return 0|r*i+((65535&t>>>16)*i+r*(65535&o>>>16)<<16>>>0)}})},"./node_modules/core-js/modules/es.math.log10.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.log,i=Math.LOG10E;o({target:"Math",stat:!0},{log10:function(e){return r(e)*i}})},"./node_modules/core-js/modules/es.math.log1p.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{log1p:t("./node_modules/core-js/internals/math-log1p.js")})},"./node_modules/core-js/modules/es.math.log2.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.log,i=Math.LN2;o({target:"Math",stat:!0},{log2:function(e){return r(e)/i}})},"./node_modules/core-js/modules/es.math.sign.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{sign:t("./node_modules/core-js/internals/math-sign.js")})},"./node_modules/core-js/modules/es.math.sinh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/math-expm1.js"),s=Math.abs,a=Math.exp,l=Math.E;o({target:"Math",stat:!0,forced:r(function(){return-2e-17!=Math.sinh(-2e-17)})},{sinh:function(e){return s(e=+e)<1?(i(e)-i(-e))/2:(a(e-1)-a(-e-1))*(l/2)}})},"./node_modules/core-js/modules/es.math.tanh.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-expm1.js"),i=Math.exp;o({target:"Math",stat:!0},{tanh:function(e){var n=r(e=+e),t=r(-e);return n==1/0?1:t==1/0?-1:(n-t)/(i(e)+i(-e))}})},"./node_modules/core-js/modules/es.math.to-string-tag.js":function(e,n,t){t("./node_modules/core-js/internals/set-to-string-tag.js")(Math,"Math",!0)},"./node_modules/core-js/modules/es.math.trunc.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.ceil,i=Math.floor;o({target:"Math",stat:!0},{trunc:function(e){return(e>0?i:r)(e)}})},"./node_modules/core-js/modules/es.number.constructor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/is-forced.js"),s=t("./node_modules/core-js/internals/redefine.js"),a=t("./node_modules/core-js/internals/has.js"),l=t("./node_modules/core-js/internals/classof-raw.js"),c=t("./node_modules/core-js/internals/inherit-if-required.js"),d=t("./node_modules/core-js/internals/to-primitive.js"),h=t("./node_modules/core-js/internals/fails.js"),u=t("./node_modules/core-js/internals/object-create.js"),p=t("./node_modules/core-js/internals/object-get-own-property-names.js").f,f=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f,m=t("./node_modules/core-js/internals/object-define-property.js").f,g=t("./node_modules/core-js/internals/string-trim.js").trim,y=r.Number,b=y.prototype,x="Number"==l(u(b)),v=function(e){var n,t,o,r,i,s,a,l,c=d(e,!1);if("string"==typeof c&&c.length>2)if(43===(n=(c=g(c)).charCodeAt(0))||45===n){if(88===(t=c.charCodeAt(2))||120===t)return NaN}else if(48===n){switch(c.charCodeAt(1)){case 66:case 98:o=2,r=49;break;case 79:case 111:o=8,r=55;break;default:return+c}for(s=(i=c.slice(2)).length,a=0;a<s;a++)if((l=i.charCodeAt(a))<48||l>r)return NaN;return parseInt(i,o)}return+c};if(i("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var j,w=function(e){var n=arguments.length<1?0:e,t=this;return t instanceof w&&(x?h(function(){b.valueOf.call(t)}):"Number"!=l(t))?c(new y(v(n)),t,w):v(n)},k=o?p(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),_=0;k.length>_;_++)a(y,j=k[_])&&!a(w,j)&&m(w,j,f(y,j));w.prototype=b,b.constructor=w,s(r,"Number",w)}},"./node_modules/core-js/modules/es.number.epsilon.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{EPSILON:Math.pow(2,-52)})},"./node_modules/core-js/modules/es.number.is-finite.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{isFinite:t("./node_modules/core-js/internals/number-is-finite.js")})},"./node_modules/core-js/modules/es.number.is-integer.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{isInteger:t("./node_modules/core-js/internals/is-integer.js")})},"./node_modules/core-js/modules/es.number.is-nan.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{isNaN:function(e){return e!=e}})},"./node_modules/core-js/modules/es.number.is-safe-integer.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-integer.js"),i=Math.abs;o({target:"Number",stat:!0},{isSafeInteger:function(e){return r(e)&&i(e)<=9007199254740991}})},"./node_modules/core-js/modules/es.number.max-safe-integer.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{MAX_SAFE_INTEGER:9007199254740991})},"./node_modules/core-js/modules/es.number.min-safe-integer.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Number",stat:!0},{MIN_SAFE_INTEGER:-9007199254740991})},"./node_modules/core-js/modules/es.number.parse-float.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/parse-float.js");o({target:"Number",stat:!0,forced:Number.parseFloat!=r},{parseFloat:r})},"./node_modules/core-js/modules/es.number.parse-int.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/parse-int.js");o({target:"Number",stat:!0,forced:Number.parseInt!=r},{parseInt:r})},"./node_modules/core-js/modules/es.number.to-fixed.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-integer.js"),i=t("./node_modules/core-js/internals/this-number-value.js"),s=t("./node_modules/core-js/internals/string-repeat.js"),a=t("./node_modules/core-js/internals/fails.js"),l=1..toFixed,c=Math.floor,d=function(e,n,t){return 0===n?t:n%2==1?d(e,n-1,t*e):d(e*e,n/2,t)};o({target:"Number",proto:!0,forced:l&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!a(function(){l.call({})})},{toFixed:function(e){var n,t,o,a,l=i(this),h=r(e),u=[0,0,0,0,0,0],p="",f="0",m=function(e,n){for(var t=-1,o=n;++t<6;)o+=e*u[t],u[t]=o%1e7,o=c(o/1e7)},g=function(e){for(var n=6,t=0;--n>=0;)t+=u[n],u[n]=c(t/e),t=t%e*1e7},y=function(){for(var e=6,n="";--e>=0;)if(""!==n||0===e||0!==u[e]){var t=String(u[e]);n=""===n?t:n+s.call("0",7-t.length)+t}return n};if(h<0||h>20)throw RangeError("Incorrect fraction digits");if(l!=l)return"NaN";if(l<=-1e21||l>=1e21)return String(l);if(l<0&&(p="-",l=-l),l>1e-21)if(t=(n=function(e){for(var n=0,t=e;t>=4096;)n+=12,t/=4096;for(;t>=2;)n+=1,t/=2;return n}(l*d(2,69,1))-69)<0?l*d(2,-n,1):l/d(2,n,1),t*=4503599627370496,(n=52-n)>0){for(m(0,t),o=h;o>=7;)m(1e7,0),o-=7;for(m(d(10,o,1),0),o=n-1;o>=23;)g(1<<23),o-=23;g(1<<o),m(1,1),g(2),f=y()}else m(0,t),m(1<<-n,0),f=y()+s.call("0",h);return f=h>0?p+((a=f.length)<=h?"0."+s.call("0",h-a)+f:f.slice(0,a-h)+"."+f.slice(a-h)):p+f}})},"./node_modules/core-js/modules/es.number.to-precision.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/this-number-value.js"),s=1..toPrecision;o({target:"Number",proto:!0,forced:r(function(){return"1"!==s.call(1,void 0)})||!r(function(){s.call({})})},{toPrecision:function(e){return void 0===e?s.call(i(this)):s.call(i(this),e)}})},"./node_modules/core-js/modules/es.object.assign.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/object-assign.js");o({target:"Object",stat:!0,forced:Object.assign!==r},{assign:r})},"./node_modules/core-js/modules/es.object.define-getter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js"),s=t("./node_modules/core-js/internals/to-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/object-define-property.js");r&&o({target:"Object",proto:!0,forced:i},{__defineGetter__:function(e,n){l.f(s(this),e,{get:a(n),enumerable:!0,configurable:!0})}})},"./node_modules/core-js/modules/es.object.define-setter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js"),s=t("./node_modules/core-js/internals/to-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/object-define-property.js");r&&o({target:"Object",proto:!0,forced:i},{__defineSetter__:function(e,n){l.f(s(this),e,{set:a(n),enumerable:!0,configurable:!0})}})},"./node_modules/core-js/modules/es.object.entries.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/object-to-array.js").entries;o({target:"Object",stat:!0},{entries:function(e){return r(e)}})},"./node_modules/core-js/modules/es.object.freeze.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/freezing.js"),i=t("./node_modules/core-js/internals/fails.js"),s=t("./node_modules/core-js/internals/is-object.js"),a=t("./node_modules/core-js/internals/internal-metadata.js").onFreeze,l=Object.freeze;o({target:"Object",stat:!0,forced:i(function(){l(1)}),sham:!r},{freeze:function(e){return l&&s(e)?l(a(e)):e}})},"./node_modules/core-js/modules/es.object.from-entries.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/iterate.js"),i=t("./node_modules/core-js/internals/create-property.js");o({target:"Object",stat:!0},{fromEntries:function(e){var n={};return r(e,function(e,t){i(n,e,t)},void 0,!0),n}})},"./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/to-indexed-object.js"),s=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f,a=t("./node_modules/core-js/internals/descriptors.js"),l=r(function(){s(1)});o({target:"Object",stat:!0,forced:!a||l,sham:!a},{getOwnPropertyDescriptor:function(e,n){return s(i(e),n)}})},"./node_modules/core-js/modules/es.object.get-own-property-descriptors.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/own-keys.js"),s=t("./node_modules/core-js/internals/to-indexed-object.js"),a=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),l=t("./node_modules/core-js/internals/create-property.js");o({target:"Object",stat:!0,sham:!r},{getOwnPropertyDescriptors:function(e){for(var n,t,o=s(e),r=a.f,c=i(o),d={},h=0;c.length>h;)void 0!==(t=r(o,n=c[h++]))&&l(d,n,t);return d}})},"./node_modules/core-js/modules/es.object.get-own-property-names.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/object-get-own-property-names-external.js").f;o({target:"Object",stat:!0,forced:r(function(){return!Object.getOwnPropertyNames(1)})},{getOwnPropertyNames:i})},"./node_modules/core-js/modules/es.object.get-prototype-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/object-get-prototype-of.js"),a=t("./node_modules/core-js/internals/correct-prototype-getter.js");o({target:"Object",stat:!0,forced:r(function(){s(1)}),sham:!a},{getPrototypeOf:function(e){return s(i(e))}})},"./node_modules/core-js/modules/es.object.is-extensible.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/is-object.js"),s=Object.isExtensible;o({target:"Object",stat:!0,forced:r(function(){s(1)})},{isExtensible:function(e){return!!i(e)&&(!s||s(e))}})},"./node_modules/core-js/modules/es.object.is-frozen.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/is-object.js"),s=Object.isFrozen;o({target:"Object",stat:!0,forced:r(function(){s(1)})},{isFrozen:function(e){return!i(e)||!!s&&s(e)}})},"./node_modules/core-js/modules/es.object.is-sealed.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/fails.js"),i=t("./node_modules/core-js/internals/is-object.js"),s=Object.isSealed;o({target:"Object",stat:!0,forced:r(function(){s(1)})},{isSealed:function(e){return!i(e)||!!s&&s(e)}})},"./node_modules/core-js/modules/es.object.is.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Object",stat:!0},{is:t("./node_modules/core-js/internals/same-value.js")})},"./node_modules/core-js/modules/es.object.keys.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-object.js"),i=t("./node_modules/core-js/internals/object-keys.js");o({target:"Object",stat:!0,forced:t("./node_modules/core-js/internals/fails.js")(function(){i(1)})},{keys:function(e){return i(r(e))}})},"./node_modules/core-js/modules/es.object.lookup-getter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js"),s=t("./node_modules/core-js/internals/to-object.js"),a=t("./node_modules/core-js/internals/to-primitive.js"),l=t("./node_modules/core-js/internals/object-get-prototype-of.js"),c=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;r&&o({target:"Object",proto:!0,forced:i},{__lookupGetter__:function(e){var n,t=s(this),o=a(e,!0);do{if(n=c(t,o))return n.get}while(t=l(t))}})},"./node_modules/core-js/modules/es.object.lookup-setter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js"),s=t("./node_modules/core-js/internals/to-object.js"),a=t("./node_modules/core-js/internals/to-primitive.js"),l=t("./node_modules/core-js/internals/object-get-prototype-of.js"),c=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;r&&o({target:"Object",proto:!0,forced:i},{__lookupSetter__:function(e){var n,t=s(this),o=a(e,!0);do{if(n=c(t,o))return n.set}while(t=l(t))}})},"./node_modules/core-js/modules/es.object.prevent-extensions.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/internal-metadata.js").onFreeze,s=t("./node_modules/core-js/internals/freezing.js"),a=t("./node_modules/core-js/internals/fails.js"),l=Object.preventExtensions;o({target:"Object",stat:!0,forced:a(function(){l(1)}),sham:!s},{preventExtensions:function(e){return l&&r(e)?l(i(e)):e}})},"./node_modules/core-js/modules/es.object.seal.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/internal-metadata.js").onFreeze,s=t("./node_modules/core-js/internals/freezing.js"),a=t("./node_modules/core-js/internals/fails.js"),l=Object.seal;o({target:"Object",stat:!0,forced:a(function(){l(1)}),sham:!s},{seal:function(e){return l&&r(e)?l(i(e)):e}})},"./node_modules/core-js/modules/es.object.set-prototype-of.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Object",stat:!0},{setPrototypeOf:t("./node_modules/core-js/internals/object-set-prototype-of.js")})},"./node_modules/core-js/modules/es.object.to-string.js":function(e,n,t){var o=t("./node_modules/core-js/internals/redefine.js"),r=t("./node_modules/core-js/internals/object-to-string.js"),i=Object.prototype;r!==i.toString&&o(i,"toString",r,{unsafe:!0})},"./node_modules/core-js/modules/es.object.values.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/object-to-array.js").values;o({target:"Object",stat:!0},{values:function(e){return r(e)}})},"./node_modules/core-js/modules/es.parse-float.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/parse-float.js");o({global:!0,forced:parseFloat!=r},{parseFloat:r})},"./node_modules/core-js/modules/es.parse-int.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/parse-int.js");o({global:!0,forced:parseInt!=r},{parseInt:r})},"./node_modules/core-js/modules/es.promise.all-settled.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/a-function.js"),i=t("./node_modules/core-js/internals/new-promise-capability.js"),s=t("./node_modules/core-js/internals/perform.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Promise",stat:!0},{allSettled:function(e){var n=this,t=i.f(n),o=t.resolve,l=t.reject,c=s(function(){var t=r(n.resolve),i=[],s=0,l=1;a(e,function(e){var r=s++,a=!1;i.push(void 0),l++,t.call(n,e).then(function(e){a||(a=!0,i[r]={status:"fulfilled",value:e},--l||o(i))},function(e){a||(a=!0,i[r]={status:"rejected",reason:e},--l||o(i))})}),--l||o(i)});return c.error&&l(c.value),t.promise}})},"./node_modules/core-js/modules/es.promise.finally.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/native-promise-constructor.js"),s=t("./node_modules/core-js/internals/get-built-in.js"),a=t("./node_modules/core-js/internals/species-constructor.js"),l=t("./node_modules/core-js/internals/promise-resolve.js"),c=t("./node_modules/core-js/internals/redefine.js");o({target:"Promise",proto:!0,real:!0},{finally:function(e){var n=a(this,s("Promise")),t="function"==typeof e;return this.then(t?function(t){return l(n,e()).then(function(){return t})}:e,t?function(t){return l(n,e()).then(function(){throw t})}:e)}}),r||"function"!=typeof i||i.prototype.finally||c(i.prototype,"finally",s("Promise").prototype.finally)},"./node_modules/core-js/modules/es.promise.js":function(e,n,t){"use strict";var o,r,i,s,a=t("./node_modules/core-js/internals/export.js"),l=t("./node_modules/core-js/internals/is-pure.js"),c=t("./node_modules/core-js/internals/global.js"),d=t("./node_modules/core-js/internals/path.js"),h=t("./node_modules/core-js/internals/native-promise-constructor.js"),u=t("./node_modules/core-js/internals/redefine.js"),p=t("./node_modules/core-js/internals/redefine-all.js"),f=t("./node_modules/core-js/internals/set-to-string-tag.js"),m=t("./node_modules/core-js/internals/set-species.js"),g=t("./node_modules/core-js/internals/is-object.js"),y=t("./node_modules/core-js/internals/a-function.js"),b=t("./node_modules/core-js/internals/an-instance.js"),x=t("./node_modules/core-js/internals/classof-raw.js"),v=t("./node_modules/core-js/internals/iterate.js"),j=t("./node_modules/core-js/internals/check-correctness-of-iteration.js"),w=t("./node_modules/core-js/internals/species-constructor.js"),k=t("./node_modules/core-js/internals/task.js").set,_=t("./node_modules/core-js/internals/microtask.js"),S=t("./node_modules/core-js/internals/promise-resolve.js"),C=t("./node_modules/core-js/internals/host-report-errors.js"),A=t("./node_modules/core-js/internals/new-promise-capability.js"),T=t("./node_modules/core-js/internals/perform.js"),O=t("./node_modules/core-js/internals/user-agent.js"),P=t("./node_modules/core-js/internals/internal-state.js"),M=t("./node_modules/core-js/internals/is-forced.js"),L=t("./node_modules/core-js/internals/well-known-symbol.js")("species"),H="Promise",I=P.get,D=P.set,E=P.getterFor(H),B=h,R=c.TypeError,N=c.document,z=c.process,G=c.fetch,W=z&&z.versions,F=W&&W.v8||"",X=A.f,V=X,Y="process"==x(z),U=!!(N&&N.createEvent&&c.dispatchEvent),q=M(H,function(){var e=B.resolve(1),n=function(){},t=(e.constructor={})[L]=function(e){e(n,n)};return!((Y||"function"==typeof PromiseRejectionEvent)&&(!l||e.finally)&&e.then(n)instanceof t&&0!==F.indexOf("6.6")&&-1===O.indexOf("Chrome/66"))}),K=q||!j(function(e){B.all(e).catch(function(){})}),$=function(e){var n;return!(!g(e)||"function"!=typeof(n=e.then))&&n},Z=function(e,n,t){if(!n.notified){n.notified=!0;var o=n.reactions;_(function(){for(var r=n.value,i=1==n.state,s=0;o.length>s;){var a,l,c,d=o[s++],h=i?d.ok:d.fail,u=d.resolve,p=d.reject,f=d.domain;try{h?(i||(2===n.rejection&&ne(e,n),n.rejection=1),!0===h?a=r:(f&&f.enter(),a=h(r),f&&(f.exit(),c=!0)),a===d.promise?p(R("Promise-chain cycle")):(l=$(a))?l.call(a,u,p):u(a)):p(r)}catch(e){f&&!c&&f.exit(),p(e)}}n.reactions=[],n.notified=!1,t&&!n.rejection&&Q(e,n)})}},J=function(e,n,t){var o,r;U?((o=N.createEvent("Event")).promise=n,o.reason=t,o.initEvent(e,!1,!0),c.dispatchEvent(o)):o={promise:n,reason:t},(r=c["on"+e])?r(o):"unhandledrejection"===e&&C("Unhandled promise rejection",t)},Q=function(e,n){k.call(c,function(){var t,o=n.value;if(ee(n)&&(t=T(function(){Y?z.emit("unhandledRejection",o,e):J("unhandledrejection",e,o)}),n.rejection=Y||ee(n)?2:1,t.error))throw t.value})},ee=function(e){return 1!==e.rejection&&!e.parent},ne=function(e,n){k.call(c,function(){Y?z.emit("rejectionHandled",e):J("rejectionhandled",e,n.value)})},te=function(e,n,t,o){return function(r){e(n,t,r,o)}},oe=function(e,n,t,o){n.done||(n.done=!0,o&&(n=o),n.value=t,n.state=2,Z(e,n,!0))},re=function(e,n,t,o){if(!n.done){n.done=!0,o&&(n=o);try{if(e===t)throw R("Promise can't be resolved itself");var r=$(t);r?_(function(){var o={done:!1};try{r.call(t,te(re,e,o,n),te(oe,e,o,n))}catch(t){oe(e,o,t,n)}}):(n.value=t,n.state=1,Z(e,n,!1))}catch(t){oe(e,{done:!1},t,n)}}};q&&(B=function(e){b(this,B,H),y(e),o.call(this);var n=I(this);try{e(te(re,this,n),te(oe,this,n))}catch(e){oe(this,n,e)}},(o=function(e){D(this,{type:H,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=p(B.prototype,{then:function(e,n){var t=E(this),o=X(w(this,B));return o.ok="function"!=typeof e||e,o.fail="function"==typeof n&&n,o.domain=Y?z.domain:void 0,t.parent=!0,t.reactions.push(o),0!=t.state&&Z(this,t,!1),o.promise},catch:function(e){return this.then(void 0,e)}}),r=function(){var e=new o,n=I(e);this.promise=e,this.resolve=te(re,e,n),this.reject=te(oe,e,n)},A.f=X=function(e){return e===B||e===i?new r(e):V(e)},l||"function"!=typeof h||(s=h.prototype.then,u(h.prototype,"then",function(e,n){var t=this;return new B(function(e,n){s.call(t,e,n)}).then(e,n)}),"function"==typeof G&&a({global:!0,enumerable:!0,forced:!0},{fetch:function(e){return S(B,G.apply(c,arguments))}}))),a({global:!0,wrap:!0,forced:q},{Promise:B}),f(B,H,!1,!0),m(H),i=d.Promise,a({target:H,stat:!0,forced:q},{reject:function(e){var n=X(this);return n.reject.call(void 0,e),n.promise}}),a({target:H,stat:!0,forced:l||q},{resolve:function(e){return S(l&&this===i?B:this,e)}}),a({target:H,stat:!0,forced:K},{all:function(e){var n=this,t=X(n),o=t.resolve,r=t.reject,i=T(function(){var t=y(n.resolve),i=[],s=0,a=1;v(e,function(e){var l=s++,c=!1;i.push(void 0),a++,t.call(n,e).then(function(e){c||(c=!0,i[l]=e,--a||o(i))},r)}),--a||o(i)});return i.error&&r(i.value),t.promise},race:function(e){var n=this,t=X(n),o=t.reject,r=T(function(){var r=y(n.resolve);v(e,function(e){r.call(n,e).then(t.resolve,o)})});return r.error&&o(r.value),t.promise}})},"./node_modules/core-js/modules/es.reflect.apply.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/get-built-in.js"),i=t("./node_modules/core-js/internals/a-function.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/fails.js"),l=r("Reflect","apply"),c=Function.apply;o({target:"Reflect",stat:!0,forced:!a(function(){l(function(){})})},{apply:function(e,n,t){return i(e),s(t),l?l(e,n,t):c.call(e,n,t)}})},"./node_modules/core-js/modules/es.reflect.construct.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/get-built-in.js"),i=t("./node_modules/core-js/internals/a-function.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/is-object.js"),l=t("./node_modules/core-js/internals/object-create.js"),c=t("./node_modules/core-js/internals/function-bind.js"),d=t("./node_modules/core-js/internals/fails.js"),h=r("Reflect","construct"),u=d(function(){function e(){}return!(h(function(){},[],e)instanceof e)}),p=!d(function(){h(function(){})}),f=u||p;o({target:"Reflect",stat:!0,forced:f,sham:f},{construct:function(e,n){i(e),s(n);var t=arguments.length<3?e:i(arguments[2]);if(p&&!u)return h(e,n,t);if(e==t){switch(n.length){case 0:return new e;case 1:return new e(n[0]);case 2:return new e(n[0],n[1]);case 3:return new e(n[0],n[1],n[2]);case 4:return new e(n[0],n[1],n[2],n[3])}var o=[null];return o.push.apply(o,n),new(c.apply(e,o))}var r=t.prototype,d=l(a(r)?r:Object.prototype),f=Function.apply.call(e,d,n);return a(f)?f:d}})},"./node_modules/core-js/modules/es.reflect.define-property.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/to-primitive.js"),a=t("./node_modules/core-js/internals/object-define-property.js");o({target:"Reflect",stat:!0,forced:t("./node_modules/core-js/internals/fails.js")(function(){Reflect.defineProperty(a.f({},1,{value:1}),1,{value:2})}),sham:!r},{defineProperty:function(e,n,t){i(e);var o=s(n,!0);i(t);try{return a.f(e,o,t),!0}catch(e){return!1}}})},"./node_modules/core-js/modules/es.reflect.delete-property.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;o({target:"Reflect",stat:!0},{deleteProperty:function(e,n){var t=i(r(e),n);return!(t&&!t.configurable)&&delete e[n]}})},"./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js");o({target:"Reflect",stat:!0,sham:!r},{getOwnPropertyDescriptor:function(e,n){return s.f(i(e),n)}})},"./node_modules/core-js/modules/es.reflect.get-prototype-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/object-get-prototype-of.js");o({target:"Reflect",stat:!0,sham:!t("./node_modules/core-js/internals/correct-prototype-getter.js")},{getPrototypeOf:function(e){return i(r(e))}})},"./node_modules/core-js/modules/es.reflect.get.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-object.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/has.js"),a=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),l=t("./node_modules/core-js/internals/object-get-prototype-of.js");o({target:"Reflect",stat:!0},{get:function e(n,t){var o,c,d=arguments.length<3?n:arguments[2];return i(n)===d?n[t]:(o=a.f(n,t))?s(o,"value")?o.value:void 0===o.get?void 0:o.get.call(d):r(c=l(n))?e(c,t,d):void 0}})},"./node_modules/core-js/modules/es.reflect.has.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Reflect",stat:!0},{has:function(e,n){return n in e}})},"./node_modules/core-js/modules/es.reflect.is-extensible.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=Object.isExtensible;o({target:"Reflect",stat:!0},{isExtensible:function(e){return r(e),!i||i(e)}})},"./node_modules/core-js/modules/es.reflect.own-keys.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Reflect",stat:!0},{ownKeys:t("./node_modules/core-js/internals/own-keys.js")})},"./node_modules/core-js/modules/es.reflect.prevent-extensions.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/get-built-in.js"),i=t("./node_modules/core-js/internals/an-object.js");o({target:"Reflect",stat:!0,sham:!t("./node_modules/core-js/internals/freezing.js")},{preventExtensions:function(e){i(e);try{var n=r("Object","preventExtensions");return n&&n(e),!0}catch(e){return!1}}})},"./node_modules/core-js/modules/es.reflect.set-prototype-of.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/a-possible-prototype.js"),s=t("./node_modules/core-js/internals/object-set-prototype-of.js");s&&o({target:"Reflect",stat:!0},{setPrototypeOf:function(e,n){r(e),i(n);try{return s(e,n),!0}catch(e){return!1}}})},"./node_modules/core-js/modules/es.reflect.set.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/is-object.js"),s=t("./node_modules/core-js/internals/has.js"),a=t("./node_modules/core-js/internals/object-define-property.js"),l=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),c=t("./node_modules/core-js/internals/object-get-prototype-of.js"),d=t("./node_modules/core-js/internals/create-property-descriptor.js");o({target:"Reflect",stat:!0},{set:function e(n,t,o){var h,u,p=arguments.length<4?n:arguments[3],f=l.f(r(n),t);if(!f){if(i(u=c(n)))return e(u,t,o,p);f=d(0)}if(s(f,"value")){if(!1===f.writable||!i(p))return!1;if(h=l.f(p,t)){if(h.get||h.set||!1===h.writable)return!1;h.value=o,a.f(p,t,h)}else a.f(p,t,d(0,o));return!0}return void 0!==f.set&&(f.set.call(p,o),!0)}})},"./node_modules/core-js/modules/es.regexp.constructor.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/is-forced.js"),s=t("./node_modules/core-js/internals/inherit-if-required.js"),a=t("./node_modules/core-js/internals/object-define-property.js").f,l=t("./node_modules/core-js/internals/object-get-own-property-names.js").f,c=t("./node_modules/core-js/internals/is-regexp.js"),d=t("./node_modules/core-js/internals/regexp-flags.js"),h=t("./node_modules/core-js/internals/redefine.js"),u=t("./node_modules/core-js/internals/fails.js"),p=t("./node_modules/core-js/internals/set-species.js"),f=t("./node_modules/core-js/internals/well-known-symbol.js")("match"),m=r.RegExp,g=m.prototype,y=/a/g,b=/a/g,x=new m(y)!==y;if(o&&i("RegExp",!x||u(function(){return b[f]=!1,m(y)!=y||m(b)==b||"/a/i"!=m(y,"i")}))){for(var v=function(e,n){var t=this instanceof v,o=c(e),r=void 0===n;return!t&&o&&e.constructor===v&&r?e:s(x?new m(o&&!r?e.source:e,n):m((o=e instanceof v)?e.source:e,o&&r?d.call(e):n),t?this:g,v)},j=function(e){e in v||a(v,e,{configurable:!0,get:function(){return m[e]},set:function(n){m[e]=n}})},w=l(m),k=0;w.length>k;)j(w[k++]);g.constructor=v,v.prototype=g,h(r,"RegExp",v)}p("RegExp")},"./node_modules/core-js/modules/es.regexp.exec.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/regexp-exec.js");o({target:"RegExp",proto:!0,forced:/./.exec!==r},{exec:r})},"./node_modules/core-js/modules/es.regexp.flags.js":function(e,n,t){var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/object-define-property.js"),i=t("./node_modules/core-js/internals/regexp-flags.js");o&&"g"!=/./g.flags&&r.f(RegExp.prototype,"flags",{configurable:!0,get:i})},"./node_modules/core-js/modules/es.regexp.to-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/redefine.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/fails.js"),s=t("./node_modules/core-js/internals/regexp-flags.js"),a=RegExp.prototype,l=a.toString,c=i(function(){return"/a/b"!=l.call({source:"a",flags:"b"})}),d="toString"!=l.name;(c||d)&&o(RegExp.prototype,"toString",function(){var e=r(this),n=String(e.source),t=e.flags;return"/"+n+"/"+String(void 0===t&&e instanceof RegExp&&!("flags"in a)?s.call(e):t)},{unsafe:!0})},"./node_modules/core-js/modules/es.set.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/collection.js"),r=t("./node_modules/core-js/internals/collection-strong.js");e.exports=o("Set",function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},r)},"./node_modules/core-js/modules/es.string.anchor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("anchor")},{anchor:function(e){return r(this,"a","name",e)}})},"./node_modules/core-js/modules/es.string.big.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("big")},{big:function(){return r(this,"big","","")}})},"./node_modules/core-js/modules/es.string.blink.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("blink")},{blink:function(){return r(this,"blink","","")}})},"./node_modules/core-js/modules/es.string.bold.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("bold")},{bold:function(){return r(this,"b","","")}})},"./node_modules/core-js/modules/es.string.code-point-at.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-multibyte.js").codeAt;o({target:"String",proto:!0},{codePointAt:function(e){return r(this,e)}})},"./node_modules/core-js/modules/es.string.ends-with.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/not-a-regexp.js"),s=t("./node_modules/core-js/internals/require-object-coercible.js"),a=t("./node_modules/core-js/internals/correct-is-regexp-logic.js"),l="".endsWith,c=Math.min;o({target:"String",proto:!0,forced:!a("endsWith")},{endsWith:function(e){var n=String(s(this));i(e);var t=arguments.length>1?arguments[1]:void 0,o=r(n.length),a=void 0===t?o:c(r(t),o),d=String(e);return l?l.call(n,d,a):n.slice(a-d.length,a)===d}})},"./node_modules/core-js/modules/es.string.fixed.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("fixed")},{fixed:function(){return r(this,"tt","","")}})},"./node_modules/core-js/modules/es.string.fontcolor.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("fontcolor")},{fontcolor:function(e){return r(this,"font","color",e)}})},"./node_modules/core-js/modules/es.string.fontsize.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("fontsize")},{fontsize:function(e){return r(this,"font","size",e)}})},"./node_modules/core-js/modules/es.string.from-code-point.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-absolute-index.js"),i=String.fromCharCode,s=String.fromCodePoint;o({target:"String",stat:!0,forced:!!s&&1!=s.length},{fromCodePoint:function(e){for(var n,t=[],o=arguments.length,s=0;o>s;){if(n=+arguments[s++],r(n,1114111)!==n)throw RangeError(n+" is not a valid code point");t.push(n<65536?i(n):i(55296+((n-=65536)>>10),n%1024+56320))}return t.join("")}})},"./node_modules/core-js/modules/es.string.includes.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/not-a-regexp.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js");o({target:"String",proto:!0,forced:!t("./node_modules/core-js/internals/correct-is-regexp-logic.js")("includes")},{includes:function(e){return!!~String(i(this)).indexOf(r(e),arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.string.italics.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("italics")},{italics:function(){return r(this,"i","","")}})},"./node_modules/core-js/modules/es.string.iterator.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/string-multibyte.js").charAt,r=t("./node_modules/core-js/internals/internal-state.js"),i=t("./node_modules/core-js/internals/define-iterator.js"),s=r.set,a=r.getterFor("String Iterator");i(String,"String",function(e){s(this,{type:"String Iterator",string:String(e),index:0})},function(){var e,n=a(this),t=n.string,r=n.index;return r>=t.length?{value:void 0,done:!0}:(e=o(t,r),n.index+=e.length,{value:e,done:!1})})},"./node_modules/core-js/modules/es.string.link.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("link")},{link:function(e){return r(this,"a","href",e)}})},"./node_modules/core-js/modules/es.string.match-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-iterator-constructor.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/an-object.js"),c=t("./node_modules/core-js/internals/classof.js"),d=t("./node_modules/core-js/internals/regexp-flags.js"),h=t("./node_modules/core-js/internals/hide.js"),u=t("./node_modules/core-js/internals/well-known-symbol.js"),p=t("./node_modules/core-js/internals/species-constructor.js"),f=t("./node_modules/core-js/internals/advance-string-index.js"),m=t("./node_modules/core-js/internals/internal-state.js"),g=t("./node_modules/core-js/internals/is-pure.js"),y=u("matchAll"),b=m.set,x=m.getterFor("RegExp String Iterator"),v=RegExp.prototype,j=v.exec,w=r(function(e,n,t,o){b(this,{type:"RegExp String Iterator",regexp:e,string:n,global:t,unicode:o,done:!1})},"RegExp String",function(){var e=x(this);if(e.done)return{value:void 0,done:!0};var n=e.regexp,t=e.string,o=function(e,n){var t,o=e.exec;if("function"==typeof o){if("object"!=typeof(t=o.call(e,n)))throw TypeError("Incorrect exec result");return t}return j.call(e,n)}(n,t);return null===o?{value:void 0,done:e.done=!0}:e.global?(""==String(o[0])&&(n.lastIndex=f(t,s(n.lastIndex),e.unicode)),{value:o,done:!1}):(e.done=!0,{value:o,done:!1})}),k=function(e){var n,t,o,r,i,a,c=l(this),h=String(e);return n=p(c,RegExp),void 0===(t=c.flags)&&c instanceof RegExp&&!("flags"in v)&&(t=d.call(c)),o=void 0===t?"":String(t),r=new n(n===RegExp?c.source:c,o),i=!!~o.indexOf("g"),a=!!~o.indexOf("u"),r.lastIndex=s(c.lastIndex),new w(r,h,i,a)};o({target:"String",proto:!0},{matchAll:function(e){var n,t,o,r=i(this);return null!=e&&(void 0===(t=e[y])&&g&&"RegExp"==c(e)&&(t=k),null!=t)?a(t).call(e,r):(n=String(r),o=new RegExp(e,"g"),g?k.call(o,n):o[y](n))}}),g||y in v||h(v,y,k)},"./node_modules/core-js/modules/es.string.match.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/to-length.js"),s=t("./node_modules/core-js/internals/require-object-coercible.js"),a=t("./node_modules/core-js/internals/advance-string-index.js"),l=t("./node_modules/core-js/internals/regexp-exec-abstract.js");o("match",1,function(e,n,t){return[function(n){var t=s(this),o=null==n?void 0:n[e];return void 0!==o?o.call(n,t):new RegExp(n)[e](String(t))},function(e){var o=t(n,e,this);if(o.done)return o.value;var s=r(e),c=String(this);if(!s.global)return l(s,c);var d=s.unicode;s.lastIndex=0;for(var h,u=[],p=0;null!==(h=l(s,c));){var f=String(h[0]);u[p]=f,""===f&&(s.lastIndex=a(c,i(s.lastIndex),d)),p++}return 0===p?null:u}]})},"./node_modules/core-js/modules/es.string.pad-end.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-pad.js").end;o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/webkit-string-pad-bug.js")},{padEnd:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.string.pad-start.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-pad.js").start;o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/webkit-string-pad-bug.js")},{padStart:function(e){return r(this,e,arguments.length>1?arguments[1]:void 0)}})},"./node_modules/core-js/modules/es.string.raw.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-indexed-object.js"),i=t("./node_modules/core-js/internals/to-length.js");o({target:"String",stat:!0},{raw:function(e){for(var n=r(e.raw),t=i(n.length),o=arguments.length,s=[],a=0;t>a;)s.push(String(n[a++])),a<o&&s.push(String(arguments[a]));return s.join("")}})},"./node_modules/core-js/modules/es.string.repeat.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"String",proto:!0},{repeat:t("./node_modules/core-js/internals/string-repeat.js")})},"./node_modules/core-js/modules/es.string.replace.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/to-integer.js"),l=t("./node_modules/core-js/internals/require-object-coercible.js"),c=t("./node_modules/core-js/internals/advance-string-index.js"),d=t("./node_modules/core-js/internals/regexp-exec-abstract.js"),h=Math.max,u=Math.min,p=Math.floor,f=/\$([$&'`]|\d\d?|<[^>]*>)/g,m=/\$([$&'`]|\d\d?)/g;o("replace",2,function(e,n,t){return[function(t,o){var r=l(this),i=null==t?void 0:t[e];return void 0!==i?i.call(t,r,o):n.call(String(r),t,o)},function(e,i){var l=t(n,e,this,i);if(l.done)return l.value;var p=r(e),f=String(this),m="function"==typeof i;m||(i=String(i));var g=p.global;if(g){var y=p.unicode;p.lastIndex=0}for(var b=[];;){var x=d(p,f);if(null===x)break;if(b.push(x),!g)break;""===String(x[0])&&(p.lastIndex=c(f,s(p.lastIndex),y))}for(var v,j="",w=0,k=0;k<b.length;k++){x=b[k];for(var _=String(x[0]),S=h(u(a(x.index),f.length),0),C=[],A=1;A<x.length;A++)C.push(void 0===(v=x[A])?v:String(v));var T=x.groups;if(m){var O=[_].concat(C,S,f);void 0!==T&&O.push(T);var P=String(i.apply(void 0,O))}else P=o(_,f,S,C,T,i);S>=w&&(j+=f.slice(w,S)+P,w=S+_.length)}return j+f.slice(w)}];function o(e,t,o,r,s,a){var l=o+e.length,c=r.length,d=m;return void 0!==s&&(s=i(s),d=f),n.call(a,d,function(n,i){var a;switch(i.charAt(0)){case"$":return"$";case"&":return e;case"`":return t.slice(0,o);case"'":return t.slice(l);case"<":a=s[i.slice(1,-1)];break;default:var d=+i;if(0===d)return n;if(d>c){var h=p(d/10);return 0===h?n:h<=c?void 0===r[h-1]?i.charAt(1):r[h-1]+i.charAt(1):n}a=r[d-1]}return void 0===a?"":a})}})},"./node_modules/core-js/modules/es.string.search.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js"),s=t("./node_modules/core-js/internals/same-value.js"),a=t("./node_modules/core-js/internals/regexp-exec-abstract.js");o("search",1,function(e,n,t){return[function(n){var t=i(this),o=null==n?void 0:n[e];return void 0!==o?o.call(n,t):new RegExp(n)[e](String(t))},function(e){var o=t(n,e,this);if(o.done)return o.value;var i=r(e),l=String(this),c=i.lastIndex;s(c,0)||(i.lastIndex=0);var d=a(i,l);return s(i.lastIndex,c)||(i.lastIndex=c),null===d?-1:d.index}]})},"./node_modules/core-js/modules/es.string.small.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("small")},{small:function(){return r(this,"small","","")}})},"./node_modules/core-js/modules/es.string.split.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"),r=t("./node_modules/core-js/internals/is-regexp.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/require-object-coercible.js"),a=t("./node_modules/core-js/internals/species-constructor.js"),l=t("./node_modules/core-js/internals/advance-string-index.js"),c=t("./node_modules/core-js/internals/to-length.js"),d=t("./node_modules/core-js/internals/regexp-exec-abstract.js"),h=t("./node_modules/core-js/internals/regexp-exec.js"),u=t("./node_modules/core-js/internals/fails.js"),p=[].push,f=Math.min,m=!u(function(){return!RegExp(4294967295,"y")});o("split",2,function(e,n,t){var o;return o="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,t){var o=String(s(this)),i=void 0===t?4294967295:t>>>0;if(0===i)return[];if(void 0===e)return[o];if(!r(e))return n.call(o,e,i);for(var a,l,c,d=[],u=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),f=0,m=new RegExp(e.source,u+"g");(a=h.call(m,o))&&!((l=m.lastIndex)>f&&(d.push(o.slice(f,a.index)),a.length>1&&a.index<o.length&&p.apply(d,a.slice(1)),c=a[0].length,f=l,d.length>=i));)m.lastIndex===a.index&&m.lastIndex++;return f===o.length?!c&&m.test("")||d.push(""):d.push(o.slice(f)),d.length>i?d.slice(0,i):d}:"0".split(void 0,0).length?function(e,t){return void 0===e&&0===t?[]:n.call(this,e,t)}:n,[function(n,t){var r=s(this),i=null==n?void 0:n[e];return void 0!==i?i.call(n,r,t):o.call(String(r),n,t)},function(e,r){var s=t(o,e,this,r,o!==n);if(s.done)return s.value;var h=i(e),u=String(this),p=a(h,RegExp),g=h.unicode,y=(h.ignoreCase?"i":"")+(h.multiline?"m":"")+(h.unicode?"u":"")+(m?"y":"g"),b=new p(m?h:"^(?:"+h.source+")",y),x=void 0===r?4294967295:r>>>0;if(0===x)return[];if(0===u.length)return null===d(b,u)?[u]:[];for(var v=0,j=0,w=[];j<u.length;){b.lastIndex=m?j:0;var k,_=d(b,m?u:u.slice(j));if(null===_||(k=f(c(b.lastIndex+(m?0:j)),u.length))===v)j=l(u,j,g);else{if(w.push(u.slice(v,j)),w.length===x)return w;for(var S=1;S<=_.length-1;S++)if(w.push(_[S]),w.length===x)return w;j=v=k}}return w.push(u.slice(v)),w}]},!m)},"./node_modules/core-js/modules/es.string.starts-with.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/not-a-regexp.js"),s=t("./node_modules/core-js/internals/require-object-coercible.js"),a=t("./node_modules/core-js/internals/correct-is-regexp-logic.js"),l="".startsWith,c=Math.min;o({target:"String",proto:!0,forced:!a("startsWith")},{startsWith:function(e){var n=String(s(this));i(e);var t=r(c(arguments.length>1?arguments[1]:void 0,n.length)),o=String(e);return l?l.call(n,o,t):n.slice(t,t+o.length)===o}})},"./node_modules/core-js/modules/es.string.strike.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("strike")},{strike:function(){return r(this,"strike","","")}})},"./node_modules/core-js/modules/es.string.sub.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("sub")},{sub:function(){return r(this,"sub","","")}})},"./node_modules/core-js/modules/es.string.sup.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-html.js");o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-html-method.js")("sup")},{sup:function(){return r(this,"sup","","")}})},"./node_modules/core-js/modules/es.string.trim-end.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-trim.js").end,i=t("./node_modules/core-js/internals/forced-string-trim-method.js")("trimEnd"),s=i?function(){return r(this)}:"".trimEnd;o({target:"String",proto:!0,forced:i},{trimEnd:s,trimRight:s})},"./node_modules/core-js/modules/es.string.trim-start.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-trim.js").start,i=t("./node_modules/core-js/internals/forced-string-trim-method.js")("trimStart"),s=i?function(){return r(this)}:"".trimStart;o({target:"String",proto:!0,forced:i},{trimStart:s,trimLeft:s})},"./node_modules/core-js/modules/es.string.trim.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-trim.js").trim;o({target:"String",proto:!0,forced:t("./node_modules/core-js/internals/forced-string-trim-method.js")("trim")},{trim:function(){return r(this)}})},"./node_modules/core-js/modules/es.symbol.async-iterator.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("asyncIterator")},"./node_modules/core-js/modules/es.symbol.description.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/global.js"),s=t("./node_modules/core-js/internals/has.js"),a=t("./node_modules/core-js/internals/is-object.js"),l=t("./node_modules/core-js/internals/object-define-property.js").f,c=t("./node_modules/core-js/internals/copy-constructor-properties.js"),d=i.Symbol;if(r&&"function"==typeof d&&(!("description"in d.prototype)||void 0!==d().description)){var h={},u=function(){var e=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),n=this instanceof u?new d(e):void 0===e?d():d(e);return""===e&&(h[n]=!0),n};c(u,d);var p=u.prototype=d.prototype;p.constructor=u;var f=p.toString,m="Symbol(test)"==String(d("test")),g=/^Symbol\((.*)\)[^)]+$/;l(p,"description",{configurable:!0,get:function(){var e=a(this)?this.valueOf():this,n=f.call(e);if(s(h,e))return"";var t=m?n.slice(7,-1):n.replace(g,"$1");return""===t?void 0:t}}),o({global:!0,forced:!0},{Symbol:u})}},"./node_modules/core-js/modules/es.symbol.has-instance.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("hasInstance")},"./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("isConcatSpreadable")},"./node_modules/core-js/modules/es.symbol.iterator.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("iterator")},"./node_modules/core-js/modules/es.symbol.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/is-pure.js"),s=t("./node_modules/core-js/internals/descriptors.js"),a=t("./node_modules/core-js/internals/native-symbol.js"),l=t("./node_modules/core-js/internals/fails.js"),c=t("./node_modules/core-js/internals/has.js"),d=t("./node_modules/core-js/internals/is-array.js"),h=t("./node_modules/core-js/internals/is-object.js"),u=t("./node_modules/core-js/internals/an-object.js"),p=t("./node_modules/core-js/internals/to-object.js"),f=t("./node_modules/core-js/internals/to-indexed-object.js"),m=t("./node_modules/core-js/internals/to-primitive.js"),g=t("./node_modules/core-js/internals/create-property-descriptor.js"),y=t("./node_modules/core-js/internals/object-create.js"),b=t("./node_modules/core-js/internals/object-keys.js"),x=t("./node_modules/core-js/internals/object-get-own-property-names.js"),v=t("./node_modules/core-js/internals/object-get-own-property-names-external.js"),j=t("./node_modules/core-js/internals/object-get-own-property-symbols.js"),w=t("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),k=t("./node_modules/core-js/internals/object-define-property.js"),_=t("./node_modules/core-js/internals/object-property-is-enumerable.js"),S=t("./node_modules/core-js/internals/hide.js"),C=t("./node_modules/core-js/internals/redefine.js"),A=t("./node_modules/core-js/internals/shared.js"),T=t("./node_modules/core-js/internals/shared-key.js"),O=t("./node_modules/core-js/internals/hidden-keys.js"),P=t("./node_modules/core-js/internals/uid.js"),M=t("./node_modules/core-js/internals/well-known-symbol.js"),L=t("./node_modules/core-js/internals/wrapped-well-known-symbol.js"),H=t("./node_modules/core-js/internals/define-well-known-symbol.js"),I=t("./node_modules/core-js/internals/set-to-string-tag.js"),D=t("./node_modules/core-js/internals/internal-state.js"),E=t("./node_modules/core-js/internals/array-iteration.js").forEach,B=T("hidden"),R=M("toPrimitive"),N=D.set,z=D.getterFor("Symbol"),G=Object.prototype,W=r.Symbol,F=r.JSON,X=F&&F.stringify,V=w.f,Y=k.f,U=v.f,q=_.f,K=A("symbols"),$=A("op-symbols"),Z=A("string-to-symbol-registry"),J=A("symbol-to-string-registry"),Q=A("wks"),ee=r.QObject,ne=!ee||!ee.prototype||!ee.prototype.findChild,te=s&&l(function(){return 7!=y(Y({},"a",{get:function(){return Y(this,"a",{value:7}).a}})).a})?function(e,n,t){var o=V(G,n);o&&delete G[n],Y(e,n,t),o&&e!==G&&Y(G,n,o)}:Y,oe=function(e,n){var t=K[e]=y(W.prototype);return N(t,{type:"Symbol",tag:e,description:n}),s||(t.description=n),t},re=a&&"symbol"==typeof W.iterator?function(e){return"symbol"==typeof e}:function(e){return Object(e)instanceof W},ie=function(e,n,t){e===G&&ie($,n,t),u(e);var o=m(n,!0);return u(t),c(K,o)?(t.enumerable?(c(e,B)&&e[B][o]&&(e[B][o]=!1),t=y(t,{enumerable:g(0,!1)})):(c(e,B)||Y(e,B,g(1,{})),e[B][o]=!0),te(e,o,t)):Y(e,o,t)},se=function(e,n){u(e);var t=f(n),o=b(t).concat(de(t));return E(o,function(n){s&&!ae.call(t,n)||ie(e,n,t[n])}),e},ae=function(e){var n=m(e,!0),t=q.call(this,n);return!(this===G&&c(K,n)&&!c($,n))&&(!(t||!c(this,n)||!c(K,n)||c(this,B)&&this[B][n])||t)},le=function(e,n){var t=f(e),o=m(n,!0);if(t!==G||!c(K,o)||c($,o)){var r=V(t,o);return!r||!c(K,o)||c(t,B)&&t[B][o]||(r.enumerable=!0),r}},ce=function(e){var n=U(f(e)),t=[];return E(n,function(e){c(K,e)||c(O,e)||t.push(e)}),t},de=function(e){var n=e===G,t=U(n?$:f(e)),o=[];return E(t,function(e){!c(K,e)||n&&!c(G,e)||o.push(K[e])}),o};a||(C((W=function(){if(this instanceof W)throw TypeError("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,n=P(e),t=function(e){this===G&&t.call($,e),c(this,B)&&c(this[B],n)&&(this[B][n]=!1),te(this,n,g(1,e))};return s&&ne&&te(G,n,{configurable:!0,set:t}),oe(n,e)}).prototype,"toString",function(){return z(this).tag}),_.f=ae,k.f=ie,w.f=le,x.f=v.f=ce,j.f=de,s&&(Y(W.prototype,"description",{configurable:!0,get:function(){return z(this).description}}),i||C(G,"propertyIsEnumerable",ae,{unsafe:!0})),L.f=function(e){return oe(M(e),e)}),o({global:!0,wrap:!0,forced:!a,sham:!a},{Symbol:W}),E(b(Q),function(e){H(e)}),o({target:"Symbol",stat:!0,forced:!a},{for:function(e){var n=String(e);if(c(Z,n))return Z[n];var t=W(n);return Z[n]=t,J[t]=n,t},keyFor:function(e){if(!re(e))throw TypeError(e+" is not a symbol");if(c(J,e))return J[e]},useSetter:function(){ne=!0},useSimple:function(){ne=!1}}),o({target:"Object",stat:!0,forced:!a,sham:!s},{create:function(e,n){return void 0===n?y(e):se(y(e),n)},defineProperty:ie,defineProperties:se,getOwnPropertyDescriptor:le}),o({target:"Object",stat:!0,forced:!a},{getOwnPropertyNames:ce,getOwnPropertySymbols:de}),o({target:"Object",stat:!0,forced:l(function(){j.f(1)})},{getOwnPropertySymbols:function(e){return j.f(p(e))}}),F&&o({target:"JSON",stat:!0,forced:!a||l(function(){var e=W();return"[null]"!=X([e])||"{}"!=X({a:e})||"{}"!=X(Object(e))})},{stringify:function(e){for(var n,t,o=[e],r=1;arguments.length>r;)o.push(arguments[r++]);if(t=n=o[1],(h(n)||void 0!==e)&&!re(e))return d(n)||(n=function(e,n){if("function"==typeof t&&(n=t.call(this,e,n)),!re(n))return n}),o[1]=n,X.apply(F,o)}}),W.prototype[R]||S(W.prototype,R,W.prototype.valueOf),I(W,"Symbol"),O[B]=!0},"./node_modules/core-js/modules/es.symbol.match-all.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("matchAll")},"./node_modules/core-js/modules/es.symbol.match.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("match")},"./node_modules/core-js/modules/es.symbol.replace.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("replace")},"./node_modules/core-js/modules/es.symbol.search.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("search")},"./node_modules/core-js/modules/es.symbol.species.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("species")},"./node_modules/core-js/modules/es.symbol.split.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("split")},"./node_modules/core-js/modules/es.symbol.to-primitive.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("toPrimitive")},"./node_modules/core-js/modules/es.symbol.to-string-tag.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("toStringTag")},"./node_modules/core-js/modules/es.symbol.unscopables.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("unscopables")},"./node_modules/core-js/modules/es.typed-array.copy-within.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-copy-within.js"),i=o.aTypedArray;o.exportProto("copyWithin",function(e,n){return r.call(i(this),e,n,arguments.length>2?arguments[2]:void 0)})},"./node_modules/core-js/modules/es.typed-array.every.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").every,i=o.aTypedArray;o.exportProto("every",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.fill.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-fill.js"),i=o.aTypedArray;o.exportProto("fill",function(e){return r.apply(i(this),arguments)})},"./node_modules/core-js/modules/es.typed-array.filter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").filter,i=t("./node_modules/core-js/internals/species-constructor.js"),s=o.aTypedArray,a=o.aTypedArrayConstructor;o.exportProto("filter",function(e){for(var n=r(s(this),e,arguments.length>1?arguments[1]:void 0),t=i(this,this.constructor),o=0,l=n.length,c=new(a(t))(l);l>o;)c[o]=n[o++];return c})},"./node_modules/core-js/modules/es.typed-array.find-index.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").findIndex,i=o.aTypedArray;o.exportProto("findIndex",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.find.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").find,i=o.aTypedArray;o.exportProto("find",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.float32-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Float32",4,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.float64-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Float64",8,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.for-each.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").forEach,i=o.aTypedArray;o.exportProto("forEach",function(e){r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.from.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js"),r=t("./node_modules/core-js/internals/array-buffer-view-core.js"),i=t("./node_modules/core-js/internals/typed-array-from.js");r.exportStatic("from",i,o)},"./node_modules/core-js/modules/es.typed-array.includes.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-includes.js").includes,i=o.aTypedArray;o.exportProto("includes",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.index-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-includes.js").indexOf,i=o.aTypedArray;o.exportProto("indexOf",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.int16-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Int16",2,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.int32-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Int32",4,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.int8-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Int8",1,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.iterator.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/array-buffer-view-core.js"),i=t("./node_modules/core-js/modules/es.array.iterator.js"),s=t("./node_modules/core-js/internals/well-known-symbol.js")("iterator"),a=o.Uint8Array,l=i.values,c=i.keys,d=i.entries,h=r.aTypedArray,u=r.exportProto,p=a&&a.prototype[s],f=!!p&&("values"==p.name||null==p.name),m=function(){return l.call(h(this))};u("entries",function(){return d.call(h(this))}),u("keys",function(){return c.call(h(this))}),u("values",m,!f),u(s,m,!f)},"./node_modules/core-js/modules/es.typed-array.join.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=o.aTypedArray,i=[].join;o.exportProto("join",function(e){return i.apply(r(this),arguments)})},"./node_modules/core-js/modules/es.typed-array.last-index-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-last-index-of.js"),i=o.aTypedArray;o.exportProto("lastIndexOf",function(e){return r.apply(i(this),arguments)})},"./node_modules/core-js/modules/es.typed-array.map.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").map,i=t("./node_modules/core-js/internals/species-constructor.js"),s=o.aTypedArray,a=o.aTypedArrayConstructor;o.exportProto("map",function(e){return r(s(this),e,arguments.length>1?arguments[1]:void 0,function(e,n){return new(a(i(e,e.constructor)))(n)})})},"./node_modules/core-js/modules/es.typed-array.of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js"),i=o.aTypedArrayConstructor;o.exportStatic("of",function(){for(var e=0,n=arguments.length,t=new(i(this))(n);n>e;)t[e]=arguments[e++];return t},r)},"./node_modules/core-js/modules/es.typed-array.reduce-right.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-reduce.js").right,i=o.aTypedArray;o.exportProto("reduceRight",function(e){return r(i(this),e,arguments.length,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.reduce.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-reduce.js").left,i=o.aTypedArray;o.exportProto("reduce",function(e){return r(i(this),e,arguments.length,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.reverse.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=o.aTypedArray,i=Math.floor;o.exportProto("reverse",function(){for(var e,n=r(this).length,t=i(n/2),o=0;o<t;)e=this[o],this[o++]=this[--n],this[n]=e;return this})},"./node_modules/core-js/modules/es.typed-array.set.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/to-offset.js"),s=t("./node_modules/core-js/internals/to-object.js"),a=t("./node_modules/core-js/internals/fails.js"),l=o.aTypedArray,c=a(function(){new Int8Array(1).set({})});o.exportProto("set",function(e){l(this);var n=i(arguments.length>1?arguments[1]:void 0,1),t=this.length,o=s(e),a=r(o.length),c=0;if(a+n>t)throw RangeError("Wrong length");for(;c<a;)this[n+c]=o[c++]},c)},"./node_modules/core-js/modules/es.typed-array.slice.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/species-constructor.js"),i=t("./node_modules/core-js/internals/fails.js"),s=o.aTypedArray,a=o.aTypedArrayConstructor,l=[].slice,c=i(function(){new Int8Array(1).slice()});o.exportProto("slice",function(e,n){for(var t=l.call(s(this),e,n),o=r(this,this.constructor),i=0,c=t.length,d=new(a(o))(c);c>i;)d[i]=t[i++];return d},c)},"./node_modules/core-js/modules/es.typed-array.some.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/array-iteration.js").some,i=o.aTypedArray;o.exportProto("some",function(e){return r(i(this),e,arguments.length>1?arguments[1]:void 0)})},"./node_modules/core-js/modules/es.typed-array.sort.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=o.aTypedArray,i=[].sort;o.exportProto("sort",function(e){return i.call(r(this),e)})},"./node_modules/core-js/modules/es.typed-array.subarray.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/array-buffer-view-core.js"),r=t("./node_modules/core-js/internals/to-length.js"),i=t("./node_modules/core-js/internals/to-absolute-index.js"),s=t("./node_modules/core-js/internals/species-constructor.js"),a=o.aTypedArray;o.exportProto("subarray",function(e,n){var t=a(this),o=t.length,l=i(e,o);return new(s(t,t.constructor))(t.buffer,t.byteOffset+l*t.BYTES_PER_ELEMENT,r((void 0===n?o:i(n,o))-l))})},"./node_modules/core-js/modules/es.typed-array.to-locale-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/array-buffer-view-core.js"),i=t("./node_modules/core-js/internals/fails.js"),s=o.Int8Array,a=r.aTypedArray,l=[].toLocaleString,c=[].slice,d=!!s&&i(function(){l.call(new s(1))}),h=i(function(){return[1,2].toLocaleString()!=new s([1,2]).toLocaleString()})||!i(function(){s.prototype.toLocaleString.call([1,2])});r.exportProto("toLocaleString",function(){return l.apply(d?c.call(a(this)):a(this),arguments)},h)},"./node_modules/core-js/modules/es.typed-array.to-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/array-buffer-view-core.js"),i=t("./node_modules/core-js/internals/fails.js"),s=o.Uint8Array,a=s&&s.prototype,l=[].toString,c=[].join;i(function(){l.call({})})&&(l=function(){return c.call(this)}),r.exportProto("toString",l,(a||{}).toString!=l)},"./node_modules/core-js/modules/es.typed-array.uint16-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Uint16",2,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.uint32-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Uint32",4,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.uint8-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Uint8",1,function(e){return function(n,t,o){return e(this,n,t,o)}})},"./node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js":function(e,n,t){t("./node_modules/core-js/internals/typed-array-constructor.js")("Uint8",1,function(e){return function(n,t,o){return e(this,n,t,o)}},!0)},"./node_modules/core-js/modules/es.weak-map.js":function(e,n,t){"use strict";var o,r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/redefine-all.js"),s=t("./node_modules/core-js/internals/internal-metadata.js"),a=t("./node_modules/core-js/internals/collection.js"),l=t("./node_modules/core-js/internals/collection-weak.js"),c=t("./node_modules/core-js/internals/is-object.js"),d=t("./node_modules/core-js/internals/internal-state.js").enforce,h=t("./node_modules/core-js/internals/native-weak-map.js"),u=!r.ActiveXObject&&"ActiveXObject"in r,p=Object.isExtensible,f=function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},m=e.exports=a("WeakMap",f,l,!0,!0);if(h&&u){o=l.getConstructor(f,"WeakMap",!0),s.REQUIRED=!0;var g=m.prototype,y=g.delete,b=g.has,x=g.get,v=g.set;i(g,{delete:function(e){if(c(e)&&!p(e)){var n=d(this);return n.frozen||(n.frozen=new o),y.call(this,e)||n.frozen.delete(e)}return y.call(this,e)},has:function(e){if(c(e)&&!p(e)){var n=d(this);return n.frozen||(n.frozen=new o),b.call(this,e)||n.frozen.has(e)}return b.call(this,e)},get:function(e){if(c(e)&&!p(e)){var n=d(this);return n.frozen||(n.frozen=new o),b.call(this,e)?x.call(this,e):n.frozen.get(e)}return x.call(this,e)},set:function(e,n){if(c(e)&&!p(e)){var t=d(this);t.frozen||(t.frozen=new o),b.call(this,e)?v.call(this,e,n):t.frozen.set(e,n)}else v.call(this,e,n);return this}})}},"./node_modules/core-js/modules/es.weak-set.js":function(e,n,t){"use strict";t("./node_modules/core-js/internals/collection.js")("WeakSet",function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},t("./node_modules/core-js/internals/collection-weak.js"),!1,!0)},"./node_modules/core-js/modules/esnext.aggregate-error.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/object-get-prototype-of.js"),i=t("./node_modules/core-js/internals/object-set-prototype-of.js"),s=t("./node_modules/core-js/internals/object-create.js"),a=t("./node_modules/core-js/internals/create-property-descriptor.js"),l=t("./node_modules/core-js/internals/iterate.js"),c=t("./node_modules/core-js/internals/hide.js"),d=function(e,n){var t=this;if(!(t instanceof d))return new d(e,n);i&&(t=i(new Error(n),r(t)));var o=[];return l(e,o.push,o),c(t,"errors",o),void 0!==n&&c(t,"message",String(n)),t};d.prototype=s(Error.prototype,{constructor:a(5,d),name:a(5,"AggregateError")}),o({global:!0},{AggregateError:d})},"./node_modules/core-js/modules/esnext.array.last-index.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/add-to-unscopables.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/object-define-property.js").f;!o||"lastIndex"in[]||(a(Array.prototype,"lastIndex",{configurable:!0,get:function(){var e=i(this),n=s(e.length);return 0==n?0:n-1}}),r("lastIndex"))},"./node_modules/core-js/modules/esnext.array.last-item.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/descriptors.js"),r=t("./node_modules/core-js/internals/add-to-unscopables.js"),i=t("./node_modules/core-js/internals/to-object.js"),s=t("./node_modules/core-js/internals/to-length.js"),a=t("./node_modules/core-js/internals/object-define-property.js").f;!o||"lastItem"in[]||(a(Array.prototype,"lastItem",{configurable:!0,get:function(){var e=i(this),n=s(e.length);return 0==n?void 0:e[n-1]},set:function(e){var n=i(this),t=s(n.length);return n[0==t?0:t-1]=e}}),r("lastItem"))},"./node_modules/core-js/modules/esnext.composite-key.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/composite-key.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/object-create.js"),a=function(){var e=i("Object","freeze");return e?e(s(null)):s(null)};o({global:!0},{compositeKey:function(){return r.apply(Object,arguments).get("object",a)}})},"./node_modules/core-js/modules/esnext.composite-symbol.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/composite-key.js"),i=t("./node_modules/core-js/internals/get-built-in.js");o({global:!0},{compositeSymbol:function(){return 1===arguments.length&&"string"==typeof arguments[0]?i("Symbol").for(arguments[0]):r.apply(null,arguments).get("symbol",i("Symbol"))}})},"./node_modules/core-js/modules/esnext.global-this.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({global:!0},{globalThis:t("./node_modules/core-js/internals/global.js")})},"./node_modules/core-js/modules/esnext.map.delete-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-delete-all.js");o({target:"Map",proto:!0,real:!0,forced:r},{deleteAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.map.every.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-map-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{every:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return!l(t,function(e,t){if(!o(t,e,n))return l.stop()},void 0,!0,!0).stopped}})},"./node_modules/core-js/modules/esnext.map.filter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/bind-context.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/get-map-iterator.js"),h=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{filter:function(e){var n=s(this),t=d(n),o=l(e,arguments.length>1?arguments[1]:void 0,3),r=new(c(n,i("Map"))),u=a(r.set);return h(t,function(e,t){o(t,e,n)&&u.call(r,e,t)},void 0,!0,!0),r}})},"./node_modules/core-js/modules/esnext.map.find-key.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-map-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{findKey:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return l(t,function(e,t){if(o(t,e,n))return l.stop(e)},void 0,!0,!0).result}})},"./node_modules/core-js/modules/esnext.map.find.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-map-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{find:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return l(t,function(e,t){if(o(t,e,n))return l.stop(t)},void 0,!0,!0).result}})},"./node_modules/core-js/modules/esnext.map.from.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Map",stat:!0},{from:t("./node_modules/core-js/internals/collection-from.js")})},"./node_modules/core-js/modules/esnext.map.group-by.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/iterate.js"),i=t("./node_modules/core-js/internals/a-function.js");o({target:"Map",stat:!0},{groupBy:function(e,n){var t=new this;i(n);var o=i(t.has),s=i(t.get),a=i(t.set);return r(e,function(e){var r=n(e);o.call(t,r)?s.call(t,r).push(e):a.call(t,r,[e])}),t}})},"./node_modules/core-js/modules/esnext.map.includes.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/get-map-iterator.js"),a=t("./node_modules/core-js/internals/same-value-zero.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{includes:function(e){return l(s(i(this)),function(n,t){if(a(t,e))return l.stop()},void 0,!0,!0).stopped}})},"./node_modules/core-js/modules/esnext.map.key-by.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/iterate.js"),i=t("./node_modules/core-js/internals/a-function.js");o({target:"Map",stat:!0},{keyBy:function(e,n){var t=new this;i(n);var o=i(t.set);return r(e,function(e){o.call(t,n(e),e)}),t}})},"./node_modules/core-js/modules/esnext.map.key-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/get-map-iterator.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{keyOf:function(e){return a(s(i(this)),function(n,t){if(t===e)return a.stop(n)},void 0,!0,!0).result}})},"./node_modules/core-js/modules/esnext.map.map-keys.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/bind-context.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/get-map-iterator.js"),h=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{mapKeys:function(e){var n=s(this),t=d(n),o=l(e,arguments.length>1?arguments[1]:void 0,3),r=new(c(n,i("Map"))),u=a(r.set);return h(t,function(e,t){u.call(r,o(t,e,n),t)},void 0,!0,!0),r}})},"./node_modules/core-js/modules/esnext.map.map-values.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/bind-context.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/get-map-iterator.js"),h=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{mapValues:function(e){var n=s(this),t=d(n),o=l(e,arguments.length>1?arguments[1]:void 0,3),r=new(c(n,i("Map"))),u=a(r.set);return h(t,function(e,t){u.call(r,e,o(t,e,n))},void 0,!0,!0),r}})},"./node_modules/core-js/modules/esnext.map.merge.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{merge:function(e){for(var n=i(this),t=s(n.set),o=0;o<arguments.length;)a(arguments[o++],t,n,!0);return n}})},"./node_modules/core-js/modules/esnext.map.of.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Map",stat:!0},{of:t("./node_modules/core-js/internals/collection-of.js")})},"./node_modules/core-js/modules/esnext.map.reduce.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/get-map-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{reduce:function(e){var n,t,o=i(this),r=a(o);if(s(e),arguments.length>1)n=arguments[1];else{if((t=r.next()).done)throw TypeError("Reduce of empty map with no initial value");n=t.value[1]}return l(r,function(t,r){n=e(n,r,t,o)},void 0,!0,!0),n}})},"./node_modules/core-js/modules/esnext.map.some.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-map-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Map",proto:!0,real:!0,forced:r},{some:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return l(t,function(e,t){if(o(t,e,n))return l.stop()},void 0,!0,!0).stopped}})},"./node_modules/core-js/modules/esnext.map.update.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js");o({target:"Map",proto:!0,real:!0,forced:r},{update:function(e,n){var t=i(this),o=arguments.length;s(n);var r=t.has(e);if(!r&&o<3)throw TypeError("Updating absent value");var a=r?t.get(e):s(o>2?arguments[2]:void 0)(e,t);return t.set(e,n(a,e,t)),t}})},"./node_modules/core-js/modules/esnext.math.clamp.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.min,i=Math.max;o({target:"Math",stat:!0},{clamp:function(e,n,t){return r(t,i(n,e))}})},"./node_modules/core-js/modules/esnext.math.deg-per-rad.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{DEG_PER_RAD:Math.PI/180})},"./node_modules/core-js/modules/esnext.math.degrees.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=180/Math.PI;o({target:"Math",stat:!0},{degrees:function(e){return e*r}})},"./node_modules/core-js/modules/esnext.math.fscale.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/math-scale.js"),i=t("./node_modules/core-js/internals/math-fround.js");o({target:"Math",stat:!0},{fscale:function(e,n,t,o,s){return i(r(e,n,t,o,s))}})},"./node_modules/core-js/modules/esnext.math.iaddh.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{iaddh:function(e,n,t,o){var r=e>>>0,i=t>>>0;return(n>>>0)+(o>>>0)+((r&i|(r|i)&~(r+i>>>0))>>>31)|0}})},"./node_modules/core-js/modules/esnext.math.imulh.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{imulh:function(e,n){var t=+e,o=+n,r=65535&t,i=65535&o,s=t>>16,a=o>>16,l=(s*i>>>0)+(r*i>>>16);return s*a+(l>>16)+((r*a>>>0)+(65535&l)>>16)}})},"./node_modules/core-js/modules/esnext.math.isubh.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{isubh:function(e,n,t,o){var r=e>>>0,i=t>>>0;return(n>>>0)-(o>>>0)-((~r&i|~(r^i)&r-i>>>0)>>>31)|0}})},"./node_modules/core-js/modules/esnext.math.rad-per-deg.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{RAD_PER_DEG:180/Math.PI})},"./node_modules/core-js/modules/esnext.math.radians.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=Math.PI/180;o({target:"Math",stat:!0},{radians:function(e){return e*r}})},"./node_modules/core-js/modules/esnext.math.scale.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{scale:t("./node_modules/core-js/internals/math-scale.js")})},"./node_modules/core-js/modules/esnext.math.seeded-prng.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/an-object.js"),i=t("./node_modules/core-js/internals/number-is-finite.js"),s=t("./node_modules/core-js/internals/create-iterator-constructor.js"),a=t("./node_modules/core-js/internals/internal-state.js"),l=a.set,c=a.getterFor("Seeded Random Generator"),d=s(function(e){l(this,{type:"Seeded Random Generator",seed:e%2147483647})},"Seeded Random",function(){var e=c(this);return{value:(1073741823&(e.seed=(1103515245*e.seed+12345)%2147483647))/1073741823,done:!1}});o({target:"Math",stat:!0,forced:!0},{seededPRNG:function(e){var n=r(e).seed;if(!i(n))throw TypeError('Math.seededPRNG() argument should have a "seed" field with a finite value.');return new d(n)}})},"./node_modules/core-js/modules/esnext.math.signbit.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{signbit:function(e){return(e=+e)!=e?e:0==e?1/e==1/0:e>0}})},"./node_modules/core-js/modules/esnext.math.umulh.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Math",stat:!0},{umulh:function(e,n){var t=+e,o=+n,r=65535&t,i=65535&o,s=t>>>16,a=o>>>16,l=(s*i>>>0)+(r*i>>>16);return s*a+(l>>>16)+((r*a>>>0)+(65535&l)>>>16)}})},"./node_modules/core-js/modules/esnext.number.from-string.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/to-integer.js"),i=t("./node_modules/core-js/internals/parse-int.js"),s=/^[\da-z]+$/;o({target:"Number",stat:!0},{fromString:function(e,n){var t,o,a=1;if("string"!=typeof e)throw TypeError("Invalid number representation");if(!e.length)throw SyntaxError("Invalid number representation");if("-"==e.charAt(0)&&(a=-1,!(e=e.slice(1)).length))throw SyntaxError("Invalid number representation");if((t=void 0===n?10:r(n))<2||t>36)throw RangeError("Invalid radix");if(!s.test(e)||(o=i(e,t)).toString(t)!==e)throw SyntaxError("Invalid number representation");return a*o}})},"./node_modules/core-js/modules/esnext.observable.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/descriptors.js"),i=t("./node_modules/core-js/internals/set-species.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/an-object.js"),l=t("./node_modules/core-js/internals/is-object.js"),c=t("./node_modules/core-js/internals/an-instance.js"),d=t("./node_modules/core-js/internals/object-define-property.js").f,h=t("./node_modules/core-js/internals/hide.js"),u=t("./node_modules/core-js/internals/redefine-all.js"),p=t("./node_modules/core-js/internals/get-iterator.js"),f=t("./node_modules/core-js/internals/iterate.js"),m=t("./node_modules/core-js/internals/host-report-errors.js"),g=t("./node_modules/core-js/internals/well-known-symbol.js"),y=t("./node_modules/core-js/internals/internal-state.js"),b=g("observable"),x=y.get,v=y.set,j=function(e){return null==e?void 0:s(e)},w=function(e){var n=e.cleanup;if(n){e.cleanup=void 0;try{n()}catch(e){m(e)}}},k=function(e){return void 0===e.observer},_=function(e,n){if(!r){e.closed=!0;var t=n.subscriptionObserver;t&&(t.closed=!0)}n.observer=void 0},S=function(e,n){var t,o=v(this,{cleanup:void 0,observer:a(e),subscriptionObserver:void 0});r||(this.closed=!1);try{(t=j(e.start))&&t.call(e,this)}catch(e){m(e)}if(!k(o)){var i=o.subscriptionObserver=new C(this);try{var l=n(i),c=l;null!=l&&(o.cleanup="function"==typeof l.unsubscribe?function(){c.unsubscribe()}:s(l))}catch(e){return void i.error(e)}k(o)&&w(o)}};S.prototype=u({},{unsubscribe:function(){var e=x(this);k(e)||(_(this,e),w(e))}}),r&&d(S.prototype,"closed",{configurable:!0,get:function(){return k(x(this))}});var C=function(e){v(this,{subscription:e}),r||(this.closed=!1)};C.prototype=u({},{next:function(e){var n=x(x(this).subscription);if(!k(n)){var t=n.observer;try{var o=j(t.next);o&&o.call(t,e)}catch(e){m(e)}}},error:function(e){var n=x(this).subscription,t=x(n);if(!k(t)){var o=t.observer;_(n,t);try{var r=j(o.error);r?r.call(o,e):m(e)}catch(e){m(e)}w(t)}},complete:function(){var e=x(this).subscription,n=x(e);if(!k(n)){var t=n.observer;_(e,n);try{var o=j(t.complete);o&&o.call(t)}catch(e){m(e)}w(n)}}}),r&&d(C.prototype,"closed",{configurable:!0,get:function(){return k(x(x(this).subscription))}});var A=function(e){c(this,A,"Observable"),v(this,{subscriber:s(e)})};u(A.prototype,{subscribe:function(e){var n=arguments.length;return new S("function"==typeof e?{next:e,error:n>1?arguments[1]:void 0,complete:n>2?arguments[2]:void 0}:l(e)?e:{},x(this).subscriber)}}),u(A,{from:function(e){var n="function"==typeof this?this:A,t=j(a(e)[b]);if(t){var o=a(t.call(e));return o.constructor===n?o:new n(function(e){return o.subscribe(e)})}var r=p(e);return new n(function(e){f(r,function(n){if(e.next(n),e.closed)return f.stop()},void 0,!1,!0),e.complete()})},of:function(){for(var e="function"==typeof this?this:A,n=arguments.length,t=new Array(n),o=0;o<n;)t[o]=arguments[o++];return new e(function(e){for(var o=0;o<n;o++)if(e.next(t[o]),e.closed)return;e.complete()})}}),h(A.prototype,b,function(){return this}),o({global:!0},{Observable:A}),i("Observable")},"./node_modules/core-js/modules/esnext.promise.all-settled.js":function(e,n,t){t("./node_modules/core-js/modules/es.promise.all-settled.js")},"./node_modules/core-js/modules/esnext.promise.any.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/a-function.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/new-promise-capability.js"),a=t("./node_modules/core-js/internals/perform.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Promise",stat:!0},{any:function(e){var n=this,t=s.f(n),o=t.resolve,c=t.reject,d=a(function(){var t=r(n.resolve),s=[],a=0,d=1,h=!1;l(e,function(e){var r=a++,l=!1;s.push(void 0),d++,t.call(n,e).then(function(e){l||h||(h=!0,o(e))},function(e){l||h||(l=!0,s[r]=e,--d||c(new(i("AggregateError"))(s,"No one promise resolved")))})}),--d||c(new(i("AggregateError"))(s,"No one promise resolved"))});return d.error&&c(d.value),t.promise}})},"./node_modules/core-js/modules/esnext.promise.try.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/new-promise-capability.js"),i=t("./node_modules/core-js/internals/perform.js");o({target:"Promise",stat:!0},{try:function(e){var n=r.f(this),t=i(e);return(t.error?n.reject:n.resolve)(t.value),n.promise}})},"./node_modules/core-js/modules/esnext.reflect.define-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.toKey,a=r.set;o({target:"Reflect",stat:!0},{defineMetadata:function(e,n,t){var o=arguments.length<4?void 0:s(arguments[3]);a(e,n,i(t),o)}})},"./node_modules/core-js/modules/esnext.reflect.delete-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.toKey,a=r.getMap,l=r.store;o({target:"Reflect",stat:!0},{deleteMetadata:function(e,n){var t=arguments.length<3?void 0:s(arguments[2]),o=a(i(n),t,!1);if(void 0===o||!o.delete(e))return!1;if(o.size)return!0;var r=l.get(n);return r.delete(t),!!r.size||l.delete(n)}})},"./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/modules/es.set.js"),i=t("./node_modules/core-js/internals/reflect-metadata.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/object-get-prototype-of.js"),l=t("./node_modules/core-js/internals/iterate.js"),c=i.keys,d=i.toKey,h=function(e,n){var t=c(e,n),o=a(e);if(null===o)return t;var i,s,d=h(o,n);return d.length?t.length?(i=new r(t.concat(d)),l(i,(s=[]).push,s),s):d:t};o({target:"Reflect",stat:!0},{getMetadataKeys:function(e){var n=arguments.length<2?void 0:d(arguments[1]);return h(s(e),n)}})},"./node_modules/core-js/modules/esnext.reflect.get-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/object-get-prototype-of.js"),a=r.has,l=r.get,c=r.toKey,d=function(e,n,t){if(a(e,n,t))return l(e,n,t);var o=s(n);return null!==o?d(e,o,t):void 0};o({target:"Reflect",stat:!0},{getMetadata:function(e,n){var t=arguments.length<3?void 0:c(arguments[2]);return d(e,i(n),t)}})},"./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.keys,a=r.toKey;o({target:"Reflect",stat:!0},{getOwnMetadataKeys:function(e){var n=arguments.length<2?void 0:a(arguments[1]);return s(i(e),n)}})},"./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.get,a=r.toKey;o({target:"Reflect",stat:!0},{getOwnMetadata:function(e,n){var t=arguments.length<3?void 0:a(arguments[2]);return s(e,i(n),t)}})},"./node_modules/core-js/modules/esnext.reflect.has-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/object-get-prototype-of.js"),a=r.has,l=r.toKey,c=function(e,n,t){if(a(e,n,t))return!0;var o=s(n);return null!==o&&c(e,o,t)};o({target:"Reflect",stat:!0},{hasMetadata:function(e,n){var t=arguments.length<3?void 0:l(arguments[2]);return c(e,i(n),t)}})},"./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.has,a=r.toKey;o({target:"Reflect",stat:!0},{hasOwnMetadata:function(e,n){var t=arguments.length<3?void 0:a(arguments[2]);return s(e,i(n),t)}})},"./node_modules/core-js/modules/esnext.reflect.metadata.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/reflect-metadata.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=r.toKey,a=r.set;o({target:"Reflect",stat:!0},{metadata:function(e,n){return function(t,o){a(e,n,i(t),s(o))}}})},"./node_modules/core-js/modules/esnext.set.add-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-add-all.js");o({target:"Set",proto:!0,real:!0,forced:r},{addAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.set.delete-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-delete-all.js");o({target:"Set",proto:!0,real:!0,forced:r},{deleteAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.set.difference.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/species-constructor.js"),c=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{difference:function(e){var n=s(this),t=new(l(n,i("Set")))(n),o=a(t.delete);return c(e,function(e){o.call(t,e)}),t}})},"./node_modules/core-js/modules/esnext.set.every.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-set-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{every:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return!l(t,function(e){if(!o(e,e,n))return l.stop()},void 0,!1,!0).stopped}})},"./node_modules/core-js/modules/esnext.set.filter.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/bind-context.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/get-set-iterator.js"),h=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{filter:function(e){var n=s(this),t=d(n),o=l(e,arguments.length>1?arguments[1]:void 0,3),r=new(c(n,i("Set"))),u=a(r.add);return h(t,function(e){o(e,e,n)&&u.call(r,e)},void 0,!1,!0),r}})},"./node_modules/core-js/modules/esnext.set.find.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-set-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{find:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return l(t,function(e){if(o(e,e,n))return l.stop(e)},void 0,!1,!0).result}})},"./node_modules/core-js/modules/esnext.set.from.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Set",stat:!0},{from:t("./node_modules/core-js/internals/collection-from.js")})},"./node_modules/core-js/modules/esnext.set.intersection.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/species-constructor.js"),c=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{intersection:function(e){var n=s(this),t=new(l(n,i("Set"))),o=a(n.has),r=a(t.add);return c(e,function(e){o.call(n,e)&&r.call(t,e)}),t}})},"./node_modules/core-js/modules/esnext.set.is-disjoint-from.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{isDisjointFrom:function(e){var n=i(this),t=s(n.has);return!a(e,function(e){if(!0===t.call(n,e))return a.stop()}).stopped}})},"./node_modules/core-js/modules/esnext.set.is-subset-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/get-iterator.js"),c=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{isSubsetOf:function(e){var n=l(this),t=s(e),o=t.has;return"function"!=typeof o&&(t=new(i("Set"))(e),o=a(t.has)),!c(n,function(e){if(!1===o.call(t,e))return c.stop()},void 0,!1,!0).stopped}})},"./node_modules/core-js/modules/esnext.set.is-superset-of.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{isSupersetOf:function(e){var n=i(this),t=s(n.has);return!a(e,function(e){if(!1===t.call(n,e))return a.stop()}).stopped}})},"./node_modules/core-js/modules/esnext.set.join.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/get-set-iterator.js"),a=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{join:function(e){var n=i(this),t=s(n),o=void 0===e?",":String(e),r=[];return a(t,r.push,r,!1,!0),r.join(o)}})},"./node_modules/core-js/modules/esnext.set.map.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/bind-context.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/get-set-iterator.js"),h=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{map:function(e){var n=s(this),t=d(n),o=l(e,arguments.length>1?arguments[1]:void 0,3),r=new(c(n,i("Set"))),u=a(r.add);return h(t,function(e){u.call(r,o(e,e,n))},void 0,!1,!0),r}})},"./node_modules/core-js/modules/esnext.set.of.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"Set",stat:!0},{of:t("./node_modules/core-js/internals/collection-of.js")})},"./node_modules/core-js/modules/esnext.set.reduce.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/a-function.js"),a=t("./node_modules/core-js/internals/get-set-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{reduce:function(e){var n,t,o=i(this),r=a(o);if(s(e),arguments.length>1)n=arguments[1];else{if((t=r.next()).done)throw TypeError("Reduce of empty set with no initial value");n=t.value}return l(r,function(t){n=e(n,t,t,o)},void 0,!1,!0),n}})},"./node_modules/core-js/modules/esnext.set.some.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/an-object.js"),s=t("./node_modules/core-js/internals/bind-context.js"),a=t("./node_modules/core-js/internals/get-set-iterator.js"),l=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{some:function(e){var n=i(this),t=a(n),o=s(e,arguments.length>1?arguments[1]:void 0,3);return l(t,function(e){if(o(e,e,n))return l.stop()},void 0,!1,!0).stopped}})},"./node_modules/core-js/modules/esnext.set.symmetric-difference.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/species-constructor.js"),c=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{symmetricDifference:function(e){var n=s(this),t=new(l(n,i("Set")))(n),o=a(t.delete),r=a(t.add);return c(e,function(e){o.call(t,e)||r.call(t,e)}),t}})},"./node_modules/core-js/modules/esnext.set.union.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/get-built-in.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/a-function.js"),l=t("./node_modules/core-js/internals/species-constructor.js"),c=t("./node_modules/core-js/internals/iterate.js");o({target:"Set",proto:!0,real:!0,forced:r},{union:function(e){var n=s(this),t=new(l(n,i("Set")))(n);return c(e,a(t.add),t),t}})},"./node_modules/core-js/modules/esnext.string.at.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/string-multibyte.js").charAt;o({target:"String",proto:!0},{at:function(e){return r(this,e)}})},"./node_modules/core-js/modules/esnext.string.code-points.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/create-iterator-constructor.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js"),s=t("./node_modules/core-js/internals/internal-state.js"),a=t("./node_modules/core-js/internals/string-multibyte.js"),l=a.codeAt,c=a.charAt,d=s.set,h=s.getterFor("String Iterator"),u=r(function(e){d(this,{type:"String Iterator",string:e,index:0})},"String",function(){var e,n=h(this),t=n.string,o=n.index;return o>=t.length?{value:void 0,done:!0}:(e=c(t,o),n.index+=e.length,{value:{codePoint:l(e,0),position:o},done:!1})});o({target:"String",proto:!0},{codePoints:function(){return new u(String(i(this)))}})},"./node_modules/core-js/modules/esnext.string.match-all.js":function(e,n,t){t("./node_modules/core-js/modules/es.symbol.match-all.js"),t("./node_modules/core-js/modules/es.string.match-all.js")},"./node_modules/core-js/modules/esnext.string.replace-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/hide.js"),i=t("./node_modules/core-js/internals/require-object-coercible.js"),s=t("./node_modules/core-js/internals/an-object.js"),a=t("./node_modules/core-js/internals/is-regexp.js"),l=t("./node_modules/core-js/internals/regexp-flags.js"),c=t("./node_modules/core-js/internals/species-constructor.js"),d=t("./node_modules/core-js/internals/well-known-symbol.js"),h=t("./node_modules/core-js/internals/is-pure.js"),u=d("replaceAll"),p=RegExp.prototype,f=function(e,n){var t=s(this),o=String("flags"in p?t.flags:l.call(t));return~o.indexOf("g")||(t=new(c(t,RegExp))(t.source,o+"g")),String(e).replace(t,n)};o({target:"String",proto:!0},{replaceAll:function(e,n){var t,o,r,s,l,c,d=i(this);if(null!=e){if(void 0!==(t=e[u]))return t.call(e,d,n);if(h&&a(e))return f.call(e,d,n)}if(o=String(d),r=String(e),s=o.split(r),"function"!=typeof n)return s.join(String(n));for(l=s[0],c=1;c<s.length;c++)l+=String(n(r,c-1,o)),l+=s[c];return l}}),h||u in p||r(p,u,f)},"./node_modules/core-js/modules/esnext.symbol.dispose.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("dispose")},"./node_modules/core-js/modules/esnext.symbol.observable.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("observable")},"./node_modules/core-js/modules/esnext.symbol.pattern-match.js":function(e,n,t){t("./node_modules/core-js/internals/define-well-known-symbol.js")("patternMatch")},"./node_modules/core-js/modules/esnext.weak-map.delete-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-delete-all.js");o({target:"WeakMap",proto:!0,real:!0,forced:r},{deleteAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.weak-map.from.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"WeakMap",stat:!0},{from:t("./node_modules/core-js/internals/collection-from.js")})},"./node_modules/core-js/modules/esnext.weak-map.of.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"WeakMap",stat:!0},{of:t("./node_modules/core-js/internals/collection-of.js")})},"./node_modules/core-js/modules/esnext.weak-set.add-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-add-all.js");o({target:"WeakSet",proto:!0,real:!0,forced:r},{addAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.weak-set.delete-all.js":function(e,n,t){"use strict";var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/is-pure.js"),i=t("./node_modules/core-js/internals/collection-delete-all.js");o({target:"WeakSet",proto:!0,real:!0,forced:r},{deleteAll:function(){return i.apply(this,arguments)}})},"./node_modules/core-js/modules/esnext.weak-set.from.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"WeakSet",stat:!0},{from:t("./node_modules/core-js/internals/collection-from.js")})},"./node_modules/core-js/modules/esnext.weak-set.of.js":function(e,n,t){t("./node_modules/core-js/internals/export.js")({target:"WeakSet",stat:!0},{of:t("./node_modules/core-js/internals/collection-of.js")})},"./node_modules/core-js/modules/web.dom-collections.for-each.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/dom-iterables.js"),i=t("./node_modules/core-js/internals/array-for-each.js"),s=t("./node_modules/core-js/internals/hide.js");for(var a in r){var l=o[a],c=l&&l.prototype;if(c&&c.forEach!==i)try{s(c,"forEach",i)}catch(e){c.forEach=i}}},"./node_modules/core-js/modules/web.dom-collections.iterator.js":function(e,n,t){var o=t("./node_modules/core-js/internals/global.js"),r=t("./node_modules/core-js/internals/dom-iterables.js"),i=t("./node_modules/core-js/modules/es.array.iterator.js"),s=t("./node_modules/core-js/internals/hide.js"),a=t("./node_modules/core-js/internals/well-known-symbol.js"),l=a("iterator"),c=a("toStringTag"),d=i.values;for(var h in r){var u=o[h],p=u&&u.prototype;if(p){if(p[l]!==d)try{s(p,l,d)}catch(e){p[l]=d}if(p[c]||s(p,c,h),r[h])for(var f in i)if(p[f]!==i[f])try{s(p,f,i[f])}catch(e){p[f]=i[f]}}}},"./node_modules/core-js/modules/web.queue-microtask.js":function(e,n,t){var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/global.js"),i=t("./node_modules/core-js/internals/microtask.js"),s=t("./node_modules/core-js/internals/classof-raw.js"),a=r.process,l="process"==s(a);o({global:!0,enumerable:!0,noTargetGet:!0},{queueMicrotask:function(e){var n=l&&a.domain;i(n?n.bind(e):e)}})},"./node_modules/core-js/modules/web.url-search-params.js":function(e,n,t){"use strict";t("./node_modules/core-js/modules/es.array.iterator.js");var o=t("./node_modules/core-js/internals/export.js"),r=t("./node_modules/core-js/internals/native-url.js"),i=t("./node_modules/core-js/internals/redefine.js"),s=t("./node_modules/core-js/internals/redefine-all.js"),a=t("./node_modules/core-js/internals/set-to-string-tag.js"),l=t("./node_modules/core-js/internals/create-iterator-constructor.js"),c=t("./node_modules/core-js/internals/internal-state.js"),d=t("./node_modules/core-js/internals/an-instance.js"),h=t("./node_modules/core-js/internals/has.js"),u=t("./node_modules/core-js/internals/bind-context.js"),p=t("./node_modules/core-js/internals/an-object.js"),f=t("./node_modules/core-js/internals/is-object.js"),m=t("./node_modules/core-js/internals/get-iterator.js"),g=t("./node_modules/core-js/internals/get-iterator-method.js"),y=t("./node_modules/core-js/internals/well-known-symbol.js")("iterator"),b=c.set,x=c.getterFor("URLSearchParams"),v=c.getterFor("URLSearchParamsIterator"),j=/\+/g,w=Array(4),k=function(e){return w[e-1]||(w[e-1]=RegExp("((?:%[\\da-f]{2}){"+e+"})","gi"))},_=function(e){try{return decodeURIComponent(e)}catch(n){return e}},S=function(e){var n=e.replace(j," "),t=4;try{return decodeURIComponent(n)}catch(e){for(;t;)n=n.replace(k(t--),_);return n}},C=/[!'()~]|%20/g,A={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+"},T=function(e){return A[e]},O=function(e){return encodeURIComponent(e).replace(C,T)},P=function(e,n){if(n)for(var t,o,r=n.split("&"),i=0;i<r.length;)(t=r[i++]).length&&(o=t.split("="),e.push({key:S(o.shift()),value:S(o.join("="))}))},M=function(e){this.entries.length=0,P(this.entries,e)},L=function(e,n){if(e<n)throw TypeError("Not enough arguments")},H=l(function(e,n){b(this,{type:"URLSearchParamsIterator",iterator:m(x(e).entries),kind:n})},"Iterator",function(){var e=v(this),n=e.kind,t=e.iterator.next(),o=t.value;return t.done||(t.value="keys"===n?o.key:"values"===n?o.value:[o.key,o.value]),t}),I=function(){d(this,I,"URLSearchParams");var e,n,t,o,r,i,s,a=arguments.length>0?arguments[0]:void 0,l=[];if(b(this,{type:"URLSearchParams",entries:l,updateURL:function(){},updateSearchParams:M}),void 0!==a)if(f(a))if("function"==typeof(e=g(a)))for(n=e.call(a);!(t=n.next()).done;){if((r=(o=m(p(t.value))).next()).done||(i=o.next()).done||!o.next().done)throw TypeError("Expected sequence with length 2");l.push({key:r.value+"",value:i.value+""})}else for(s in a)h(a,s)&&l.push({key:s,value:a[s]+""});else P(l,"string"==typeof a?"?"===a.charAt(0)?a.slice(1):a:a+"")},D=I.prototype;s(D,{append:function(e,n){L(arguments.length,2);var t=x(this);t.entries.push({key:e+"",value:n+""}),t.updateURL()},delete:function(e){L(arguments.length,1);for(var n=x(this),t=n.entries,o=e+"",r=0;r<t.length;)t[r].key===o?t.splice(r,1):r++;n.updateURL()},get:function(e){L(arguments.length,1);for(var n=x(this).entries,t=e+"",o=0;o<n.length;o++)if(n[o].key===t)return n[o].value;return null},getAll:function(e){L(arguments.length,1);for(var n=x(this).entries,t=e+"",o=[],r=0;r<n.length;r++)n[r].key===t&&o.push(n[r].value);return o},has:function(e){L(arguments.length,1);for(var n=x(this).entries,t=e+"",o=0;o<n.length;)if(n[o++].key===t)return!0;return!1},set:function(e,n){L(arguments.length,1);for(var t,o=x(this),r=o.entries,i=!1,s=e+"",a=n+"",l=0;l<r.length;l++)(t=r[l]).key===s&&(i?r.splice(l--,1):(i=!0,t.value=a));i||r.push({key:s,value:a}),o.updateURL()},sort:function(){var e,n,t,o=x(this),r=o.entries,i=r.slice();for(r.length=0,t=0;t<i.length;t++){for(e=i[t],n=0;n<t;n++)if(r[n].key>e.key){r.splice(n,0,e);break}n===t&&r.push(e)}o.updateURL()},forEach:function(e){for(var n,t=x(this).entries,o=u(e,arguments.length>1?arguments[1]:void 0,3),r=0;r<t.length;)o((n=t[r++]).value,n.key,this)},keys:function(){return new H(this,"keys")},values:function(){return new H(this,"values")},entries:function(){return new H(this,"entries")}},{enumerable:!0}),i(D,y,D.entries),i(D,"toString",function(){for(var e,n=x(this).entries,t=[],o=0;o<n.length;)e=n[o++],t.push(O(e.key)+"="+O(e.value));return t.join("&")},{enumerable:!0}),a(I,"URLSearchParams"),o({global:!0,forced:!r},{URLSearchParams:I}),e.exports={URLSearchParams:I,getState:x}},"./node_modules/core-js/modules/web.url.js":function(e,n,t){"use strict";t("./node_modules/core-js/modules/es.string.iterator.js");var o,r=t("./node_modules/core-js/internals/export.js"),i=t("./node_modules/core-js/internals/descriptors.js"),s=t("./node_modules/core-js/internals/native-url.js"),a=t("./node_modules/core-js/internals/global.js"),l=t("./node_modules/core-js/internals/object-define-properties.js"),c=t("./node_modules/core-js/internals/redefine.js"),d=t("./node_modules/core-js/internals/an-instance.js"),h=t("./node_modules/core-js/internals/has.js"),u=t("./node_modules/core-js/internals/object-assign.js"),p=t("./node_modules/core-js/internals/array-from.js"),f=t("./node_modules/core-js/internals/string-multibyte.js").codeAt,m=t("./node_modules/core-js/internals/punycode-to-ascii.js"),g=t("./node_modules/core-js/internals/set-to-string-tag.js"),y=t("./node_modules/core-js/modules/web.url-search-params.js"),b=t("./node_modules/core-js/internals/internal-state.js"),x=a.URL,v=y.URLSearchParams,j=y.getState,w=b.set,k=b.getterFor("URL"),_=Math.floor,S=Math.pow,C=/[A-Za-z]/,A=/[\d+\-.A-Za-z]/,T=/\d/,O=/^(0x|0X)/,P=/^[0-7]+$/,M=/^\d+$/,L=/^[\dA-Fa-f]+$/,H=/[\u0000\u0009\u000A\u000D #%\/:?@[\\]]/,I=/[\u0000\u0009\u000A\u000D #\/:?@[\\]]/,D=/^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g,E=/[\u0009\u000A\u000D]/g,B=function(e,n){var t,o,r;if("["==n.charAt(0)){if("]"!=n.charAt(n.length-1))return"Invalid host";if(!(t=N(n.slice(1,-1))))return"Invalid host";e.host=t}else if(U(e)){if(n=m(n),H.test(n))return"Invalid host";if(null===(t=R(n)))return"Invalid host";e.host=t}else{if(I.test(n))return"Invalid host";for(t="",o=p(n),r=0;r<o.length;r++)t+=V(o[r],G);e.host=t}},R=function(e){var n,t,o,r,i,s,a,l=e.split(".");if(l.length&&""==l[l.length-1]&&l.pop(),(n=l.length)>4)return e;for(t=[],o=0;o<n;o++){if(""==(r=l[o]))return e;if(i=10,r.length>1&&"0"==r.charAt(0)&&(i=O.test(r)?16:8,r=r.slice(8==i?1:2)),""===r)s=0;else{if(!(10==i?M:8==i?P:L).test(r))return e;s=parseInt(r,i)}t.push(s)}for(o=0;o<n;o++)if(s=t[o],o==n-1){if(s>=S(256,5-n))return null}else if(s>255)return null;for(a=t.pop(),o=0;o<t.length;o++)a+=t[o]*S(256,3-o);return a},N=function(e){var n,t,o,r,i,s,a,l=[0,0,0,0,0,0,0,0],c=0,d=null,h=0,u=function(){return e.charAt(h)};if(":"==u()){if(":"!=e.charAt(1))return;h+=2,d=++c}for(;u();){if(8==c)return;if(":"!=u()){for(n=t=0;t<4&&L.test(u());)n=16*n+parseInt(u(),16),h++,t++;if("."==u()){if(0==t)return;if(h-=t,c>6)return;for(o=0;u();){if(r=null,o>0){if(!("."==u()&&o<4))return;h++}if(!T.test(u()))return;for(;T.test(u());){if(i=parseInt(u(),10),null===r)r=i;else{if(0==r)return;r=10*r+i}if(r>255)return;h++}l[c]=256*l[c]+r,2!=++o&&4!=o||c++}if(4!=o)return;break}if(":"==u()){if(h++,!u())return}else if(u())return;l[c++]=n}else{if(null!==d)return;h++,d=++c}}if(null!==d)for(s=c-d,c=7;0!=c&&s>0;)a=l[c],l[c--]=l[d+s-1],l[d+--s]=a;else if(8!=c)return;return l},z=function(e){var n,t,o,r;if("number"==typeof e){for(n=[],t=0;t<4;t++)n.unshift(e%256),e=_(e/256);return n.join(".")}if("object"==typeof e){for(n="",o=function(e){for(var n=null,t=1,o=null,r=0,i=0;i<8;i++)0!==e[i]?(r>t&&(n=o,t=r),o=null,r=0):(null===o&&(o=i),++r);return r>t&&(n=o,t=r),n}(e),t=0;t<8;t++)r&&0===e[t]||(r&&(r=!1),o===t?(n+=t?":":"::",r=!0):(n+=e[t].toString(16),t<7&&(n+=":")));return"["+n+"]"}return e},G={},W=u({},G,{" ":1,'"':1,"<":1,">":1,"`":1}),F=u({},W,{"#":1,"?":1,"{":1,"}":1}),X=u({},F,{"/":1,":":1,";":1,"=":1,"@":1,"[":1,"\\":1,"]":1,"^":1,"|":1}),V=function(e,n){var t=f(e,0);return t>32&&t<127&&!h(n,e)?e:encodeURIComponent(e)},Y={ftp:21,file:null,gopher:70,http:80,https:443,ws:80,wss:443},U=function(e){return h(Y,e.scheme)},q=function(e){return""!=e.username||""!=e.password},K=function(e){return!e.host||e.cannotBeABaseURL||"file"==e.scheme},$=function(e,n){var t;return 2==e.length&&C.test(e.charAt(0))&&(":"==(t=e.charAt(1))||!n&&"|"==t)},Z=function(e){var n;return e.length>1&&$(e.slice(0,2))&&(2==e.length||"/"===(n=e.charAt(2))||"\\"===n||"?"===n||"#"===n)},J=function(e){var n=e.path,t=n.length;!t||"file"==e.scheme&&1==t&&$(n[0],!0)||n.pop()},Q=function(e){return"."===e||"%2e"===e.toLowerCase()},ee={},ne={},te={},oe={},re={},ie={},se={},ae={},le={},ce={},de={},he={},ue={},pe={},fe={},me={},ge={},ye={},be={},xe={},ve={},je=function(e,n,t,r){var i,s,a,l,c,d=t||ee,u=0,f="",m=!1,g=!1,y=!1;for(t||(e.scheme="",e.username="",e.password="",e.host=null,e.port=null,e.path=[],e.query=null,e.fragment=null,e.cannotBeABaseURL=!1,n=n.replace(D,"")),n=n.replace(E,""),i=p(n);u<=i.length;){switch(s=i[u],d){case ee:if(!s||!C.test(s)){if(t)return"Invalid scheme";d=te;continue}f+=s.toLowerCase(),d=ne;break;case ne:if(s&&(A.test(s)||"+"==s||"-"==s||"."==s))f+=s.toLowerCase();else{if(":"!=s){if(t)return"Invalid scheme";f="",d=te,u=0;continue}if(t&&(U(e)!=h(Y,f)||"file"==f&&(q(e)||null!==e.port)||"file"==e.scheme&&!e.host))return;if(e.scheme=f,t)return void(U(e)&&Y[e.scheme]==e.port&&(e.port=null));f="","file"==e.scheme?d=pe:U(e)&&r&&r.scheme==e.scheme?d=oe:U(e)?d=ae:"/"==i[u+1]?(d=re,u++):(e.cannotBeABaseURL=!0,e.path.push(""),d=be)}break;case te:if(!r||r.cannotBeABaseURL&&"#"!=s)return"Invalid scheme";if(r.cannotBeABaseURL&&"#"==s){e.scheme=r.scheme,e.path=r.path.slice(),e.query=r.query,e.fragment="",e.cannotBeABaseURL=!0,d=ve;break}d="file"==r.scheme?pe:ie;continue;case oe:if("/"!=s||"/"!=i[u+1]){d=ie;continue}d=le,u++;break;case re:if("/"==s){d=ce;break}d=ye;continue;case ie:if(e.scheme=r.scheme,s==o)e.username=r.username,e.password=r.password,e.host=r.host,e.port=r.port,e.path=r.path.slice(),e.query=r.query;else if("/"==s||"\\"==s&&U(e))d=se;else if("?"==s)e.username=r.username,e.password=r.password,e.host=r.host,e.port=r.port,e.path=r.path.slice(),e.query="",d=xe;else{if("#"!=s){e.username=r.username,e.password=r.password,e.host=r.host,e.port=r.port,e.path=r.path.slice(),e.path.pop(),d=ye;continue}e.username=r.username,e.password=r.password,e.host=r.host,e.port=r.port,e.path=r.path.slice(),e.query=r.query,e.fragment="",d=ve}break;case se:if(!U(e)||"/"!=s&&"\\"!=s){if("/"!=s){e.username=r.username,e.password=r.password,e.host=r.host,e.port=r.port,d=ye;continue}d=ce}else d=le;break;case ae:if(d=le,"/"!=s||"/"!=f.charAt(u+1))continue;u++;break;case le:if("/"!=s&&"\\"!=s){d=ce;continue}break;case ce:if("@"==s){m&&(f="%40"+f),m=!0,a=p(f);for(var b=0;b<a.length;b++){var x=a[b];if(":"!=x||y){var v=V(x,X);y?e.password+=v:e.username+=v}else y=!0}f=""}else if(s==o||"/"==s||"?"==s||"#"==s||"\\"==s&&U(e)){if(m&&""==f)return"Invalid authority";u-=p(f).length+1,f="",d=de}else f+=s;break;case de:case he:if(t&&"file"==e.scheme){d=me;continue}if(":"!=s||g){if(s==o||"/"==s||"?"==s||"#"==s||"\\"==s&&U(e)){if(U(e)&&""==f)return"Invalid host";if(t&&""==f&&(q(e)||null!==e.port))return;if(l=B(e,f))return l;if(f="",d=ge,t)return;continue}"["==s?g=!0:"]"==s&&(g=!1),f+=s}else{if(""==f)return"Invalid host";if(l=B(e,f))return l;if(f="",d=ue,t==he)return}break;case ue:if(!T.test(s)){if(s==o||"/"==s||"?"==s||"#"==s||"\\"==s&&U(e)||t){if(""!=f){var j=parseInt(f,10);if(j>65535)return"Invalid port";e.port=U(e)&&j===Y[e.scheme]?null:j,f=""}if(t)return;d=ge;continue}return"Invalid port"}f+=s;break;case pe:if(e.scheme="file","/"==s||"\\"==s)d=fe;else{if(!r||"file"!=r.scheme){d=ye;continue}if(s==o)e.host=r.host,e.path=r.path.slice(),e.query=r.query;else if("?"==s)e.host=r.host,e.path=r.path.slice(),e.query="",d=xe;else{if("#"!=s){Z(i.slice(u).join(""))||(e.host=r.host,e.path=r.path.slice(),J(e)),d=ye;continue}e.host=r.host,e.path=r.path.slice(),e.query=r.query,e.fragment="",d=ve}}break;case fe:if("/"==s||"\\"==s){d=me;break}r&&"file"==r.scheme&&!Z(i.slice(u).join(""))&&($(r.path[0],!0)?e.path.push(r.path[0]):e.host=r.host),d=ye;continue;case me:if(s==o||"/"==s||"\\"==s||"?"==s||"#"==s){if(!t&&$(f))d=ye;else if(""==f){if(e.host="",t)return;d=ge}else{if(l=B(e,f))return l;if("localhost"==e.host&&(e.host=""),t)return;f="",d=ge}continue}f+=s;break;case ge:if(U(e)){if(d=ye,"/"!=s&&"\\"!=s)continue}else if(t||"?"!=s)if(t||"#"!=s){if(s!=o&&(d=ye,"/"!=s))continue}else e.fragment="",d=ve;else e.query="",d=xe;break;case ye:if(s==o||"/"==s||"\\"==s&&U(e)||!t&&("?"==s||"#"==s)){if(".."===(c=(c=f).toLowerCase())||"%2e."===c||".%2e"===c||"%2e%2e"===c?(J(e),"/"==s||"\\"==s&&U(e)||e.path.push("")):Q(f)?"/"==s||"\\"==s&&U(e)||e.path.push(""):("file"==e.scheme&&!e.path.length&&$(f)&&(e.host&&(e.host=""),f=f.charAt(0)+":"),e.path.push(f)),f="","file"==e.scheme&&(s==o||"?"==s||"#"==s))for(;e.path.length>1&&""===e.path[0];)e.path.shift();"?"==s?(e.query="",d=xe):"#"==s&&(e.fragment="",d=ve)}else f+=V(s,F);break;case be:"?"==s?(e.query="",d=xe):"#"==s?(e.fragment="",d=ve):s!=o&&(e.path[0]+=V(s,G));break;case xe:t||"#"!=s?s!=o&&("'"==s&&U(e)?e.query+="%27":e.query+="#"==s?"%23":V(s,G)):(e.fragment="",d=ve);break;case ve:s!=o&&(e.fragment+=V(s,W))}u++}},we=function(e){var n,t,o=d(this,we,"URL"),r=arguments.length>1?arguments[1]:void 0,s=String(e),a=w(o,{type:"URL"});if(void 0!==r)if(r instanceof we)n=k(r);else if(t=je(n={},String(r)))throw TypeError(t);if(t=je(a,s,null,n))throw TypeError(t);var l=a.searchParams=new v,c=j(l);c.updateSearchParams(a.query),c.updateURL=function(){a.query=String(l)||null},i||(o.href=_e.call(o),o.origin=Se.call(o),o.protocol=Ce.call(o),o.username=Ae.call(o),o.password=Te.call(o),o.host=Oe.call(o),o.hostname=Pe.call(o),o.port=Me.call(o),o.pathname=Le.call(o),o.search=He.call(o),o.searchParams=Ie.call(o),o.hash=De.call(o))},ke=we.prototype,_e=function(){var e=k(this),n=e.scheme,t=e.username,o=e.password,r=e.host,i=e.port,s=e.path,a=e.query,l=e.fragment,c=n+":";return null!==r?(c+="//",q(e)&&(c+=t+(o?":"+o:"")+"@"),c+=z(r),null!==i&&(c+=":"+i)):"file"==n&&(c+="//"),c+=e.cannotBeABaseURL?s[0]:s.length?"/"+s.join("/"):"",null!==a&&(c+="?"+a),null!==l&&(c+="#"+l),c},Se=function(){var e=k(this),n=e.scheme,t=e.port;if("blob"==n)try{return new URL(n.path[0]).origin}catch(e){return"null"}return"file"!=n&&U(e)?n+"://"+z(e.host)+(null!==t?":"+t:""):"null"},Ce=function(){return k(this).scheme+":"},Ae=function(){return k(this).username},Te=function(){return k(this).password},Oe=function(){var e=k(this),n=e.host,t=e.port;return null===n?"":null===t?z(n):z(n)+":"+t},Pe=function(){var e=k(this).host;return null===e?"":z(e)},Me=function(){var e=k(this).port;return null===e?"":String(e)},Le=function(){var e=k(this),n=e.path;return e.cannotBeABaseURL?n[0]:n.length?"/"+n.join("/"):""},He=function(){var e=k(this).query;return e?"?"+e:""},Ie=function(){return k(this).searchParams},De=function(){var e=k(this).fragment;return e?"#"+e:""},Ee=function(e,n){return{get:e,set:n,configurable:!0,enumerable:!0}};if(i&&l(ke,{href:Ee(_e,function(e){var n=k(this),t=String(e),o=je(n,t);if(o)throw TypeError(o);j(n.searchParams).updateSearchParams(n.query)}),origin:Ee(Se),protocol:Ee(Ce,function(e){var n=k(this);je(n,String(e)+":",ee)}),username:Ee(Ae,function(e){var n=k(this),t=p(String(e));if(!K(n)){n.username="";for(var o=0;o<t.length;o++)n.username+=V(t[o],X)}}),password:Ee(Te,function(e){var n=k(this),t=p(String(e));if(!K(n)){n.password="";for(var o=0;o<t.length;o++)n.password+=V(t[o],X)}}),host:Ee(Oe,function(e){var n=k(this);n.cannotBeABaseURL||je(n,String(e),de)}),hostname:Ee(Pe,function(e){var n=k(this);n.cannotBeABaseURL||je(n,String(e),he)}),port:Ee(Me,function(e){var n=k(this);K(n)||(""==(e=String(e))?n.port=null:je(n,e,ue))}),pathname:Ee(Le,function(e){var n=k(this);n.cannotBeABaseURL||(n.path=[],je(n,e+"",ge))}),search:Ee(He,function(e){var n=k(this);""==(e=String(e))?n.query=null:("?"==e.charAt(0)&&(e=e.slice(1)),n.query="",je(n,e,xe)),j(n.searchParams).updateSearchParams(n.query)}),searchParams:Ee(Ie),hash:Ee(De,function(e){var n=k(this);""!=(e=String(e))?("#"==e.charAt(0)&&(e=e.slice(1)),n.fragment="",je(n,e,ve)):n.fragment=null})}),c(ke,"toJSON",function(){return _e.call(this)},{enumerable:!0}),c(ke,"toString",function(){return _e.call(this)},{enumerable:!0}),x){var Be=x.createObjectURL,Re=x.revokeObjectURL;Be&&c(we,"createObjectURL",function(e){return Be.apply(x,arguments)}),Re&&c(we,"revokeObjectURL",function(e){return Re.apply(x,arguments)})}g(we,"URL"),r({global:!0,forced:!s,sham:!i},{URL:we})},"./node_modules/core-js/modules/web.url.to-json.js":function(e,n,t){"use strict";t("./node_modules/core-js/internals/export.js")({target:"URL",proto:!0,enumerable:!0},{toJSON:function(){return URL.prototype.toString.call(this)}})},"./node_modules/highcharts/modules/no-data-to-display.js":function(e,n,t){var o;o=function(e){!function(e){function n(){this.hasData()?this.hideNoData():this.showNoData()}var t=e.seriesTypes,o=e.Chart.prototype,r=e.getOptions(),i=e.extend,s=e.each;i(r.lang,{noData:"No data to display"}),r.noData={position:{x:0,y:0,align:"center",verticalAlign:"middle"}},r.noData.style={fontWeight:"bold",fontSize:"12px",color:"#666666"},s("bubble gauge heatmap pie treemap waterfall".split(" "),function(e){t[e]&&(t[e].prototype.hasData=function(){return!!this.points.length})}),e.Series.prototype.hasData=function(){return this.visible&&void 0!==this.dataMax&&void 0!==this.dataMin},o.showNoData=function(e){var n=this.options;e=e||n.lang.noData,n=n.noData,this.noDataLabel||(this.noDataLabel=this.renderer.label(e,0,0,null,null,null,n.useHTML,null,"no-data"),this.noDataLabel.attr(n.attr).css(n.style),this.noDataLabel.add(),this.noDataLabel.align(i(this.noDataLabel.getBBox(),n.position),!1,"plotBox"))},o.hideNoData=function(){this.noDataLabel&&(this.noDataLabel=this.noDataLabel.destroy())},o.hasData=function(){for(var e=this.series,n=e.length;n--;)if(e[n].hasData()&&!e[n].options.isInternal)return!0;return this.loadingShown},o.callbacks.push(function(t){e.addEvent(t,"load",n),e.addEvent(t,"redraw",n)})}(e)},e.exports?e.exports=o:o(Highcharts)},"./node_modules/lodash/_Hash.js":function(e,n,t){var o=t("./node_modules/lodash/_hashClear.js"),r=t("./node_modules/lodash/_hashDelete.js"),i=t("./node_modules/lodash/_hashGet.js"),s=t("./node_modules/lodash/_hashHas.js"),a=t("./node_modules/lodash/_hashSet.js");function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var o=e[n];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=a,e.exports=l},"./node_modules/lodash/_ListCache.js":function(e,n,t){var o=t("./node_modules/lodash/_listCacheClear.js"),r=t("./node_modules/lodash/_listCacheDelete.js"),i=t("./node_modules/lodash/_listCacheGet.js"),s=t("./node_modules/lodash/_listCacheHas.js"),a=t("./node_modules/lodash/_listCacheSet.js");function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var o=e[n];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=a,e.exports=l},"./node_modules/lodash/_Map.js":function(e,n,t){var o=t("./node_modules/lodash/_getNative.js")(t("./node_modules/lodash/_root.js"),"Map");e.exports=o},"./node_modules/lodash/_MapCache.js":function(e,n,t){var o=t("./node_modules/lodash/_mapCacheClear.js"),r=t("./node_modules/lodash/_mapCacheDelete.js"),i=t("./node_modules/lodash/_mapCacheGet.js"),s=t("./node_modules/lodash/_mapCacheHas.js"),a=t("./node_modules/lodash/_mapCacheSet.js");function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var o=e[n];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=s,l.prototype.set=a,e.exports=l},"./node_modules/lodash/_Stack.js":function(e,n,t){var o=t("./node_modules/lodash/_ListCache.js"),r=t("./node_modules/lodash/_stackClear.js"),i=t("./node_modules/lodash/_stackDelete.js"),s=t("./node_modules/lodash/_stackGet.js"),a=t("./node_modules/lodash/_stackHas.js"),l=t("./node_modules/lodash/_stackSet.js");function c(e){var n=this.__data__=new o(e);this.size=n.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=s,c.prototype.has=a,c.prototype.set=l,e.exports=c},"./node_modules/lodash/_Symbol.js":function(e,n,t){var o=t("./node_modules/lodash/_root.js").Symbol;e.exports=o},"./node_modules/lodash/_Uint8Array.js":function(e,n,t){var o=t("./node_modules/lodash/_root.js").Uint8Array;e.exports=o},"./node_modules/lodash/_apply.js":function(e,n){e.exports=function(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)}},"./node_modules/lodash/_arrayLikeKeys.js":function(e,n,t){var o=t("./node_modules/lodash/_baseTimes.js"),r=t("./node_modules/lodash/isArguments.js"),i=t("./node_modules/lodash/isArray.js"),s=t("./node_modules/lodash/isBuffer.js"),a=t("./node_modules/lodash/_isIndex.js"),l=t("./node_modules/lodash/isTypedArray.js"),c=Object.prototype.hasOwnProperty;e.exports=function(e,n){var t=i(e),d=!t&&r(e),h=!t&&!d&&s(e),u=!t&&!d&&!h&&l(e),p=t||d||h||u,f=p?o(e.length,String):[],m=f.length;for(var g in e)!n&&!c.call(e,g)||p&&("length"==g||h&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||a(g,m))||f.push(g);return f}},"./node_modules/lodash/_assignMergeValue.js":function(e,n,t){var o=t("./node_modules/lodash/_baseAssignValue.js"),r=t("./node_modules/lodash/eq.js");e.exports=function(e,n,t){(void 0===t||r(e[n],t))&&(void 0!==t||n in e)||o(e,n,t)}},"./node_modules/lodash/_assignValue.js":function(e,n,t){var o=t("./node_modules/lodash/_baseAssignValue.js"),r=t("./node_modules/lodash/eq.js"),i=Object.prototype.hasOwnProperty;e.exports=function(e,n,t){var s=e[n];i.call(e,n)&&r(s,t)&&(void 0!==t||n in e)||o(e,n,t)}},"./node_modules/lodash/_assocIndexOf.js":function(e,n,t){var o=t("./node_modules/lodash/eq.js");e.exports=function(e,n){for(var t=e.length;t--;)if(o(e[t][0],n))return t;return-1}},"./node_modules/lodash/_baseAssignValue.js":function(e,n,t){var o=t("./node_modules/lodash/_defineProperty.js");e.exports=function(e,n,t){"__proto__"==n&&o?o(e,n,{configurable:!0,enumerable:!0,value:t,writable:!0}):e[n]=t}},"./node_modules/lodash/_baseCreate.js":function(e,n,t){var o=t("./node_modules/lodash/isObject.js"),r=Object.create,i=function(){function e(){}return function(n){if(!o(n))return{};if(r)return r(n);e.prototype=n;var t=new e;return e.prototype=void 0,t}}();e.exports=i},"./node_modules/lodash/_baseFor.js":function(e,n,t){var o=t("./node_modules/lodash/_createBaseFor.js")();e.exports=o},"./node_modules/lodash/_baseGetTag.js":function(e,n,t){var o=t("./node_modules/lodash/_Symbol.js"),r=t("./node_modules/lodash/_getRawTag.js"),i=t("./node_modules/lodash/_objectToString.js"),s="[object Null]",a="[object Undefined]",l=o?o.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?a:s:l&&l in Object(e)?r(e):i(e)}},"./node_modules/lodash/_baseIsArguments.js":function(e,n,t){var o=t("./node_modules/lodash/_baseGetTag.js"),r=t("./node_modules/lodash/isObjectLike.js"),i="[object Arguments]";e.exports=function(e){return r(e)&&o(e)==i}},"./node_modules/lodash/_baseIsNative.js":function(e,n,t){var o=t("./node_modules/lodash/isFunction.js"),r=t("./node_modules/lodash/_isMasked.js"),i=t("./node_modules/lodash/isObject.js"),s=t("./node_modules/lodash/_toSource.js"),a=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,h=c.hasOwnProperty,u=RegExp("^"+d.call(h).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=function(e){return!(!i(e)||r(e))&&(o(e)?u:a).test(s(e))}},"./node_modules/lodash/_baseIsTypedArray.js":function(e,n,t){var o=t("./node_modules/lodash/_baseGetTag.js"),r=t("./node_modules/lodash/isLength.js"),i=t("./node_modules/lodash/isObjectLike.js"),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,e.exports=function(e){return i(e)&&r(e.length)&&!!s[o(e)]}},"./node_modules/lodash/_baseKeysIn.js":function(e,n,t){var o=t("./node_modules/lodash/isObject.js"),r=t("./node_modules/lodash/_isPrototype.js"),i=t("./node_modules/lodash/_nativeKeysIn.js"),s=Object.prototype.hasOwnProperty;e.exports=function(e){if(!o(e))return i(e);var n=r(e),t=[];for(var a in e)("constructor"!=a||!n&&s.call(e,a))&&t.push(a);return t}},"./node_modules/lodash/_baseMerge.js":function(e,n,t){var o=t("./node_modules/lodash/_Stack.js"),r=t("./node_modules/lodash/_assignMergeValue.js"),i=t("./node_modules/lodash/_baseFor.js"),s=t("./node_modules/lodash/_baseMergeDeep.js"),a=t("./node_modules/lodash/isObject.js"),l=t("./node_modules/lodash/keysIn.js"),c=t("./node_modules/lodash/_safeGet.js");e.exports=function e(n,t,d,h,u){n!==t&&i(t,function(i,l){if(u||(u=new o),a(i))s(n,t,l,d,e,h,u);else{var p=h?h(c(n,l),i,l+"",n,t,u):void 0;void 0===p&&(p=i),r(n,l,p)}},l)}},"./node_modules/lodash/_baseMergeDeep.js":function(e,n,t){var o=t("./node_modules/lodash/_assignMergeValue.js"),r=t("./node_modules/lodash/_cloneBuffer.js"),i=t("./node_modules/lodash/_cloneTypedArray.js"),s=t("./node_modules/lodash/_copyArray.js"),a=t("./node_modules/lodash/_initCloneObject.js"),l=t("./node_modules/lodash/isArguments.js"),c=t("./node_modules/lodash/isArray.js"),d=t("./node_modules/lodash/isArrayLikeObject.js"),h=t("./node_modules/lodash/isBuffer.js"),u=t("./node_modules/lodash/isFunction.js"),p=t("./node_modules/lodash/isObject.js"),f=t("./node_modules/lodash/isPlainObject.js"),m=t("./node_modules/lodash/isTypedArray.js"),g=t("./node_modules/lodash/_safeGet.js"),y=t("./node_modules/lodash/toPlainObject.js");e.exports=function(e,n,t,b,x,v,j){var w=g(e,t),k=g(n,t),_=j.get(k);if(_)o(e,t,_);else{var S=v?v(w,k,t+"",e,n,j):void 0,C=void 0===S;if(C){var A=c(k),T=!A&&h(k),O=!A&&!T&&m(k);S=k,A||T||O?c(w)?S=w:d(w)?S=s(w):T?(C=!1,S=r(k,!0)):O?(C=!1,S=i(k,!0)):S=[]:f(k)||l(k)?(S=w,l(w)?S=y(w):p(w)&&!u(w)||(S=a(k))):C=!1}C&&(j.set(k,S),x(S,k,b,v,j),j.delete(k)),o(e,t,S)}}},"./node_modules/lodash/_baseRest.js":function(e,n,t){var o=t("./node_modules/lodash/identity.js"),r=t("./node_modules/lodash/_overRest.js"),i=t("./node_modules/lodash/_setToString.js");e.exports=function(e,n){return i(r(e,n,o),e+"")}},"./node_modules/lodash/_baseSetToString.js":function(e,n,t){var o=t("./node_modules/lodash/constant.js"),r=t("./node_modules/lodash/_defineProperty.js"),i=t("./node_modules/lodash/identity.js"),s=r?function(e,n){return r(e,"toString",{configurable:!0,enumerable:!1,value:o(n),writable:!0})}:i;e.exports=s},"./node_modules/lodash/_baseTimes.js":function(e,n){e.exports=function(e,n){for(var t=-1,o=Array(e);++t<e;)o[t]=n(t);return o}},"./node_modules/lodash/_baseUnary.js":function(e,n){e.exports=function(e){return function(n){return e(n)}}},"./node_modules/lodash/_cloneArrayBuffer.js":function(e,n,t){var o=t("./node_modules/lodash/_Uint8Array.js");e.exports=function(e){var n=new e.constructor(e.byteLength);return new o(n).set(new o(e)),n}},"./node_modules/lodash/_cloneBuffer.js":function(e,n,t){(function(e){var o=t("./node_modules/lodash/_root.js"),r=n&&!n.nodeType&&n,i=r&&"object"==typeof e&&e&&!e.nodeType&&e,s=i&&i.exports===r?o.Buffer:void 0,a=s?s.allocUnsafe:void 0;e.exports=function(e,n){if(n)return e.slice();var t=e.length,o=a?a(t):new e.constructor(t);return e.copy(o),o}}).call(this,t("./node_modules/webpack/buildin/module.js")(e))},"./node_modules/lodash/_cloneTypedArray.js":function(e,n,t){var o=t("./node_modules/lodash/_cloneArrayBuffer.js");e.exports=function(e,n){var t=n?o(e.buffer):e.buffer;return new e.constructor(t,e.byteOffset,e.length)}},"./node_modules/lodash/_copyArray.js":function(e,n){e.exports=function(e,n){var t=-1,o=e.length;for(n||(n=Array(o));++t<o;)n[t]=e[t];return n}},"./node_modules/lodash/_copyObject.js":function(e,n,t){var o=t("./node_modules/lodash/_assignValue.js"),r=t("./node_modules/lodash/_baseAssignValue.js");e.exports=function(e,n,t,i){var s=!t;t||(t={});for(var a=-1,l=n.length;++a<l;){var c=n[a],d=i?i(t[c],e[c],c,t,e):void 0;void 0===d&&(d=e[c]),s?r(t,c,d):o(t,c,d)}return t}},"./node_modules/lodash/_coreJsData.js":function(e,n,t){var o=t("./node_modules/lodash/_root.js")["__core-js_shared__"];e.exports=o},"./node_modules/lodash/_createAssigner.js":function(e,n,t){var o=t("./node_modules/lodash/_baseRest.js"),r=t("./node_modules/lodash/_isIterateeCall.js");e.exports=function(e){return o(function(n,t){var o=-1,i=t.length,s=i>1?t[i-1]:void 0,a=i>2?t[2]:void 0;for(s=e.length>3&&"function"==typeof s?(i--,s):void 0,a&&r(t[0],t[1],a)&&(s=i<3?void 0:s,i=1),n=Object(n);++o<i;){var l=t[o];l&&e(n,l,o,s)}return n})}},"./node_modules/lodash/_createBaseFor.js":function(e,n){e.exports=function(e){return function(n,t,o){for(var r=-1,i=Object(n),s=o(n),a=s.length;a--;){var l=s[e?a:++r];if(!1===t(i[l],l,i))break}return n}}},"./node_modules/lodash/_defineProperty.js":function(e,n,t){var o=t("./node_modules/lodash/_getNative.js"),r=function(){try{var e=o(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=r},"./node_modules/lodash/_freeGlobal.js":function(e,n,t){(function(n){var t="object"==typeof n&&n&&n.Object===Object&&n;e.exports=t}).call(this,t("./node_modules/webpack/buildin/global.js"))},"./node_modules/lodash/_getMapData.js":function(e,n,t){var o=t("./node_modules/lodash/_isKeyable.js");e.exports=function(e,n){var t=e.__data__;return o(n)?t["string"==typeof n?"string":"hash"]:t.map}},"./node_modules/lodash/_getNative.js":function(e,n,t){var o=t("./node_modules/lodash/_baseIsNative.js"),r=t("./node_modules/lodash/_getValue.js");e.exports=function(e,n){var t=r(e,n);return o(t)?t:void 0}},"./node_modules/lodash/_getPrototype.js":function(e,n,t){var o=t("./node_modules/lodash/_overArg.js")(Object.getPrototypeOf,Object);e.exports=o},"./node_modules/lodash/_getRawTag.js":function(e,n,t){var o=t("./node_modules/lodash/_Symbol.js"),r=Object.prototype,i=r.hasOwnProperty,s=r.toString,a=o?o.toStringTag:void 0;e.exports=function(e){var n=i.call(e,a),t=e[a];try{e[a]=void 0;var o=!0}catch(e){}var r=s.call(e);return o&&(n?e[a]=t:delete e[a]),r}},"./node_modules/lodash/_getValue.js":function(e,n){e.exports=function(e,n){return null==e?void 0:e[n]}},"./node_modules/lodash/_hashClear.js":function(e,n,t){var o=t("./node_modules/lodash/_nativeCreate.js");e.exports=function(){this.__data__=o?o(null):{},this.size=0}},"./node_modules/lodash/_hashDelete.js":function(e,n){e.exports=function(e){var n=this.has(e)&&delete this.__data__[e];return this.size-=n?1:0,n}},"./node_modules/lodash/_hashGet.js":function(e,n,t){var o=t("./node_modules/lodash/_nativeCreate.js"),r="__lodash_hash_undefined__",i=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;if(o){var t=n[e];return t===r?void 0:t}return i.call(n,e)?n[e]:void 0}},"./node_modules/lodash/_hashHas.js":function(e,n,t){var o=t("./node_modules/lodash/_nativeCreate.js"),r=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;return o?void 0!==n[e]:r.call(n,e)}},"./node_modules/lodash/_hashSet.js":function(e,n,t){var o=t("./node_modules/lodash/_nativeCreate.js"),r="__lodash_hash_undefined__";e.exports=function(e,n){var t=this.__data__;return this.size+=this.has(e)?0:1,t[e]=o&&void 0===n?r:n,this}},"./node_modules/lodash/_initCloneObject.js":function(e,n,t){var o=t("./node_modules/lodash/_baseCreate.js"),r=t("./node_modules/lodash/_getPrototype.js"),i=t("./node_modules/lodash/_isPrototype.js");e.exports=function(e){return"function"!=typeof e.constructor||i(e)?{}:o(r(e))}},"./node_modules/lodash/_isIndex.js":function(e,n){var t=9007199254740991,o=/^(?:0|[1-9]\d*)$/;e.exports=function(e,n){var r=typeof e;return!!(n=null==n?t:n)&&("number"==r||"symbol"!=r&&o.test(e))&&e>-1&&e%1==0&&e<n}},"./node_modules/lodash/_isIterateeCall.js":function(e,n,t){var o=t("./node_modules/lodash/eq.js"),r=t("./node_modules/lodash/isArrayLike.js"),i=t("./node_modules/lodash/_isIndex.js"),s=t("./node_modules/lodash/isObject.js");e.exports=function(e,n,t){if(!s(t))return!1;var a=typeof n;return!!("number"==a?r(t)&&i(n,t.length):"string"==a&&n in t)&&o(t[n],e)}},"./node_modules/lodash/_isKeyable.js":function(e,n){e.exports=function(e){var n=typeof e;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==e:null===e}},"./node_modules/lodash/_isMasked.js":function(e,n,t){var o,r=t("./node_modules/lodash/_coreJsData.js"),i=(o=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";e.exports=function(e){return!!i&&i in e}},"./node_modules/lodash/_isPrototype.js":function(e,n){var t=Object.prototype;e.exports=function(e){var n=e&&e.constructor;return e===("function"==typeof n&&n.prototype||t)}},"./node_modules/lodash/_listCacheClear.js":function(e,n){e.exports=function(){this.__data__=[],this.size=0}},"./node_modules/lodash/_listCacheDelete.js":function(e,n,t){var o=t("./node_modules/lodash/_assocIndexOf.js"),r=Array.prototype.splice;e.exports=function(e){var n=this.__data__,t=o(n,e);return!(t<0||(t==n.length-1?n.pop():r.call(n,t,1),--this.size,0))}},"./node_modules/lodash/_listCacheGet.js":function(e,n,t){var o=t("./node_modules/lodash/_assocIndexOf.js");e.exports=function(e){var n=this.__data__,t=o(n,e);return t<0?void 0:n[t][1]}},"./node_modules/lodash/_listCacheHas.js":function(e,n,t){var o=t("./node_modules/lodash/_assocIndexOf.js");e.exports=function(e){return o(this.__data__,e)>-1}},"./node_modules/lodash/_listCacheSet.js":function(e,n,t){var o=t("./node_modules/lodash/_assocIndexOf.js");e.exports=function(e,n){var t=this.__data__,r=o(t,e);return r<0?(++this.size,t.push([e,n])):t[r][1]=n,this}},"./node_modules/lodash/_mapCacheClear.js":function(e,n,t){var o=t("./node_modules/lodash/_Hash.js"),r=t("./node_modules/lodash/_ListCache.js"),i=t("./node_modules/lodash/_Map.js");e.exports=function(){this.size=0,this.__data__={hash:new o,map:new(i||r),string:new o}}},"./node_modules/lodash/_mapCacheDelete.js":function(e,n,t){var o=t("./node_modules/lodash/_getMapData.js");e.exports=function(e){var n=o(this,e).delete(e);return this.size-=n?1:0,n}},"./node_modules/lodash/_mapCacheGet.js":function(e,n,t){var o=t("./node_modules/lodash/_getMapData.js");e.exports=function(e){return o(this,e).get(e)}},"./node_modules/lodash/_mapCacheHas.js":function(e,n,t){var o=t("./node_modules/lodash/_getMapData.js");e.exports=function(e){return o(this,e).has(e)}},"./node_modules/lodash/_mapCacheSet.js":function(e,n,t){var o=t("./node_modules/lodash/_getMapData.js");e.exports=function(e,n){var t=o(this,e),r=t.size;return t.set(e,n),this.size+=t.size==r?0:1,this}},"./node_modules/lodash/_nativeCreate.js":function(e,n,t){var o=t("./node_modules/lodash/_getNative.js")(Object,"create");e.exports=o},"./node_modules/lodash/_nativeKeysIn.js":function(e,n){e.exports=function(e){var n=[];if(null!=e)for(var t in Object(e))n.push(t);return n}},"./node_modules/lodash/_nodeUtil.js":function(e,n,t){(function(e){var o=t("./node_modules/lodash/_freeGlobal.js"),r=n&&!n.nodeType&&n,i=r&&"object"==typeof e&&e&&!e.nodeType&&e,s=i&&i.exports===r&&o.process,a=function(){try{var e=i&&i.require&&i.require("util").types;return e||s&&s.binding&&s.binding("util")}catch(e){}}();e.exports=a}).call(this,t("./node_modules/webpack/buildin/module.js")(e))},"./node_modules/lodash/_objectToString.js":function(e,n){var t=Object.prototype.toString;e.exports=function(e){return t.call(e)}},"./node_modules/lodash/_overArg.js":function(e,n){e.exports=function(e,n){return function(t){return e(n(t))}}},"./node_modules/lodash/_overRest.js":function(e,n,t){var o=t("./node_modules/lodash/_apply.js"),r=Math.max;e.exports=function(e,n,t){return n=r(void 0===n?e.length-1:n,0),function(){for(var i=arguments,s=-1,a=r(i.length-n,0),l=Array(a);++s<a;)l[s]=i[n+s];s=-1;for(var c=Array(n+1);++s<n;)c[s]=i[s];return c[n]=t(l),o(e,this,c)}}},"./node_modules/lodash/_root.js":function(e,n,t){var o=t("./node_modules/lodash/_freeGlobal.js"),r="object"==typeof self&&self&&self.Object===Object&&self,i=o||r||Function("return this")();e.exports=i},"./node_modules/lodash/_safeGet.js":function(e,n){e.exports=function(e,n){if(("constructor"!==n||"function"!=typeof e[n])&&"__proto__"!=n)return e[n]}},"./node_modules/lodash/_setToString.js":function(e,n,t){var o=t("./node_modules/lodash/_baseSetToString.js"),r=t("./node_modules/lodash/_shortOut.js")(o);e.exports=r},"./node_modules/lodash/_shortOut.js":function(e,n){var t=800,o=16,r=Date.now;e.exports=function(e){var n=0,i=0;return function(){var s=r(),a=o-(s-i);if(i=s,a>0){if(++n>=t)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}},"./node_modules/lodash/_stackClear.js":function(e,n,t){var o=t("./node_modules/lodash/_ListCache.js");e.exports=function(){this.__data__=new o,this.size=0}},"./node_modules/lodash/_stackDelete.js":function(e,n){e.exports=function(e){var n=this.__data__,t=n.delete(e);return this.size=n.size,t}},"./node_modules/lodash/_stackGet.js":function(e,n){e.exports=function(e){return this.__data__.get(e)}},"./node_modules/lodash/_stackHas.js":function(e,n){e.exports=function(e){return this.__data__.has(e)}},"./node_modules/lodash/_stackSet.js":function(e,n,t){var o=t("./node_modules/lodash/_ListCache.js"),r=t("./node_modules/lodash/_Map.js"),i=t("./node_modules/lodash/_MapCache.js"),s=200;e.exports=function(e,n){var t=this.__data__;if(t instanceof o){var a=t.__data__;if(!r||a.length<s-1)return a.push([e,n]),this.size=++t.size,this;t=this.__data__=new i(a)}return t.set(e,n),this.size=t.size,this}},"./node_modules/lodash/_toSource.js":function(e,n){var t=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return t.call(e)}catch(e){}try{return e+""}catch(e){}}return""}},"./node_modules/lodash/constant.js":function(e,n){e.exports=function(e){return function(){return e}}},"./node_modules/lodash/eq.js":function(e,n){e.exports=function(e,n){return e===n||e!=e&&n!=n}},"./node_modules/lodash/identity.js":function(e,n){e.exports=function(e){return e}},"./node_modules/lodash/isArguments.js":function(e,n,t){var o=t("./node_modules/lodash/_baseIsArguments.js"),r=t("./node_modules/lodash/isObjectLike.js"),i=Object.prototype,s=i.hasOwnProperty,a=i.propertyIsEnumerable,l=o(function(){return arguments}())?o:function(e){return r(e)&&s.call(e,"callee")&&!a.call(e,"callee")};e.exports=l},"./node_modules/lodash/isArray.js":function(e,n){var t=Array.isArray;e.exports=t},"./node_modules/lodash/isArrayLike.js":function(e,n,t){var o=t("./node_modules/lodash/isFunction.js"),r=t("./node_modules/lodash/isLength.js");e.exports=function(e){return null!=e&&r(e.length)&&!o(e)}},"./node_modules/lodash/isArrayLikeObject.js":function(e,n,t){var o=t("./node_modules/lodash/isArrayLike.js"),r=t("./node_modules/lodash/isObjectLike.js");e.exports=function(e){return r(e)&&o(e)}},"./node_modules/lodash/isBuffer.js":function(e,n,t){(function(e){var o=t("./node_modules/lodash/_root.js"),r=t("./node_modules/lodash/stubFalse.js"),i=n&&!n.nodeType&&n,s=i&&"object"==typeof e&&e&&!e.nodeType&&e,a=s&&s.exports===i?o.Buffer:void 0,l=(a?a.isBuffer:void 0)||r;e.exports=l}).call(this,t("./node_modules/webpack/buildin/module.js")(e))},"./node_modules/lodash/isFunction.js":function(e,n,t){var o=t("./node_modules/lodash/_baseGetTag.js"),r=t("./node_modules/lodash/isObject.js"),i="[object AsyncFunction]",s="[object Function]",a="[object GeneratorFunction]",l="[object Proxy]";e.exports=function(e){if(!r(e))return!1;var n=o(e);return n==s||n==a||n==i||n==l}},"./node_modules/lodash/isLength.js":function(e,n){var t=9007199254740991;e.exports=function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=t}},"./node_modules/lodash/isObject.js":function(e,n){e.exports=function(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}},"./node_modules/lodash/isObjectLike.js":function(e,n){e.exports=function(e){return null!=e&&"object"==typeof e}},"./node_modules/lodash/isPlainObject.js":function(e,n,t){var o=t("./node_modules/lodash/_baseGetTag.js"),r=t("./node_modules/lodash/_getPrototype.js"),i=t("./node_modules/lodash/isObjectLike.js"),s="[object Object]",a=Function.prototype,l=Object.prototype,c=a.toString,d=l.hasOwnProperty,h=c.call(Object);e.exports=function(e){if(!i(e)||o(e)!=s)return!1;var n=r(e);if(null===n)return!0;var t=d.call(n,"constructor")&&n.constructor;return"function"==typeof t&&t instanceof t&&c.call(t)==h}},"./node_modules/lodash/isTypedArray.js":function(e,n,t){var o=t("./node_modules/lodash/_baseIsTypedArray.js"),r=t("./node_modules/lodash/_baseUnary.js"),i=t("./node_modules/lodash/_nodeUtil.js"),s=i&&i.isTypedArray,a=s?r(s):o;e.exports=a},"./node_modules/lodash/keysIn.js":function(e,n,t){var o=t("./node_modules/lodash/_arrayLikeKeys.js"),r=t("./node_modules/lodash/_baseKeysIn.js"),i=t("./node_modules/lodash/isArrayLike.js");e.exports=function(e){return i(e)?o(e,!0):r(e)}},"./node_modules/lodash/merge.js":function(e,n,t){var o=t("./node_modules/lodash/_baseMerge.js"),r=t("./node_modules/lodash/_createAssigner.js")(function(e,n,t){o(e,n,t)});e.exports=r},"./node_modules/lodash/stubFalse.js":function(e,n){e.exports=function(){return!1}},"./node_modules/lodash/toPlainObject.js":function(e,n,t){var o=t("./node_modules/lodash/_copyObject.js"),r=t("./node_modules/lodash/keysIn.js");e.exports=function(e){return o(e,r(e))}},"./node_modules/memoize-one/dist/memoize-one.esm.js":function(e,n,t){"use strict";function o(e,n){if(e.length!==n.length)return!1;for(var t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}n.a=function(e,n){var t;void 0===n&&(n=o);var r,i=[],s=!1;return function(){for(var o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];return s&&t===this&&n(o,i)?r:(r=e.apply(this,o),s=!0,t=this,i=o,r)}}},"./node_modules/merge-anything/dist/index.esm.js":function(e,n,t){"use strict";function o(e){return Object.prototype.toString.call(e).slice(8,-1)}function r(e){return"Object"===o(e)&&(e.constructor===Object&&Object.getPrototypeOf(e)===Object.prototype)}function i(e){return"Array"===o(e)}function s(e){return"Symbol"===o(e)}function a(e,n,t,o){var r=o.propertyIsEnumerable(n)?"enumerable":"nonenumerable";"enumerable"===r&&(e[n]=t),"nonenumerable"===r&&Object.defineProperty(e,n,{value:t,enumerable:!1,writable:!0,configurable:!0})}n.a=function(e){for(var n=[],t=1;t<arguments.length;t++)n[t-1]=arguments[t];var o=null,l=e;return r(e)&&e.extensions&&1===Object.keys(e).length&&(l={},o=e.extensions),n.reduce(function(e,n){return function e(n,t,o){if(!r(t))return o&&i(o)&&o.forEach(function(e){t=e(n,t)}),t;var l={};if(r(n)){var c=Object.getOwnPropertyNames(n),d=Object.getOwnPropertySymbols(n);l=c.concat(d).reduce(function(e,o){var r=n[o];return(!s(o)&&!Object.getOwnPropertyNames(t).includes(o)||s(o)&&!Object.getOwnPropertySymbols(t).includes(o))&&a(e,o,r,n),e},{})}var h=Object.getOwnPropertyNames(t),u=Object.getOwnPropertySymbols(t);return h.concat(u).reduce(function(s,l){var c=t[l],d=r(n)?n[l]:void 0;return o&&i(o)&&o.forEach(function(e){c=e(d,c)}),void 0!==d&&r(c)&&(c=e(d,c,o)),a(s,l,c,t),s},l)}(e,n,o)},l)}},"./node_modules/object-assign/index.js":function(e,n,t){"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var o=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var n={},t=0;t<10;t++)n["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(n).map(function(e){return n[e]}).join(""))return!1;var o={};return"abcdefghijklmnopqrst".split("").forEach(function(e){o[e]=e}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},o)).join("")}catch(e){return!1}}()?Object.assign:function(e,n){for(var t,s,a=function(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),l=1;l<arguments.length;l++){for(var c in t=Object(arguments[l]))r.call(t,c)&&(a[c]=t[c]);if(o){s=o(t);for(var d=0;d<s.length;d++)i.call(t,s[d])&&(a[s[d]]=t[s[d]])}}return a}},"./node_modules/process/browser.js":function(e,n){var t,o,r=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{o="function"==typeof clearTimeout?clearTimeout:s}catch(e){o=s}}();var l,c=[],d=!1,h=-1;function u(){d&&l&&(d=!1,l.length?c=l.concat(c):h=-1,c.length&&p())}function p(){if(!d){var e=a(u);d=!0;for(var n=c.length;n;){for(l=c,c=[];++h<n;)l&&l[h].run();h=-1,n=c.length}l=null,d=!1,function(e){if(o===clearTimeout)return clearTimeout(e);if((o===s||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(e);try{o(e)}catch(n){try{return o.call(null,e)}catch(n){return o.call(this,e)}}}(e)}}function f(e,n){this.fun=e,this.array=n}function m(){}r.nextTick=function(e){var n=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)n[t-1]=arguments[t];c.push(new f(e,n)),1!==c.length||d||a(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=m,r.addListener=m,r.once=m,r.off=m,r.removeListener=m,r.removeAllListeners=m,r.emit=m,r.prependListener=m,r.prependOnceListener=m,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},"./node_modules/prop-types/factoryWithThrowingShims.js":function(e,n,t){"use strict";var o=t("./node_modules/prop-types/lib/ReactPropTypesSecret.js");function r(){}function i(){}i.resetWarningCache=r,e.exports=function(){function e(e,n,t,r,i,s){if(s!==o){var a=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw a.name="Invariant Violation",a}}function n(){return e}e.isRequired=e;var t={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:n,element:e,elementType:e,instanceOf:n,node:e,objectOf:n,oneOf:n,oneOfType:n,shape:n,exact:n,checkPropTypes:i,resetWarningCache:r};return t.PropTypes=t,t}},"./node_modules/prop-types/index.js":function(e,n,t){e.exports=t("./node_modules/prop-types/factoryWithThrowingShims.js")()},"./node_modules/prop-types/lib/ReactPropTypesSecret.js":function(e,n,t){"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},"./node_modules/react-is/cjs/react-is.production.min.js":function(e,n,t){"use strict";
/** @license React v16.10.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Object.defineProperty(n,"__esModule",{value:!0});var o="function"==typeof Symbol&&Symbol.for,r=o?Symbol.for("react.element"):60103,i=o?Symbol.for("react.portal"):60106,s=o?Symbol.for("react.fragment"):60107,a=o?Symbol.for("react.strict_mode"):60108,l=o?Symbol.for("react.profiler"):60114,c=o?Symbol.for("react.provider"):60109,d=o?Symbol.for("react.context"):60110,h=o?Symbol.for("react.async_mode"):60111,u=o?Symbol.for("react.concurrent_mode"):60111,p=o?Symbol.for("react.forward_ref"):60112,f=o?Symbol.for("react.suspense"):60113,m=o?Symbol.for("react.suspense_list"):60120,g=o?Symbol.for("react.memo"):60115,y=o?Symbol.for("react.lazy"):60116,b=o?Symbol.for("react.fundamental"):60117,x=o?Symbol.for("react.responder"):60118,v=o?Symbol.for("react.scope"):60119;function j(e){if("object"==typeof e&&null!==e){var n=e.$$typeof;switch(n){case r:switch(e=e.type){case h:case u:case s:case l:case a:case f:return e;default:switch(e=e&&e.$$typeof){case d:case p:case c:return e;default:return n}}case y:case g:case i:return n}}}function w(e){return j(e)===u}n.typeOf=j,n.AsyncMode=h,n.ConcurrentMode=u,n.ContextConsumer=d,n.ContextProvider=c,n.Element=r,n.ForwardRef=p,n.Fragment=s,n.Lazy=y,n.Memo=g,n.Portal=i,n.Profiler=l,n.StrictMode=a,n.Suspense=f,n.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===s||e===u||e===l||e===a||e===f||e===m||"object"==typeof e&&null!==e&&(e.$$typeof===y||e.$$typeof===g||e.$$typeof===c||e.$$typeof===d||e.$$typeof===p||e.$$typeof===b||e.$$typeof===x||e.$$typeof===v)},n.isAsyncMode=function(e){return w(e)||j(e)===h},n.isConcurrentMode=w,n.isContextConsumer=function(e){return j(e)===d},n.isContextProvider=function(e){return j(e)===c},n.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===r},n.isForwardRef=function(e){return j(e)===p},n.isFragment=function(e){return j(e)===s},n.isLazy=function(e){return j(e)===y},n.isMemo=function(e){return j(e)===g},n.isPortal=function(e){return j(e)===i},n.isProfiler=function(e){return j(e)===l},n.isStrictMode=function(e){return j(e)===a},n.isSuspense=function(e){return j(e)===f}},"./node_modules/react-is/index.js":function(e,n,t){"use strict";e.exports=t("./node_modules/react-is/cjs/react-is.production.min.js")},"./node_modules/react/cjs/react.production.min.js":function(e,n,t){"use strict";
/** @license React v16.11.0
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o=t("./node_modules/object-assign/index.js"),r="function"==typeof Symbol&&Symbol.for,i=r?Symbol.for("react.element"):60103,s=r?Symbol.for("react.portal"):60106,a=r?Symbol.for("react.fragment"):60107,l=r?Symbol.for("react.strict_mode"):60108,c=r?Symbol.for("react.profiler"):60114,d=r?Symbol.for("react.provider"):60109,h=r?Symbol.for("react.context"):60110,u=r?Symbol.for("react.forward_ref"):60112,p=r?Symbol.for("react.suspense"):60113;r&&Symbol.for("react.suspense_list");var f=r?Symbol.for("react.memo"):60115,m=r?Symbol.for("react.lazy"):60116;r&&Symbol.for("react.fundamental"),r&&Symbol.for("react.responder"),r&&Symbol.for("react.scope");var g="function"==typeof Symbol&&Symbol.iterator;function y(e){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)n+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x={};function v(e,n,t){this.props=e,this.context=n,this.refs=x,this.updater=t||b}function j(){}function w(e,n,t){this.props=e,this.context=n,this.refs=x,this.updater=t||b}v.prototype.isReactComponent={},v.prototype.setState=function(e,n){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error(y(85));this.updater.enqueueSetState(this,e,n,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},j.prototype=v.prototype;var k=w.prototype=new j;k.constructor=w,o(k,v.prototype),k.isPureReactComponent=!0;var _={current:null},S={current:null},C=Object.prototype.hasOwnProperty,A={key:!0,ref:!0,__self:!0,__source:!0};function T(e,n,t){var o,r={},s=null,a=null;if(null!=n)for(o in void 0!==n.ref&&(a=n.ref),void 0!==n.key&&(s=""+n.key),n)C.call(n,o)&&!A.hasOwnProperty(o)&&(r[o]=n[o]);var l=arguments.length-2;if(1===l)r.children=t;else if(1<l){for(var c=Array(l),d=0;d<l;d++)c[d]=arguments[d+2];r.children=c}if(e&&e.defaultProps)for(o in l=e.defaultProps)void 0===r[o]&&(r[o]=l[o]);return{$$typeof:i,type:e,key:s,ref:a,props:r,_owner:S.current}}function O(e){return"object"==typeof e&&null!==e&&e.$$typeof===i}var P=/\/+/g,M=[];function L(e,n,t,o){if(M.length){var r=M.pop();return r.result=e,r.keyPrefix=n,r.func=t,r.context=o,r.count=0,r}return{result:e,keyPrefix:n,func:t,context:o,count:0}}function H(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>M.length&&M.push(e)}function I(e,n,t){return null==e?0:function e(n,t,o,r){var a=typeof n;"undefined"!==a&&"boolean"!==a||(n=null);var l=!1;if(null===n)l=!0;else switch(a){case"string":case"number":l=!0;break;case"object":switch(n.$$typeof){case i:case s:l=!0}}if(l)return o(r,n,""===t?"."+D(n,0):t),1;if(l=0,t=""===t?".":t+":",Array.isArray(n))for(var c=0;c<n.length;c++){var d=t+D(a=n[c],c);l+=e(a,d,o,r)}else if(d=null===n||"object"!=typeof n?null:"function"==typeof(d=g&&n[g]||n["@@iterator"])?d:null,"function"==typeof d)for(n=d.call(n),c=0;!(a=n.next()).done;)l+=e(a=a.value,d=t+D(a,c++),o,r);else if("object"===a)throw o=""+n,Error(y(31,"[object Object]"===o?"object with keys {"+Object.keys(n).join(", ")+"}":o,""));return l}(e,"",n,t)}function D(e,n){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,function(e){return n[e]})}(e.key):n.toString(36)}function E(e,n){e.func.call(e.context,n,e.count++)}function B(e,n,t){var o=e.result,r=e.keyPrefix;e=e.func.call(e.context,n,e.count++),Array.isArray(e)?R(e,o,t,function(e){return e}):null!=e&&(O(e)&&(e=function(e,n){return{$$typeof:i,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}}(e,r+(!e.key||n&&n.key===e.key?"":(""+e.key).replace(P,"$&/")+"/")+t)),o.push(e))}function R(e,n,t,o,r){var i="";null!=t&&(i=(""+t).replace(P,"$&/")+"/"),I(e,B,n=L(n,i,o,r)),H(n)}function N(){var e=_.current;if(null===e)throw Error(y(321));return e}var z={Children:{map:function(e,n,t){if(null==e)return e;var o=[];return R(e,o,null,n,t),o},forEach:function(e,n,t){if(null==e)return e;I(e,E,n=L(null,null,n,t)),H(n)},count:function(e){return I(e,function(){return null},null)},toArray:function(e){var n=[];return R(e,n,null,function(e){return e}),n},only:function(e){if(!O(e))throw Error(y(143));return e}},createRef:function(){return{current:null}},Component:v,PureComponent:w,createContext:function(e,n){return void 0===n&&(n=null),(e={$$typeof:h,_calculateChangedBits:n,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:d,_context:e},e.Consumer=e},forwardRef:function(e){return{$$typeof:u,render:e}},lazy:function(e){return{$$typeof:m,_ctor:e,_status:-1,_result:null}},memo:function(e,n){return{$$typeof:f,type:e,compare:void 0===n?null:n}},useCallback:function(e,n){return N().useCallback(e,n)},useContext:function(e,n){return N().useContext(e,n)},useEffect:function(e,n){return N().useEffect(e,n)},useImperativeHandle:function(e,n,t){return N().useImperativeHandle(e,n,t)},useDebugValue:function(){},useLayoutEffect:function(e,n){return N().useLayoutEffect(e,n)},useMemo:function(e,n){return N().useMemo(e,n)},useReducer:function(e,n,t){return N().useReducer(e,n,t)},useRef:function(e){return N().useRef(e)},useState:function(e){return N().useState(e)},Fragment:a,Profiler:c,StrictMode:l,Suspense:p,createElement:T,cloneElement:function(e,n,t){if(null==e)throw Error(y(267,e));var r=o({},e.props),s=e.key,a=e.ref,l=e._owner;if(null!=n){if(void 0!==n.ref&&(a=n.ref,l=S.current),void 0!==n.key&&(s=""+n.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(d in n)C.call(n,d)&&!A.hasOwnProperty(d)&&(r[d]=void 0===n[d]&&void 0!==c?c[d]:n[d])}var d=arguments.length-2;if(1===d)r.children=t;else if(1<d){c=Array(d);for(var h=0;h<d;h++)c[h]=arguments[h+2];r.children=c}return{$$typeof:i,type:e.type,key:s,ref:a,props:r,_owner:l}},createFactory:function(e){var n=T.bind(null,e);return n.type=e,n},isValidElement:O,version:"16.11.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:_,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:S,IsSomeRendererActing:{current:!1},assign:o}},G={default:z},W=G&&z||G;e.exports=W.default||W},"./node_modules/react/index.js":function(e,n,t){"use strict";e.exports=t("./node_modules/react/cjs/react.production.min.js")},"./node_modules/regenerator-runtime/runtime.js":function(e,n,t){var o=function(e){"use strict";var n,t=Object.prototype,o=t.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",s=r.asyncIterator||"@@asyncIterator",a=r.toStringTag||"@@toStringTag";function l(e,n,t,o){var r=n&&n.prototype instanceof m?n:m,i=Object.create(r.prototype),s=new A(o||[]);return i._invoke=function(e,n,t){var o=d;return function(r,i){if(o===u)throw new Error("Generator is already running");if(o===p){if("throw"===r)throw i;return O()}for(t.method=r,t.arg=i;;){var s=t.delegate;if(s){var a=_(s,t);if(a){if(a===f)continue;return a}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(o===d)throw o=p,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o=u;var l=c(e,n,t);if("normal"===l.type){if(o=t.done?p:h,l.arg===f)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(o=p,t.method="throw",t.arg=l.arg)}}}(e,t,s),i}function c(e,n,t){try{return{type:"normal",arg:e.call(n,t)}}catch(e){return{type:"throw",arg:e}}}e.wrap=l;var d="suspendedStart",h="suspendedYield",u="executing",p="completed",f={};function m(){}function g(){}function y(){}var b={};b[i]=function(){return this};var x=Object.getPrototypeOf,v=x&&x(x(T([])));v&&v!==t&&o.call(v,i)&&(b=v);var j=y.prototype=m.prototype=Object.create(b);function w(e){["next","throw","return"].forEach(function(n){e[n]=function(e){return this._invoke(n,e)}})}function k(e){var n;this._invoke=function(t,r){function i(){return new Promise(function(n,i){!function n(t,r,i,s){var a=c(e[t],e,r);if("throw"!==a.type){var l=a.arg,d=l.value;return d&&"object"==typeof d&&o.call(d,"__await")?Promise.resolve(d.__await).then(function(e){n("next",e,i,s)},function(e){n("throw",e,i,s)}):Promise.resolve(d).then(function(e){l.value=e,i(l)},function(e){return n("throw",e,i,s)})}s(a.arg)}(t,r,n,i)})}return n=n?n.then(i,i):i()}}function _(e,t){var o=e.iterator[t.method];if(o===n){if(t.delegate=null,"throw"===t.method){if(e.iterator.return&&(t.method="return",t.arg=n,_(e,t),"throw"===t.method))return f;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return f}var r=c(o,e.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,f;var i=r.arg;return i?i.done?(t[e.resultName]=i.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=n),t.delegate=null,f):i:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,f)}function S(e){var n={tryLoc:e[0]};1 in e&&(n.catchLoc=e[1]),2 in e&&(n.finallyLoc=e[2],n.afterLoc=e[3]),this.tryEntries.push(n)}function C(e){var n=e.completion||{};n.type="normal",delete n.arg,e.completion=n}function A(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(S,this),this.reset(!0)}function T(e){if(e){var t=e[i];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,s=function t(){for(;++r<e.length;)if(o.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=n,t.done=!0,t};return s.next=s}}return{next:O}}function O(){return{value:n,done:!0}}return g.prototype=j.constructor=y,y.constructor=g,y[a]=g.displayName="GeneratorFunction",e.isGeneratorFunction=function(e){var n="function"==typeof e&&e.constructor;return!!n&&(n===g||"GeneratorFunction"===(n.displayName||n.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,y):(e.__proto__=y,a in e||(e[a]="GeneratorFunction")),e.prototype=Object.create(j),e},e.awrap=function(e){return{__await:e}},w(k.prototype),k.prototype[s]=function(){return this},e.AsyncIterator=k,e.async=function(n,t,o,r){var i=new k(l(n,t,o,r));return e.isGeneratorFunction(t)?i:i.next().then(function(e){return e.done?e.value:i.next()})},w(j),j[a]="Generator",j[i]=function(){return this},j.toString=function(){return"[object Generator]"},e.keys=function(e){var n=[];for(var t in e)n.push(t);return n.reverse(),function t(){for(;n.length;){var o=n.pop();if(o in e)return t.value=o,t.done=!1,t}return t.done=!0,t}},e.values=T,A.prototype={constructor:A,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(C),!e)for(var t in this)"t"===t.charAt(0)&&o.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=n)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(o,r){return a.type="throw",a.arg=e,t.next=o,r&&(t.method="next",t.arg=n),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var s=this.tryEntries[i],a=s.completion;if("root"===s.tryLoc)return r("end");if(s.tryLoc<=this.prev){var l=o.call(s,"catchLoc"),c=o.call(s,"finallyLoc");if(l&&c){if(this.prev<s.catchLoc)return r(s.catchLoc,!0);if(this.prev<s.finallyLoc)return r(s.finallyLoc)}else if(l){if(this.prev<s.catchLoc)return r(s.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return r(s.finallyLoc)}}}},abrupt:function(e,n){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc<=this.prev&&o.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var i=r;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var s=i?i.completion:{};return s.type=e,s.arg=n,i?(this.method="next",this.next=i.finallyLoc,f):this.complete(s)},complete:function(e,n){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&n&&(this.next=n),f},finish:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.finallyLoc===e)return this.complete(t.completion,t.afterLoc),C(t),f}},catch:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.tryLoc===e){var o=t.completion;if("throw"===o.type){var r=o.arg;C(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,o){return this.delegate={iterator:T(e),resultName:t,nextLoc:o},"next"===this.method&&(this.arg=n),f}},e}(e.exports);try{regeneratorRuntime=o}catch(e){Function("r","regeneratorRuntime = r")(o)}},"./node_modules/styled-components/dist/styled-components.browser.esm.js":function(e,n,t){"use strict";t.r(n),function(e){t.d(n,"createGlobalStyle",function(){return rn}),t.d(n,"css",function(){return ve}),t.d(n,"isStyledComponent",function(){return A}),t.d(n,"keyframes",function(){return an}),t.d(n,"ServerStyleSheet",function(){return Ke}),t.d(n,"StyleSheetConsumer",function(){return Ze}),t.d(n,"StyleSheetContext",function(){return $e}),t.d(n,"StyleSheetManager",function(){return Je}),t.d(n,"ThemeConsumer",function(){return Ue}),t.d(n,"ThemeContext",function(){return Ye}),t.d(n,"ThemeProvider",function(){return qe}),t.d(n,"withTheme",function(){return ln}),t.d(n,"__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS",function(){return cn});var o=t("./node_modules/stylis/stylis.min.js"),r=t.n(o),i=t("./node_modules/stylis-rule-sheet/index.js"),s=t.n(i),a=t("./node_modules/react/index.js"),l=t.n(a),c=t("./node_modules/@emotion/unitless/dist/unitless.browser.esm.js"),d=t("./node_modules/react-is/index.js"),h=t("./node_modules/memoize-one/dist/memoize-one.esm.js"),u=(t("./node_modules/prop-types/index.js"),t("./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js")),p=t("./node_modules/merge-anything/dist/index.esm.js"),f=function(e,n){for(var t=[e[0]],o=0,r=n.length;o<r;o+=1)t.push(n[o],e[o+1]);return t},m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},g=function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")},y=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),b=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},x=function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)},v=function(e,n){var t={};for(var o in e)n.indexOf(o)>=0||Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t},j=function(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n},w=function(e){return"object"===(void 0===e?"undefined":m(e))&&e.constructor===Object},k=Object.freeze([]),_=Object.freeze({});function S(e){return"function"==typeof e}function C(e){return e.displayName||e.name||"Component"}function A(e){return e&&"string"==typeof e.styledComponentId}var T=void 0!==e&&(e.env.REACT_APP_SC_ATTR||"mltk-viz-styled-components")||"data-styled",O="undefined"!=typeof window&&"HTMLElement"in window,P="boolean"==typeof SC_DISABLE_SPEEDY&&SC_DISABLE_SPEEDY||void 0!==e&&(e.env.REACT_APP_SC_DISABLE_SPEEDY||e.env.SC_DISABLE_SPEEDY)||!1,M={};var L=function(e){function n(t){g(this,n);for(var o=arguments.length,r=Array(o>1?o-1:0),i=1;i<o;i++)r[i-1]=arguments[i];var s=j(this,e.call(this,"An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#"+t+" for more information."+(r.length>0?" Additional arguments: "+r.join(", "):"")));return j(s)}return x(n,e),n}(Error),H=/^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm,I=function(e){var n=""+(e||""),t=[];return n.replace(H,function(e,n,o){return t.push({componentId:n,matchIndex:o}),e}),t.map(function(e,o){var r=e.componentId,i=e.matchIndex,s=t[o+1];return{componentId:r,cssFromDOM:s?n.slice(i,s.matchIndex):n.slice(i)}})},D=/^\s*\/\/.*$/gm,E=new r.a({global:!1,cascade:!0,keyframe:!1,prefix:!1,compress:!1,semicolon:!0}),B=new r.a({global:!1,cascade:!0,keyframe:!1,prefix:!0,compress:!1,semicolon:!1}),R=[],N=function(e){if(-2===e){var n=R;return R=[],n}},z=s()(function(e){R.push(e)}),G=void 0,W=void 0,F=void 0,X=function(e,n,t){return n>0&&-1!==t.slice(0,n).indexOf(W)&&t.slice(n-W.length,n)!==W?"."+G:e};B.use([function(e,n,t){2===e&&t.length&&t[0].lastIndexOf(W)>0&&(t[0]=t[0].replace(F,X))},z,N]),E.use([z,N]);var V=function(e){return E("",e)};function Y(e,n,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"&",r=e.join("").replace(D,""),i=n&&t?t+" "+n+" { "+r+" }":r;return G=o,W=n,F=new RegExp("\\"+W+"\\b","g"),B(t||!n?"":n,i)}var U=function(){return t.nc},q=function(e,n,t){t&&((e[n]||(e[n]=Object.create(null)))[t]=!0)},K=function(e,n){e[n]=Object.create(null)},$=function(e){return function(n,t){return void 0!==e[n]&&e[n][t]}},Z=function(e){var n="";for(var t in e)n+=Object.keys(e[t]).join(" ")+" ";return n.trim()},J=function(e){if(e.sheet)return e.sheet;for(var n=e.ownerDocument.styleSheets.length,t=0;t<n;t+=1){var o=e.ownerDocument.styleSheets[t];if(o.ownerNode===e)return o}throw new L(10)},Q=function(e,n,t){if(!n)return!1;var o=e.cssRules.length;try{e.insertRule(n,t<=o?t:o)}catch(e){return!1}return!0},ee=function(e){return"\n/* sc-component-id: "+e+" */\n"},ne=function(e,n){for(var t=0,o=0;o<=n;o+=1)t+=e[o];return t},te=function(e,n){return function(t){var o=U();return"<style "+[o&&'nonce="'+o+'"',T+'="'+Z(n)+'"','data-styled-version="4.4.1"',t].filter(Boolean).join(" ")+">"+e()+"</style>"}},oe=function(e,n){return function(){var t,o=((t={})[T]=Z(n),t["data-styled-version"]="4.4.1",t),r=U();return r&&(o.nonce=r),l.a.createElement("style",b({},o,{dangerouslySetInnerHTML:{__html:e()}}))}},re=function(e){return function(){return Object.keys(e)}},ie=function(e,n){return e.createTextNode(ee(n))},se=function e(n,t){var o=void 0===n?Object.create(null):n,r=void 0===t?Object.create(null):t,i=function(e){var n=r[e];return void 0!==n?n:r[e]=[""]},s=function(){var e="";for(var n in r){var t=r[n][0];t&&(e+=ee(n)+t)}return e};return{clone:function(){var n=function(e){var n=Object.create(null);for(var t in e)n[t]=b({},e[t]);return n}(o),t=Object.create(null);for(var i in r)t[i]=[r[i][0]];return e(n,t)},css:s,getIds:re(r),hasNameForId:$(o),insertMarker:i,insertRules:function(e,n,t){i(e)[0]+=n.join(" "),q(o,e,t)},removeRules:function(e){var n=r[e];void 0!==n&&(n[0]="",K(o,e))},sealed:!1,styleTag:null,toElement:oe(s,o),toHTML:te(s,o)}},ae=function(e,n,t,o,r){if(O&&!t){var i=function(e,n,t){var o=document;e?o=e.ownerDocument:n&&(o=n.ownerDocument);var r=o.createElement("style");r.setAttribute(T,""),r.setAttribute("data-styled-version","4.4.1");var i=U();if(i&&r.setAttribute("nonce",i),r.appendChild(o.createTextNode("")),e&&!n)e.appendChild(r);else{if(!n||!e||!n.parentNode)throw new L(6);n.parentNode.insertBefore(r,t?n:n.nextSibling)}return r}(e,n,o);return P?function(e,n){var t=Object.create(null),o=Object.create(null),r=void 0!==n,i=!1,s=function(n){var r=o[n];return void 0!==r?r:(o[n]=ie(e.ownerDocument,n),e.appendChild(o[n]),t[n]=Object.create(null),o[n])},a=function(){var e="";for(var n in o)e+=o[n].data;return e};return{clone:function(){throw new L(5)},css:a,getIds:re(o),hasNameForId:$(t),insertMarker:s,insertRules:function(e,o,a){for(var l=s(e),c=[],d=o.length,h=0;h<d;h+=1){var u=o[h],p=r;if(p&&-1!==u.indexOf("@import"))c.push(u);else{p=!1;var f=h===d-1?"":" ";l.appendData(""+u+f)}}q(t,e,a),r&&c.length>0&&(i=!0,n().insertRules(e+"-import",c))},removeRules:function(s){var a=o[s];if(void 0!==a){var l=ie(e.ownerDocument,s);e.replaceChild(l,a),o[s]=l,K(t,s),r&&i&&n().removeRules(s+"-import")}},sealed:!1,styleTag:e,toElement:oe(a,t),toHTML:te(a,t)}}(i,r):function(e,n){var t=Object.create(null),o=Object.create(null),r=[],i=void 0!==n,s=!1,a=function(e){var n=o[e];return void 0!==n?n:(o[e]=r.length,r.push(0),K(t,e),o[e])},l=function(){var n=J(e).cssRules,t="";for(var i in o){t+=ee(i);for(var s=o[i],a=ne(r,s),l=a-r[s];l<a;l+=1){var c=n[l];void 0!==c&&(t+=c.cssText)}}return t};return{clone:function(){throw new L(5)},css:l,getIds:re(o),hasNameForId:$(t),insertMarker:a,insertRules:function(o,l,c){for(var d=a(o),h=J(e),u=ne(r,d),p=0,f=[],m=l.length,g=0;g<m;g+=1){var y=l[g],b=i;b&&-1!==y.indexOf("@import")?f.push(y):Q(h,y,u+p)&&(b=!1,p+=1)}i&&f.length>0&&(s=!0,n().insertRules(o+"-import",f)),r[d]+=p,q(t,o,c)},removeRules:function(a){var l=o[a];if(void 0!==l&&!1!==e.isConnected){var c=r[l];!function(e,n,t){for(var o=n-t,r=n;r>o;r-=1)e.deleteRule(r)}(J(e),ne(r,l)-1,c),r[l]=0,K(t,a),i&&s&&n().removeRules(a+"-import")}},sealed:!1,styleTag:e,toElement:oe(l,t),toHTML:te(l,t)}}(i,r)}return se()},le=/\s+/,ce=void 0;ce=O?P?40:1e3:-1;var de=0,he=void 0,ue=function(){function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O?document.head:null,o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];g(this,e),this.getImportRuleTag=function(){var e=n.importRuleTag;if(void 0!==e)return e;var t=n.tags[0];return n.importRuleTag=ae(n.target,t?t.styleTag:null,n.forceServer,!0)},de+=1,this.id=de,this.forceServer=o,this.target=o?null:t,this.tagMap={},this.deferred={},this.rehydratedNames={},this.ignoreRehydratedNames={},this.tags=[],this.capacity=1,this.clones=[]}return e.prototype.rehydrate=function(){if(!O||this.forceServer)return this;var e=[],n=[],t=!1,o=document.querySelectorAll("style["+T+'][data-styled-version="4.4.1"]'),r=o.length;if(!r)return this;for(var i=0;i<r;i+=1){var s=o[i];t||(t=!!s.getAttribute("data-styled-streamed"));for(var a,l=(s.getAttribute(T)||"").trim().split(le),c=l.length,d=0;d<c;d+=1)a=l[d],this.rehydratedNames[a]=!0;n.push.apply(n,I(s.textContent)),e.push(s)}var h=n.length;if(!h)return this;var u=this.makeTag(null);!function(e,n,t){for(var o=0,r=t.length;o<r;o+=1){var i=t[o],s=i.componentId,a=i.cssFromDOM,l=V(a);e.insertRules(s,l)}for(var c=0,d=n.length;c<d;c+=1){var h=n[c];h.parentNode&&h.parentNode.removeChild(h)}}(u,e,n),this.capacity=Math.max(1,ce-h),this.tags.push(u);for(var p=0;p<h;p+=1)this.tagMap[n[p].componentId]=u;return this},e.reset=function(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];he=new e(void 0,n).rehydrate()},e.prototype.clone=function(){var n=new e(this.target,this.forceServer);return this.clones.push(n),n.tags=this.tags.map(function(e){for(var t=e.getIds(),o=e.clone(),r=0;r<t.length;r+=1)n.tagMap[t[r]]=o;return o}),n.rehydratedNames=b({},this.rehydratedNames),n.deferred=b({},this.deferred),n},e.prototype.sealAllTags=function(){this.capacity=1,this.tags.forEach(function(e){e.sealed=!0})},e.prototype.makeTag=function(e){var n=e?e.styleTag:null;return ae(this.target,n,this.forceServer,!1,this.getImportRuleTag)},e.prototype.getTagForId=function(e){var n=this.tagMap[e];if(void 0!==n&&!n.sealed)return n;var t=this.tags[this.tags.length-1];return this.capacity-=1,0===this.capacity&&(this.capacity=ce,t=this.makeTag(t),this.tags.push(t)),this.tagMap[e]=t},e.prototype.hasId=function(e){return void 0!==this.tagMap[e]},e.prototype.hasNameForId=function(e,n){if(void 0===this.ignoreRehydratedNames[e]&&this.rehydratedNames[n])return!0;var t=this.tagMap[e];return void 0!==t&&t.hasNameForId(e,n)},e.prototype.deferredInject=function(e,n){if(void 0===this.tagMap[e]){for(var t=this.clones,o=0;o<t.length;o+=1)t[o].deferredInject(e,n);this.getTagForId(e).insertMarker(e),this.deferred[e]=n}},e.prototype.inject=function(e,n,t){for(var o=this.clones,r=0;r<o.length;r+=1)o[r].inject(e,n,t);var i=this.getTagForId(e);if(void 0!==this.deferred[e]){var s=this.deferred[e].concat(n);i.insertRules(e,s,t),this.deferred[e]=void 0}else i.insertRules(e,n,t)},e.prototype.remove=function(e){var n=this.tagMap[e];if(void 0!==n){for(var t=this.clones,o=0;o<t.length;o+=1)t[o].remove(e);n.removeRules(e),this.ignoreRehydratedNames[e]=!0,this.deferred[e]=void 0}},e.prototype.toHTML=function(){return this.tags.map(function(e){return e.toHTML()}).join("")},e.prototype.toReactElements=function(){var e=this.id;return this.tags.map(function(n,t){var o="sc-"+e+"-"+t;return Object(a.cloneElement)(n.toElement(),{key:o})})},y(e,null,[{key:"master",get:function(){return he||(he=(new e).rehydrate())}},{key:"instance",get:function(){return e.master}}]),e}(),pe=function(){function e(n,t){var o=this;g(this,e),this.inject=function(e){e.hasNameForId(o.id,o.name)||e.inject(o.id,o.rules,o.name)},this.toString=function(){throw new L(12,String(o.name))},this.name=n,this.rules=t,this.id="sc-keyframes-"+n}return e.prototype.getName=function(){return this.name},e}(),fe=/([A-Z])/g,me=/^ms-/;function ge(e){return e.replace(fe,"-$1").toLowerCase().replace(me,"-ms-")}var ye=function(e){return null==e||!1===e||""===e},be=function e(n,t){var o=[];return Object.keys(n).forEach(function(t){if(!ye(n[t])){if(w(n[t]))return o.push.apply(o,e(n[t],t)),o;if(S(n[t]))return o.push(ge(t)+":",n[t],";"),o;o.push(ge(t)+": "+(r=t,null==(i=n[t])||"boolean"==typeof i||""===i?"":"number"!=typeof i||0===i||r in c.a?String(i).trim():i+"px")+";")}var r,i;return o}),t?[t+" {"].concat(o,["}"]):o};function xe(e,n,t){if(Array.isArray(e)){for(var o,r=[],i=0,s=e.length;i<s;i+=1)null!==(o=xe(e[i],n,t))&&(Array.isArray(o)?r.push.apply(r,o):r.push(o));return r}return ye(e)?null:A(e)?"."+e.styledComponentId:S(e)?"function"!=typeof(a=e)||a.prototype&&a.prototype.isReactComponent||!n?e:xe(e(n),n,t):e instanceof pe?t?(e.inject(t),e.getName()):e:w(e)?be(e):e.toString();var a}function ve(e){for(var n=arguments.length,t=Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];return S(e)||w(e)?xe(f(k,[e].concat(t))):xe(f(e,t))}function je(e){for(var n,t=0|e.length,o=0|t,r=0;t>=4;)n=1540483477*(65535&(n=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+((1540483477*(n>>>16)&65535)<<16),o=1540483477*(65535&o)+((1540483477*(o>>>16)&65535)<<16)^(n=1540483477*(65535&(n^=n>>>24))+((1540483477*(n>>>16)&65535)<<16)),t-=4,++r;switch(t){case 3:o^=(255&e.charCodeAt(r+2))<<16;case 2:o^=(255&e.charCodeAt(r+1))<<8;case 1:o=1540483477*(65535&(o^=255&e.charCodeAt(r)))+((1540483477*(o>>>16)&65535)<<16)}return((o=1540483477*(65535&(o^=o>>>13))+((1540483477*(o>>>16)&65535)<<16))^o>>>15)>>>0}var we=52,ke=function(e){return String.fromCharCode(e+(e>25?39:97))};function _e(e){var n="",t=void 0;for(t=e;t>we;t=Math.floor(t/we))n=ke(t%we)+n;return ke(t%we)+n}function Se(e,n){for(var t=0;t<e.length;t+=1){var o=e[t];if(Array.isArray(o)&&!Se(o,n))return!1;if(S(o)&&!A(o))return!1}return!n.some(function(e){return S(e)||function(e){for(var n in e)if(S(e[n]))return!0;return!1}(e)})}var Ce,Ae=function(e){return _e(je(e))},Te=function(){function e(n,t,o){g(this,e),this.rules=n,this.isStatic=Se(n,t),this.componentId=o,ue.master.hasId(o)||ue.master.deferredInject(o,[])}return e.prototype.generateAndInjectStyles=function(e,n){var t=this.isStatic,o=this.componentId,r=this.lastClassName;if(O&&t&&"string"==typeof r&&n.hasNameForId(o,r))return r;var i=xe(this.rules,e,n),s=Ae(this.componentId+i.join(""));return n.hasNameForId(o,s)||n.inject(this.componentId,Y(i,"."+s,void 0,o),s),this.lastClassName=s,s},e.generateName=function(e){return Ae(e)},e}(),Oe=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_,o=!!t&&e.theme===t.theme;return e.theme&&!o?e.theme:n||t.theme},Pe=/[[\].#*$><+~=|^:(),"'`-]+/g,Me=/(^-|-$)/g;function Le(e){return e.replace(Pe,"-").replace(Me,"")}function He(e){return"string"==typeof e&&!0}var Ie={childContextTypes:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDerivedStateFromProps:!0,propTypes:!0,type:!0},De={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},Ee=((Ce={})[d.ForwardRef]={$$typeof:!0,render:!0},Ce),Be=Object.defineProperty,Re=Object.getOwnPropertyNames,Ne=Object.getOwnPropertySymbols,ze=void 0===Ne?function(){return[]}:Ne,Ge=Object.getOwnPropertyDescriptor,We=Object.getPrototypeOf,Fe=Object.prototype,Xe=Array.prototype;function Ve(e,n,t){if("string"!=typeof n){var o=We(n);o&&o!==Fe&&Ve(e,o,t);for(var r=Xe.concat(Re(n),ze(n)),i=Ee[e.$$typeof]||Ie,s=Ee[n.$$typeof]||Ie,a=r.length,l=void 0,c=void 0;a--;)if(c=r[a],!(De[c]||t&&t[c]||s&&s[c]||i&&i[c])&&(l=Ge(n,c)))try{Be(e,c,l)}catch(e){}return e}return e}var Ye=Object(a.createContext)(),Ue=Ye.Consumer,qe=function(e){function n(t){g(this,n);var o=j(this,e.call(this,t));return o.getContext=Object(h.a)(o.getContext.bind(o)),o.renderInner=o.renderInner.bind(o),o}return x(n,e),n.prototype.render=function(){return this.props.children?l.a.createElement(Ye.Consumer,null,this.renderInner):null},n.prototype.renderInner=function(e){var n=this.getContext(this.props.theme,e);return l.a.createElement(Ye.Provider,{value:n},this.props.children)},n.prototype.getTheme=function(e,n){if(S(e))return e(n);if(null===e||Array.isArray(e)||"object"!==(void 0===e?"undefined":m(e)))throw new L(8);return b({},n,e)},n.prototype.getContext=function(e,n){return this.getTheme(e,n)},n}(a.Component),Ke=function(){function e(){g(this,e),this.masterSheet=ue.master,this.instance=this.masterSheet.clone(),this.sealed=!1}return e.prototype.seal=function(){if(!this.sealed){var e=this.masterSheet.clones.indexOf(this.instance);this.masterSheet.clones.splice(e,1),this.sealed=!0}},e.prototype.collectStyles=function(e){if(this.sealed)throw new L(2);return l.a.createElement(Je,{sheet:this.instance},e)},e.prototype.getStyleTags=function(){return this.seal(),this.instance.toHTML()},e.prototype.getStyleElement=function(){return this.seal(),this.instance.toReactElements()},e.prototype.interleaveWithNodeStream=function(e){throw new L(3)},e}(),$e=Object(a.createContext)(),Ze=$e.Consumer,Je=function(e){function n(t){g(this,n);var o=j(this,e.call(this,t));return o.getContext=Object(h.a)(o.getContext),o}return x(n,e),n.prototype.getContext=function(e,n){if(e)return e;if(n)return new ue(n);throw new L(4)},n.prototype.render=function(){var e=this.props,n=e.children,t=e.sheet,o=e.target;return l.a.createElement($e.Provider,{value:this.getContext(t,o)},n)},n}(a.Component),Qe={};var en=function(e){function n(){g(this,n);var t=j(this,e.call(this));return t.attrs={},t.renderOuter=t.renderOuter.bind(t),t.renderInner=t.renderInner.bind(t),t}return x(n,e),n.prototype.render=function(){return l.a.createElement(Ze,null,this.renderOuter)},n.prototype.renderOuter=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ue.master;return this.styleSheet=e,this.props.forwardedComponent.componentStyle.isStatic?this.renderInner():l.a.createElement(Ue,null,this.renderInner)},n.prototype.renderInner=function(e){var n=this.props.forwardedComponent,t=n.componentStyle,o=n.defaultProps,r=(n.displayName,n.foldedComponentIds),i=n.styledComponentId,s=n.target,l=void 0;l=t.isStatic?this.generateAndInjectStyles(_,this.props):this.generateAndInjectStyles(Oe(this.props,e,o)||_,this.props);var c=this.props.as||this.attrs.as||s,d=He(c),h={},p=b({},this.props,this.attrs),f=void 0;for(f in p)"forwardedComponent"!==f&&"as"!==f&&("forwardedRef"===f?h.ref=p[f]:"forwardedAs"===f?h.as=p[f]:d&&!Object(u.a)(f)||(h[f]=p[f]));return this.props.style&&this.attrs.style&&(h.style=b({},this.attrs.style,this.props.style)),h.className=Array.prototype.concat(r,i,l!==i?l:null,this.props.className,this.attrs.className).filter(Boolean).join(" "),Object(a.createElement)(c,h)},n.prototype.buildExecutionContext=function(e,n,t){var o=this,r=b({},n,{theme:e});return t.length?(this.attrs={},t.forEach(function(e){var n,t=e,i=!1,s=void 0,a=void 0;for(a in S(t)&&(t=t(r),i=!0),t)s=t[a],i||!S(s)||(n=s)&&n.prototype&&n.prototype.isReactComponent||A(s)||(s=s(r)),o.attrs[a]=s,r[a]=s}),r):r},n.prototype.generateAndInjectStyles=function(e,n){var t=n.forwardedComponent,o=t.attrs,r=t.componentStyle;t.warnTooManyClasses;return r.isStatic&&!o.length?r.generateAndInjectStyles(_,this.styleSheet):r.generateAndInjectStyles(this.buildExecutionContext(e,n,o),this.styleSheet)},n}(a.Component);function nn(e,n,t){var o=A(e),r=!He(e),i=n.displayName,s=void 0===i?function(e){return He(e)?"styled."+e:"Styled("+C(e)+")"}(e):i,a=n.componentId,c=void 0===a?function(e,n,t){var o="string"!=typeof n?"sc":Le(n),r=(Qe[o]||0)+1;Qe[o]=r;var i=o+"-"+e.generateName(o+r);return t?t+"-"+i:i}(Te,n.displayName,n.parentComponentId):a,d=n.ParentComponent,h=void 0===d?en:d,u=n.attrs,f=void 0===u?k:u,m=n.displayName&&n.componentId?Le(n.displayName)+"-"+n.componentId:n.componentId||c,g=o&&e.attrs?Array.prototype.concat(e.attrs,f).filter(Boolean):f,y=new Te(o?e.componentStyle.rules.concat(t):t,g,m),x=void 0,j=function(e,n){return l.a.createElement(h,b({},e,{forwardedComponent:x,forwardedRef:n}))};return j.displayName=s,(x=l.a.forwardRef(j)).displayName=s,x.attrs=g,x.componentStyle=y,x.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):k,x.styledComponentId=m,x.target=o?e.target:e,x.withComponent=function(e){var o=n.componentId,r=v(n,["componentId"]),i=o&&o+"-"+(He(e)?e:Le(C(e)));return nn(e,b({},r,{attrs:g,componentId:i,ParentComponent:h}),t)},Object.defineProperty(x,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(n){this._foldedDefaultProps=o?Object(p.a)(e.defaultProps,n):n}}),x.toString=function(){return"."+x.styledComponentId},r&&Ve(x,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,styledComponentId:!0,target:!0,withComponent:!0}),x}var tn=function(e){return function e(n,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_;if(!Object(d.isValidElementType)(t))throw new L(1,String(t));var r=function(){return n(t,o,ve.apply(void 0,arguments))};return r.withConfig=function(r){return e(n,t,b({},o,r))},r.attrs=function(r){return e(n,t,b({},o,{attrs:Array.prototype.concat(o.attrs,r).filter(Boolean)}))},r}(nn,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"].forEach(function(e){tn[e]=tn(e)});var on=function(){function e(n,t){g(this,e),this.rules=n,this.componentId=t,this.isStatic=Se(n,k),ue.master.hasId(t)||ue.master.deferredInject(t,[])}return e.prototype.createStyles=function(e,n){var t=Y(xe(this.rules,e,n),"");n.inject(this.componentId,t)},e.prototype.removeStyles=function(e){var n=this.componentId;e.hasId(n)&&e.remove(n)},e.prototype.renderStyles=function(e,n){this.removeStyles(n),this.createStyles(e,n)},e}();function rn(e){for(var n=arguments.length,t=Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];var r=ve.apply(void 0,[e].concat(t)),i="sc-global-"+je(JSON.stringify(r)),s=new on(r,i),a=function(e){function n(t){g(this,n);var o=j(this,e.call(this,t)),r=o.constructor,i=r.globalStyle,s=r.styledComponentId;return O&&(window.scCGSHMRCache[s]=(window.scCGSHMRCache[s]||0)+1),o.state={globalStyle:i,styledComponentId:s},o}return x(n,e),n.prototype.componentWillUnmount=function(){window.scCGSHMRCache[this.state.styledComponentId]&&(window.scCGSHMRCache[this.state.styledComponentId]-=1),0===window.scCGSHMRCache[this.state.styledComponentId]&&this.state.globalStyle.removeStyles(this.styleSheet)},n.prototype.render=function(){var e=this;return l.a.createElement(Ze,null,function(n){e.styleSheet=n||ue.master;var t=e.state.globalStyle;return t.isStatic?(t.renderStyles(M,e.styleSheet),null):l.a.createElement(Ue,null,function(n){var o=e.constructor.defaultProps,r=b({},e.props);return void 0!==n&&(r.theme=Oe(e.props,n,o)),t.renderStyles(r,e.styleSheet),null})})},n}(l.a.Component);return a.globalStyle=s,a.styledComponentId=i,a}O&&(window.scCGSHMRCache={});var sn=function(e){return e.replace(/\s|\\n/g,"")};function an(e){for(var n=arguments.length,t=Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];var r=ve.apply(void 0,[e].concat(t)),i=_e(je(sn(JSON.stringify(r))));return new pe(i,Y(r,i,"@keyframes"))}var ln=function(e){var n=l.a.forwardRef(function(n,t){return l.a.createElement(Ue,null,function(o){var r=e.defaultProps,i=Oe(n,o,r);return l.a.createElement(e,b({},n,{theme:i,ref:t}))})});return Ve(n,e),n.displayName="WithTheme("+C(e)+")",n},cn={StyleSheet:ue};n.default=tn}.call(this,t("./node_modules/process/browser.js"))},"./node_modules/stylis-rule-sheet/index.js":function(e,n,t){e.exports=function(){"use strict";return function(e){function n(n){if(n)try{e(n+"}")}catch(e){}}return function(t,o,r,i,s,a,l,c,d,h){switch(t){case 1:if(0===d&&64===o.charCodeAt(0))return e(o+";"),"";break;case 2:if(0===c)return o+"/*|*/";break;case 3:switch(c){case 102:case 112:return e(r[0]+o),"";default:return o+(0===h?"/*|*/":"")}case-2:o.split("/*|*/}").forEach(n)}}}}()},"./node_modules/stylis/stylis.min.js":function(e,n,t){e.exports=function e(n){"use strict";var t=/^\0+/g,o=/[\0\r\f]/g,r=/: */g,i=/zoo|gra/,s=/([,: ])(transform)/g,a=/,+\s*(?![^(]*[)])/g,l=/ +\s*(?![^(]*[)])/g,c=/ *[\0] */g,d=/,\r+?/g,h=/([\t\r\n ])*\f?&/g,u=/:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g,p=/\W+/g,f=/@(k\w+)\s*(\S*)\s*/,m=/::(place)/g,g=/:(read-only)/g,y=/\s+(?=[{\];=:>])/g,b=/([[}=:>])\s+/g,x=/(\{[^{]+?);(?=\})/g,v=/\s{2,}/g,j=/([^\(])(:+) */g,w=/[svh]\w+-[tblr]{2}/,k=/\(\s*(.*)\s*\)/g,_=/([\s\S]*?);/g,S=/-self|flex-/g,C=/[^]*?(:[rp][el]a[\w-]+)[^]*/,A=/stretch|:\s*\w+\-(?:conte|avail)/,T=/([^-])(image-set\()/,O="-webkit-",P="-moz-",M="-ms-",L=59,H=125,I=123,D=40,E=41,B=91,R=93,N=10,z=13,G=9,W=64,F=32,X=38,V=45,Y=95,U=42,q=44,K=58,$=39,Z=34,J=47,Q=62,ee=43,ne=126,te=0,oe=12,re=11,ie=107,se=109,ae=115,le=112,ce=111,de=105,he=99,ue=100,pe=112,fe=1,me=1,ge=0,ye=1,be=1,xe=1,ve=0,je=0,we=0,ke=[],_e=[],Se=0,Ce=null,Ae=-2,Te=-1,Oe=0,Pe=1,Me=2,Le=3,He=0,Ie=1,De="",Ee="",Be="";function Re(e,n,r,i,s){for(var a,l,d=0,h=0,u=0,p=0,y=0,b=0,x=0,v=0,w=0,_=0,S=0,C=0,A=0,T=0,Y=0,ve=0,_e=0,Ce=0,Ae=0,Te=r.length,ze=Te-1,Ye="",Ue="",qe="",Ke="",$e="",Ze="";Y<Te;){if(x=r.charCodeAt(Y),Y===ze&&h+p+u+d!==0&&(0!==h&&(x=h===J?N:J),p=u=d=0,Te++,ze++),h+p+u+d===0){if(Y===ze&&(ve>0&&(Ue=Ue.replace(o,"")),Ue.trim().length>0)){switch(x){case F:case G:case L:case z:case N:break;default:Ue+=r.charAt(Y)}x=L}if(1===_e)switch(x){case I:case H:case L:case Z:case $:case D:case E:case q:_e=0;case G:case z:case N:case F:break;default:for(_e=0,Ae=Y,y=x,Y--,x=L;Ae<Te;)switch(r.charCodeAt(Ae++)){case N:case z:case L:++Y,x=y,Ae=Te;break;case K:ve>0&&(++Y,x=y);case I:Ae=Te}}switch(x){case I:for(y=(Ue=Ue.trim()).charCodeAt(0),S=1,Ae=++Y;Y<Te;){switch(x=r.charCodeAt(Y)){case I:S++;break;case H:S--;break;case J:switch(b=r.charCodeAt(Y+1)){case U:case J:Y=Ve(b,Y,ze,r)}break;case B:x++;case D:x++;case Z:case $:for(;Y++<ze&&r.charCodeAt(Y)!==x;);}if(0===S)break;Y++}switch(qe=r.substring(Ae,Y),y===te&&(y=(Ue=Ue.replace(t,"").trim()).charCodeAt(0)),y){case W:switch(ve>0&&(Ue=Ue.replace(o,"")),b=Ue.charCodeAt(1)){case ue:case se:case ae:case V:a=n;break;default:a=ke}if(Ae=(qe=Re(n,a,qe,b,s+1)).length,we>0&&0===Ae&&(Ae=Ue.length),Se>0&&(a=Ne(ke,Ue,Ce),l=Xe(Le,qe,a,n,me,fe,Ae,b,s,i),Ue=a.join(""),void 0!==l&&0===(Ae=(qe=l.trim()).length)&&(b=0,qe="")),Ae>0)switch(b){case ae:Ue=Ue.replace(k,Fe);case ue:case se:case V:qe=Ue+"{"+qe+"}";break;case ie:qe=(Ue=Ue.replace(f,"$1 $2"+(Ie>0?De:"")))+"{"+qe+"}",qe=1===be||2===be&&We("@"+qe,3)?"@"+O+qe+"@"+qe:"@"+qe;break;default:qe=Ue+qe,i===pe&&(Ke+=qe,qe="")}else qe="";break;default:qe=Re(n,Ne(n,Ue,Ce),qe,i,s+1)}$e+=qe,C=0,_e=0,T=0,ve=0,Ce=0,A=0,Ue="",qe="",x=r.charCodeAt(++Y);break;case H:case L:if((Ae=(Ue=(ve>0?Ue.replace(o,""):Ue).trim()).length)>1)switch(0===T&&((y=Ue.charCodeAt(0))===V||y>96&&y<123)&&(Ae=(Ue=Ue.replace(" ",":")).length),Se>0&&void 0!==(l=Xe(Pe,Ue,n,e,me,fe,Ke.length,i,s,i))&&0===(Ae=(Ue=l.trim()).length)&&(Ue="\0\0"),y=Ue.charCodeAt(0),b=Ue.charCodeAt(1),y){case te:break;case W:if(b===de||b===he){Ze+=Ue+r.charAt(Y);break}default:if(Ue.charCodeAt(Ae-1)===K)break;Ke+=Ge(Ue,y,b,Ue.charCodeAt(2))}C=0,_e=0,T=0,ve=0,Ce=0,Ue="",x=r.charCodeAt(++Y)}}switch(x){case z:case N:if(h+p+u+d+je===0)switch(_){case E:case $:case Z:case W:case ne:case Q:case U:case ee:case J:case V:case K:case q:case L:case I:case H:break;default:T>0&&(_e=1)}h===J?h=0:ye+C===0&&i!==ie&&Ue.length>0&&(ve=1,Ue+="\0"),Se*He>0&&Xe(Oe,Ue,n,e,me,fe,Ke.length,i,s,i),fe=1,me++;break;case L:case H:if(h+p+u+d===0){fe++;break}default:switch(fe++,Ye=r.charAt(Y),x){case G:case F:if(p+d+h===0)switch(v){case q:case K:case G:case F:Ye="";break;default:x!==F&&(Ye=" ")}break;case te:Ye="\\0";break;case oe:Ye="\\f";break;case re:Ye="\\v";break;case X:p+h+d===0&&ye>0&&(Ce=1,ve=1,Ye="\f"+Ye);break;case 108:if(p+h+d+ge===0&&T>0)switch(Y-T){case 2:v===le&&r.charCodeAt(Y-3)===K&&(ge=v);case 8:w===ce&&(ge=w)}break;case K:p+h+d===0&&(T=Y);break;case q:h+u+p+d===0&&(ve=1,Ye+="\r");break;case Z:case $:0===h&&(p=p===x?0:0===p?x:p);break;case B:p+h+u===0&&d++;break;case R:p+h+u===0&&d--;break;case E:p+h+d===0&&u--;break;case D:if(p+h+d===0){if(0===C)switch(2*v+3*w){case 533:break;default:S=0,C=1}u++}break;case W:h+u+p+d+T+A===0&&(A=1);break;case U:case J:if(p+d+u>0)break;switch(h){case 0:switch(2*x+3*r.charCodeAt(Y+1)){case 235:h=J;break;case 220:Ae=Y,h=U}break;case U:x===J&&v===U&&Ae+2!==Y&&(33===r.charCodeAt(Ae+2)&&(Ke+=r.substring(Ae,Y+1)),Ye="",h=0)}}if(0===h){if(ye+p+d+A===0&&i!==ie&&x!==L)switch(x){case q:case ne:case Q:case ee:case E:case D:if(0===C){switch(v){case G:case F:case N:case z:Ye+="\0";break;default:Ye="\0"+Ye+(x===q?"":"\0")}ve=1}else switch(x){case D:T+7===Y&&108===v&&(T=0),C=++S;break;case E:0==(C=--S)&&(ve=1,Ye+="\0")}break;case G:case F:switch(v){case te:case I:case H:case L:case q:case oe:case G:case F:case N:case z:break;default:0===C&&(ve=1,Ye+="\0")}}Ue+=Ye,x!==F&&x!==G&&(_=x)}}w=v,v=x,Y++}if(Ae=Ke.length,we>0&&0===Ae&&0===$e.length&&0===n[0].length==0&&(i!==se||1===n.length&&(ye>0?Ee:Be)===n[0])&&(Ae=n.join(",").length+2),Ae>0){if(a=0===ye&&i!==ie?function(e){for(var n,t,r=0,i=e.length,s=Array(i);r<i;++r){for(var a=e[r].split(c),l="",d=0,h=0,u=0,p=0,f=a.length;d<f;++d)if(!(0===(h=(t=a[d]).length)&&f>1)){if(u=l.charCodeAt(l.length-1),p=t.charCodeAt(0),n="",0!==d)switch(u){case U:case ne:case Q:case ee:case F:case D:break;default:n=" "}switch(p){case X:t=n+Ee;case ne:case Q:case ee:case F:case E:case D:break;case B:t=n+t+Ee;break;case K:switch(2*t.charCodeAt(1)+3*t.charCodeAt(2)){case 530:if(xe>0){t=n+t.substring(8,h-1);break}default:(d<1||a[d-1].length<1)&&(t=n+Ee+t)}break;case q:n="";default:t=h>1&&t.indexOf(":")>0?n+t.replace(j,"$1"+Ee+"$2"):n+t+Ee}l+=t}s[r]=l.replace(o,"").trim()}return s}(n):n,Se>0&&void 0!==(l=Xe(Me,Ke,a,e,me,fe,Ae,i,s,i))&&0===(Ke=l).length)return Ze+Ke+$e;if(Ke=a.join(",")+"{"+Ke+"}",be*ge!=0){switch(2!==be||We(Ke,2)||(ge=0),ge){case ce:Ke=Ke.replace(g,":"+P+"$1")+Ke;break;case le:Ke=Ke.replace(m,"::"+O+"input-$1")+Ke.replace(m,"::"+P+"$1")+Ke.replace(m,":"+M+"input-$1")+Ke}ge=0}}return Ze+Ke+$e}function Ne(e,n,t){var o=n.trim().split(d),r=o,i=o.length,s=e.length;switch(s){case 0:case 1:for(var a=0,l=0===s?"":e[0]+" ";a<i;++a)r[a]=ze(l,r[a],t,s).trim();break;default:a=0;var c=0;for(r=[];a<i;++a)for(var h=0;h<s;++h)r[c++]=ze(e[h]+" ",o[a],t,s).trim()}return r}function ze(e,n,t,o){var r=n,i=r.charCodeAt(0);switch(i<33&&(i=(r=r.trim()).charCodeAt(0)),i){case X:switch(ye+o){case 0:case 1:if(0===e.trim().length)break;default:return r.replace(h,"$1"+e.trim())}break;case K:switch(r.charCodeAt(1)){case 103:if(xe>0&&ye>0)return r.replace(u,"$1").replace(h,"$1"+Be);break;default:return e.trim()+r.replace(h,"$1"+e.trim())}default:if(t*ye>0&&r.indexOf("\f")>0)return r.replace(h,(e.charCodeAt(0)===K?"":"$1")+e.trim())}return e+r}function Ge(e,n,t,o){var c,d=0,h=e+";",u=2*n+3*t+4*o;if(944===u)return function(e){var n=e.length,t=e.indexOf(":",9)+1,o=e.substring(0,t).trim(),r=e.substring(t,n-1).trim();switch(e.charCodeAt(9)*Ie){case 0:break;case V:if(110!==e.charCodeAt(10))break;default:for(var i=r.split((r="",a)),s=0,t=0,n=i.length;s<n;t=0,++s){for(var c=i[s],d=c.split(l);c=d[t];){var h=c.charCodeAt(0);if(1===Ie&&(h>W&&h<90||h>96&&h<123||h===Y||h===V&&c.charCodeAt(1)!==V))switch(isNaN(parseFloat(c))+(-1!==c.indexOf("("))){case 1:switch(c){case"infinite":case"alternate":case"backwards":case"running":case"normal":case"forwards":case"both":case"none":case"linear":case"ease":case"ease-in":case"ease-out":case"ease-in-out":case"paused":case"reverse":case"alternate-reverse":case"inherit":case"initial":case"unset":case"step-start":case"step-end":break;default:c+=De}}d[t++]=c}r+=(0===s?"":",")+d.join(" ")}}return r=o+r+";",1===be||2===be&&We(r,1)?O+r+r:r}(h);if(0===be||2===be&&!We(h,1))return h;switch(u){case 1015:return 97===h.charCodeAt(10)?O+h+h:h;case 951:return 116===h.charCodeAt(3)?O+h+h:h;case 963:return 110===h.charCodeAt(5)?O+h+h:h;case 1009:if(100!==h.charCodeAt(4))break;case 969:case 942:return O+h+h;case 978:return O+h+P+h+h;case 1019:case 983:return O+h+P+h+M+h+h;case 883:return h.charCodeAt(8)===V?O+h+h:h.indexOf("image-set(",11)>0?h.replace(T,"$1"+O+"$2")+h:h;case 932:if(h.charCodeAt(4)===V)switch(h.charCodeAt(5)){case 103:return O+"box-"+h.replace("-grow","")+O+h+M+h.replace("grow","positive")+h;case 115:return O+h+M+h.replace("shrink","negative")+h;case 98:return O+h+M+h.replace("basis","preferred-size")+h}return O+h+M+h+h;case 964:return O+h+M+"flex-"+h+h;case 1023:if(99!==h.charCodeAt(8))break;return c=h.substring(h.indexOf(":",15)).replace("flex-","").replace("space-between","justify"),O+"box-pack"+c+O+h+M+"flex-pack"+c+h;case 1005:return i.test(h)?h.replace(r,":"+O)+h.replace(r,":"+P)+h:h;case 1e3:switch(d=(c=h.substring(13).trim()).indexOf("-")+1,c.charCodeAt(0)+c.charCodeAt(d)){case 226:c=h.replace(w,"tb");break;case 232:c=h.replace(w,"tb-rl");break;case 220:c=h.replace(w,"lr");break;default:return h}return O+h+M+c+h;case 1017:if(-1===h.indexOf("sticky",9))return h;case 975:switch(d=(h=e).length-10,u=(c=(33===h.charCodeAt(d)?h.substring(0,d):h).substring(e.indexOf(":",7)+1).trim()).charCodeAt(0)+(0|c.charCodeAt(7))){case 203:if(c.charCodeAt(8)<111)break;case 115:h=h.replace(c,O+c)+";"+h;break;case 207:case 102:h=h.replace(c,O+(u>102?"inline-":"")+"box")+";"+h.replace(c,O+c)+";"+h.replace(c,M+c+"box")+";"+h}return h+";";case 938:if(h.charCodeAt(5)===V)switch(h.charCodeAt(6)){case 105:return c=h.replace("-items",""),O+h+O+"box-"+c+M+"flex-"+c+h;case 115:return O+h+M+"flex-item-"+h.replace(S,"")+h;default:return O+h+M+"flex-line-pack"+h.replace("align-content","").replace(S,"")+h}break;case 973:case 989:if(h.charCodeAt(3)!==V||122===h.charCodeAt(4))break;case 931:case 953:if(!0===A.test(e))return 115===(c=e.substring(e.indexOf(":")+1)).charCodeAt(0)?Ge(e.replace("stretch","fill-available"),n,t,o).replace(":fill-available",":stretch"):h.replace(c,O+c)+h.replace(c,P+c.replace("fill-",""))+h;break;case 962:if(h=O+h+(102===h.charCodeAt(5)?M+h:"")+h,t+o===211&&105===h.charCodeAt(13)&&h.indexOf("transform",10)>0)return h.substring(0,h.indexOf(";",27)+1).replace(s,"$1"+O+"$2")+h}return h}function We(e,n){var t=e.indexOf(1===n?":":"{"),o=e.substring(0,3!==n?t:10),r=e.substring(t+1,e.length-1);return Ce(2!==n?o:o.replace(C,"$1"),r,n)}function Fe(e,n){var t=Ge(n,n.charCodeAt(0),n.charCodeAt(1),n.charCodeAt(2));return t!==n+";"?t.replace(_," or ($1)").substring(4):"("+n+")"}function Xe(e,n,t,o,r,i,s,a,l,c){for(var d,h=0,u=n;h<Se;++h)switch(d=_e[h].call(Ue,e,u,t,o,r,i,s,a,l,c)){case void 0:case!1:case!0:case null:break;default:u=d}if(u!==n)return u}function Ve(e,n,t,o){for(var r=n+1;r<t;++r)switch(o.charCodeAt(r)){case J:if(e===U&&o.charCodeAt(r-1)===U&&n+2!==r)return r+1;break;case N:if(e===J)return r+1}return r}function Ye(e){for(var n in e){var t=e[n];switch(n){case"keyframe":Ie=0|t;break;case"global":xe=0|t;break;case"cascade":ye=0|t;break;case"compress":ve=0|t;break;case"semicolon":je=0|t;break;case"preserve":we=0|t;break;case"prefix":Ce=null,t?"function"!=typeof t?be=1:(be=2,Ce=t):be=0}}return Ye}function Ue(n,t){if(void 0!==this&&this.constructor===Ue)return e(n);var r=n,i=r.charCodeAt(0);i<33&&(i=(r=r.trim()).charCodeAt(0)),Ie>0&&(De=r.replace(p,i===B?"":"-")),i=1,1===ye?Be=r:Ee=r;var s,a=[Be];Se>0&&void 0!==(s=Xe(Te,t,a,a,me,fe,0,0,0,0))&&"string"==typeof s&&(t=s);var l=Re(ke,a,t,0,0);return Se>0&&void 0!==(s=Xe(Ae,l,a,a,me,fe,l.length,0,0,0))&&"string"!=typeof(l=s)&&(i=0),De="",Be="",Ee="",ge=0,me=1,fe=1,ve*i==0?l:l.replace(o,"").replace(y,"").replace(b,"$1").replace(x,"$1").replace(v," ")}return Ue.use=function e(n){switch(n){case void 0:case null:Se=_e.length=0;break;default:if("function"==typeof n)_e[Se++]=n;else if("object"==typeof n)for(var t=0,o=n.length;t<o;++t)e(n[t]);else He=0|!!n}return e},Ue.set=Ye,void 0!==n&&Ye(n),Ue}(null)},"./node_modules/tinycolor2/tinycolor.js":function(e,n,t){var o;!function(r){var i=/^\s+/,s=/\s+$/,a=0,l=r.round,c=r.min,d=r.max,h=r.random;function u(e,n){if(n=n||{},(e=e||"")instanceof u)return e;if(!(this instanceof u))return new u(e,n);var t=function(e){var n={r:0,g:0,b:0},t=1,o=null,a=null,l=null,h=!1,u=!1;"string"==typeof e&&(e=function(e){e=e.replace(i,"").replace(s,"").toLowerCase();var n,t=!1;if(P[e])e=P[e],t=!0;else if("transparent"==e)return{r:0,g:0,b:0,a:0,format:"name"};if(n=F.rgb.exec(e))return{r:n[1],g:n[2],b:n[3]};if(n=F.rgba.exec(e))return{r:n[1],g:n[2],b:n[3],a:n[4]};if(n=F.hsl.exec(e))return{h:n[1],s:n[2],l:n[3]};if(n=F.hsla.exec(e))return{h:n[1],s:n[2],l:n[3],a:n[4]};if(n=F.hsv.exec(e))return{h:n[1],s:n[2],v:n[3]};if(n=F.hsva.exec(e))return{h:n[1],s:n[2],v:n[3],a:n[4]};if(n=F.hex8.exec(e))return{r:D(n[1]),g:D(n[2]),b:D(n[3]),a:N(n[4]),format:t?"name":"hex8"};if(n=F.hex6.exec(e))return{r:D(n[1]),g:D(n[2]),b:D(n[3]),format:t?"name":"hex"};if(n=F.hex4.exec(e))return{r:D(n[1]+""+n[1]),g:D(n[2]+""+n[2]),b:D(n[3]+""+n[3]),a:N(n[4]+""+n[4]),format:t?"name":"hex8"};if(n=F.hex3.exec(e))return{r:D(n[1]+""+n[1]),g:D(n[2]+""+n[2]),b:D(n[3]+""+n[3]),format:t?"name":"hex"};return!1}(e));"object"==typeof e&&(X(e.r)&&X(e.g)&&X(e.b)?(p=e.r,f=e.g,m=e.b,n={r:255*H(p,255),g:255*H(f,255),b:255*H(m,255)},h=!0,u="%"===String(e.r).substr(-1)?"prgb":"rgb"):X(e.h)&&X(e.s)&&X(e.v)?(o=B(e.s),a=B(e.v),n=function(e,n,t){e=6*H(e,360),n=H(n,100),t=H(t,100);var o=r.floor(e),i=e-o,s=t*(1-n),a=t*(1-i*n),l=t*(1-(1-i)*n),c=o%6;return{r:255*[t,a,s,s,l,t][c],g:255*[l,t,t,a,s,s][c],b:255*[s,s,l,t,t,a][c]}}(e.h,o,a),h=!0,u="hsv"):X(e.h)&&X(e.s)&&X(e.l)&&(o=B(e.s),l=B(e.l),n=function(e,n,t){var o,r,i;function s(e,n,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+6*(n-e)*t:t<.5?n:t<2/3?e+(n-e)*(2/3-t)*6:e}if(e=H(e,360),n=H(n,100),t=H(t,100),0===n)o=r=i=t;else{var a=t<.5?t*(1+n):t+n-t*n,l=2*t-a;o=s(l,a,e+1/3),r=s(l,a,e),i=s(l,a,e-1/3)}return{r:255*o,g:255*r,b:255*i}}(e.h,o,l),h=!0,u="hsl"),e.hasOwnProperty("a")&&(t=e.a));var p,f,m;return t=L(t),{ok:h,format:e.format||u,r:c(255,d(n.r,0)),g:c(255,d(n.g,0)),b:c(255,d(n.b,0)),a:t}}(e);this._originalInput=e,this._r=t.r,this._g=t.g,this._b=t.b,this._a=t.a,this._roundA=l(100*this._a)/100,this._format=n.format||t.format,this._gradientType=n.gradientType,this._r<1&&(this._r=l(this._r)),this._g<1&&(this._g=l(this._g)),this._b<1&&(this._b=l(this._b)),this._ok=t.ok,this._tc_id=a++}function p(e,n,t){e=H(e,255),n=H(n,255),t=H(t,255);var o,r,i=d(e,n,t),s=c(e,n,t),a=(i+s)/2;if(i==s)o=r=0;else{var l=i-s;switch(r=a>.5?l/(2-i-s):l/(i+s),i){case e:o=(n-t)/l+(n<t?6:0);break;case n:o=(t-e)/l+2;break;case t:o=(e-n)/l+4}o/=6}return{h:o,s:r,l:a}}function f(e,n,t){e=H(e,255),n=H(n,255),t=H(t,255);var o,r,i=d(e,n,t),s=c(e,n,t),a=i,l=i-s;if(r=0===i?0:l/i,i==s)o=0;else{switch(i){case e:o=(n-t)/l+(n<t?6:0);break;case n:o=(t-e)/l+2;break;case t:o=(e-n)/l+4}o/=6}return{h:o,s:r,v:a}}function m(e,n,t,o){var r=[E(l(e).toString(16)),E(l(n).toString(16)),E(l(t).toString(16))];return o&&r[0].charAt(0)==r[0].charAt(1)&&r[1].charAt(0)==r[1].charAt(1)&&r[2].charAt(0)==r[2].charAt(1)?r[0].charAt(0)+r[1].charAt(0)+r[2].charAt(0):r.join("")}function g(e,n,t,o){return[E(R(o)),E(l(e).toString(16)),E(l(n).toString(16)),E(l(t).toString(16))].join("")}function y(e,n){n=0===n?0:n||10;var t=u(e).toHsl();return t.s-=n/100,t.s=I(t.s),u(t)}function b(e,n){n=0===n?0:n||10;var t=u(e).toHsl();return t.s+=n/100,t.s=I(t.s),u(t)}function x(e){return u(e).desaturate(100)}function v(e,n){n=0===n?0:n||10;var t=u(e).toHsl();return t.l+=n/100,t.l=I(t.l),u(t)}function j(e,n){n=0===n?0:n||10;var t=u(e).toRgb();return t.r=d(0,c(255,t.r-l(-n/100*255))),t.g=d(0,c(255,t.g-l(-n/100*255))),t.b=d(0,c(255,t.b-l(-n/100*255))),u(t)}function w(e,n){n=0===n?0:n||10;var t=u(e).toHsl();return t.l-=n/100,t.l=I(t.l),u(t)}function k(e,n){var t=u(e).toHsl(),o=(t.h+n)%360;return t.h=o<0?360+o:o,u(t)}function _(e){var n=u(e).toHsl();return n.h=(n.h+180)%360,u(n)}function S(e){var n=u(e).toHsl(),t=n.h;return[u(e),u({h:(t+120)%360,s:n.s,l:n.l}),u({h:(t+240)%360,s:n.s,l:n.l})]}function C(e){var n=u(e).toHsl(),t=n.h;return[u(e),u({h:(t+90)%360,s:n.s,l:n.l}),u({h:(t+180)%360,s:n.s,l:n.l}),u({h:(t+270)%360,s:n.s,l:n.l})]}function A(e){var n=u(e).toHsl(),t=n.h;return[u(e),u({h:(t+72)%360,s:n.s,l:n.l}),u({h:(t+216)%360,s:n.s,l:n.l})]}function T(e,n,t){n=n||6,t=t||30;var o=u(e).toHsl(),r=360/t,i=[u(e)];for(o.h=(o.h-(r*n>>1)+720)%360;--n;)o.h=(o.h+r)%360,i.push(u(o));return i}function O(e,n){n=n||6;for(var t=u(e).toHsv(),o=t.h,r=t.s,i=t.v,s=[],a=1/n;n--;)s.push(u({h:o,s:r,v:i})),i=(i+a)%1;return s}u.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var e=this.toRgb();return(299*e.r+587*e.g+114*e.b)/1e3},getLuminance:function(){var e,n,t,o=this.toRgb();return e=o.r/255,n=o.g/255,t=o.b/255,.2126*(e<=.03928?e/12.92:r.pow((e+.055)/1.055,2.4))+.7152*(n<=.03928?n/12.92:r.pow((n+.055)/1.055,2.4))+.0722*(t<=.03928?t/12.92:r.pow((t+.055)/1.055,2.4))},setAlpha:function(e){return this._a=L(e),this._roundA=l(100*this._a)/100,this},toHsv:function(){var e=f(this._r,this._g,this._b);return{h:360*e.h,s:e.s,v:e.v,a:this._a}},toHsvString:function(){var e=f(this._r,this._g,this._b),n=l(360*e.h),t=l(100*e.s),o=l(100*e.v);return 1==this._a?"hsv("+n+", "+t+"%, "+o+"%)":"hsva("+n+", "+t+"%, "+o+"%, "+this._roundA+")"},toHsl:function(){var e=p(this._r,this._g,this._b);return{h:360*e.h,s:e.s,l:e.l,a:this._a}},toHslString:function(){var e=p(this._r,this._g,this._b),n=l(360*e.h),t=l(100*e.s),o=l(100*e.l);return 1==this._a?"hsl("+n+", "+t+"%, "+o+"%)":"hsla("+n+", "+t+"%, "+o+"%, "+this._roundA+")"},toHex:function(e){return m(this._r,this._g,this._b,e)},toHexString:function(e){return"#"+this.toHex(e)},toHex8:function(e){return function(e,n,t,o,r){var i=[E(l(e).toString(16)),E(l(n).toString(16)),E(l(t).toString(16)),E(R(o))];if(r&&i[0].charAt(0)==i[0].charAt(1)&&i[1].charAt(0)==i[1].charAt(1)&&i[2].charAt(0)==i[2].charAt(1)&&i[3].charAt(0)==i[3].charAt(1))return i[0].charAt(0)+i[1].charAt(0)+i[2].charAt(0)+i[3].charAt(0);return i.join("")}(this._r,this._g,this._b,this._a,e)},toHex8String:function(e){return"#"+this.toHex8(e)},toRgb:function(){return{r:l(this._r),g:l(this._g),b:l(this._b),a:this._a}},toRgbString:function(){return 1==this._a?"rgb("+l(this._r)+", "+l(this._g)+", "+l(this._b)+")":"rgba("+l(this._r)+", "+l(this._g)+", "+l(this._b)+", "+this._roundA+")"},toPercentageRgb:function(){return{r:l(100*H(this._r,255))+"%",g:l(100*H(this._g,255))+"%",b:l(100*H(this._b,255))+"%",a:this._a}},toPercentageRgbString:function(){return 1==this._a?"rgb("+l(100*H(this._r,255))+"%, "+l(100*H(this._g,255))+"%, "+l(100*H(this._b,255))+"%)":"rgba("+l(100*H(this._r,255))+"%, "+l(100*H(this._g,255))+"%, "+l(100*H(this._b,255))+"%, "+this._roundA+")"},toName:function(){return 0===this._a?"transparent":!(this._a<1)&&(M[m(this._r,this._g,this._b,!0)]||!1)},toFilter:function(e){var n="#"+g(this._r,this._g,this._b,this._a),t=n,o=this._gradientType?"GradientType = 1, ":"";if(e){var r=u(e);t="#"+g(r._r,r._g,r._b,r._a)}return"progid:DXImageTransform.Microsoft.gradient("+o+"startColorstr="+n+",endColorstr="+t+")"},toString:function(e){var n=!!e;e=e||this._format;var t=!1,o=this._a<1&&this._a>=0;return n||!o||"hex"!==e&&"hex6"!==e&&"hex3"!==e&&"hex4"!==e&&"hex8"!==e&&"name"!==e?("rgb"===e&&(t=this.toRgbString()),"prgb"===e&&(t=this.toPercentageRgbString()),"hex"!==e&&"hex6"!==e||(t=this.toHexString()),"hex3"===e&&(t=this.toHexString(!0)),"hex4"===e&&(t=this.toHex8String(!0)),"hex8"===e&&(t=this.toHex8String()),"name"===e&&(t=this.toName()),"hsl"===e&&(t=this.toHslString()),"hsv"===e&&(t=this.toHsvString()),t||this.toHexString()):"name"===e&&0===this._a?this.toName():this.toRgbString()},clone:function(){return u(this.toString())},_applyModification:function(e,n){var t=e.apply(null,[this].concat([].slice.call(n)));return this._r=t._r,this._g=t._g,this._b=t._b,this.setAlpha(t._a),this},lighten:function(){return this._applyModification(v,arguments)},brighten:function(){return this._applyModification(j,arguments)},darken:function(){return this._applyModification(w,arguments)},desaturate:function(){return this._applyModification(y,arguments)},saturate:function(){return this._applyModification(b,arguments)},greyscale:function(){return this._applyModification(x,arguments)},spin:function(){return this._applyModification(k,arguments)},_applyCombination:function(e,n){return e.apply(null,[this].concat([].slice.call(n)))},analogous:function(){return this._applyCombination(T,arguments)},complement:function(){return this._applyCombination(_,arguments)},monochromatic:function(){return this._applyCombination(O,arguments)},splitcomplement:function(){return this._applyCombination(A,arguments)},triad:function(){return this._applyCombination(S,arguments)},tetrad:function(){return this._applyCombination(C,arguments)}},u.fromRatio=function(e,n){if("object"==typeof e){var t={};for(var o in e)e.hasOwnProperty(o)&&(t[o]="a"===o?e[o]:B(e[o]));e=t}return u(e,n)},u.equals=function(e,n){return!(!e||!n)&&u(e).toRgbString()==u(n).toRgbString()},u.random=function(){return u.fromRatio({r:h(),g:h(),b:h()})},u.mix=function(e,n,t){t=0===t?0:t||50;var o=u(e).toRgb(),r=u(n).toRgb(),i=t/100;return u({r:(r.r-o.r)*i+o.r,g:(r.g-o.g)*i+o.g,b:(r.b-o.b)*i+o.b,a:(r.a-o.a)*i+o.a})},u.readability=function(e,n){var t=u(e),o=u(n);return(r.max(t.getLuminance(),o.getLuminance())+.05)/(r.min(t.getLuminance(),o.getLuminance())+.05)},u.isReadable=function(e,n,t){var o,r,i=u.readability(e,n);switch(r=!1,(o=function(e){var n,t;n=((e=e||{level:"AA",size:"small"}).level||"AA").toUpperCase(),t=(e.size||"small").toLowerCase(),"AA"!==n&&"AAA"!==n&&(n="AA");"small"!==t&&"large"!==t&&(t="small");return{level:n,size:t}}(t)).level+o.size){case"AAsmall":case"AAAlarge":r=i>=4.5;break;case"AAlarge":r=i>=3;break;case"AAAsmall":r=i>=7}return r},u.mostReadable=function(e,n,t){var o,r,i,s,a=null,l=0;r=(t=t||{}).includeFallbackColors,i=t.level,s=t.size;for(var c=0;c<n.length;c++)(o=u.readability(e,n[c]))>l&&(l=o,a=u(n[c]));return u.isReadable(e,a,{level:i,size:s})||!r?a:(t.includeFallbackColors=!1,u.mostReadable(e,["#fff","#000"],t))};var P=u.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"},M=u.hexNames=function(e){var n={};for(var t in e)e.hasOwnProperty(t)&&(n[e[t]]=t);return n}(P);function L(e){return e=parseFloat(e),(isNaN(e)||e<0||e>1)&&(e=1),e}function H(e,n){(function(e){return"string"==typeof e&&-1!=e.indexOf(".")&&1===parseFloat(e)})(e)&&(e="100%");var t=function(e){return"string"==typeof e&&-1!=e.indexOf("%")}(e);return e=c(n,d(0,parseFloat(e))),t&&(e=parseInt(e*n,10)/100),r.abs(e-n)<1e-6?1:e%n/parseFloat(n)}function I(e){return c(1,d(0,e))}function D(e){return parseInt(e,16)}function E(e){return 1==e.length?"0"+e:""+e}function B(e){return e<=1&&(e=100*e+"%"),e}function R(e){return r.round(255*parseFloat(e)).toString(16)}function N(e){return D(e)/255}var z,G,W,F=(G="[\\s|\\(]+("+(z="(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)")+")[,|\\s]+("+z+")[,|\\s]+("+z+")\\s*\\)?",W="[\\s|\\(]+("+z+")[,|\\s]+("+z+")[,|\\s]+("+z+")[,|\\s]+("+z+")\\s*\\)?",{CSS_UNIT:new RegExp(z),rgb:new RegExp("rgb"+G),rgba:new RegExp("rgba"+W),hsl:new RegExp("hsl"+G),hsla:new RegExp("hsla"+W),hsv:new RegExp("hsv"+G),hsva:new RegExp("hsva"+W),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/});function X(e){return!!F.CSS_UNIT.exec(e)}e.exports?e.exports=u:void 0===(o=function(){return u}.call(n,t,n,e))||(e.exports=o)}(Math)},"./node_modules/webpack/buildin/global.js":function(e,n){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(e){"object"==typeof window&&(t=window)}e.exports=t},"./node_modules/webpack/buildin/module.js":function(e,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},"./src/main/webapp/contrib/highcharts/modules/highcharts-downsample/highcharts-downsample.es":function(e,n,t){(function(e){var o,r;o=[t("./src/main/webapp/contrib/highcharts/modules/highcharts-downsample/lttb.es")],void 0===(r=function(n){"use strict";var t,o;function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}n=(t=n)&&t.__esModule?t:{default:t},o=function(e){!function(e){Array.isArray||(Array.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)});Math.floor,Math.abs;e.wrap(e.Series.prototype,"setData",function(e){var t=this.options;if(t.hasOwnProperty("downsample")&&arguments[1].length>0)if(Array.isArray(arguments[1][0])&&2==arguments[1][0].length)arguments[1]=(0,n.default)(arguments[1],t.downsample.threshold);else if(!isNaN(parseFloat(arguments[1][0]))&&isFinite(arguments[1][0])){for(var o=void 0!==t.pointStart?t.pointStart:0,r=void 0!==t.pointInterval?t.pointInterval:1,i=0,s=arguments[1].length;i<s;i++)arguments[1][i]=[o,arguments[1][i]],o+=r;arguments[1]=(0,n.default)(arguments[1],t.downsample.threshold)}else null!==arguments[1][0].x&&void 0!==arguments[1][0].y?arguments[1]=(0,n.default)(arguments[1],t.downsample.threshold):console.log("Downsample Error: Invalid data format! Note: Range Series are not supported");e.apply(this,Array.prototype.slice.call(arguments,1))})}(e)},"object"===r(e)&&e.exports?e.exports=o:o(Highcharts)}.apply(n,o))||(e.exports=r)}).call(this,t("./node_modules/webpack/buildin/module.js")(e))},"./src/main/webapp/contrib/highcharts/modules/highcharts-downsample/lttb.es":function(e,n,t){var o;void 0===(o=function(t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,n){var t=e.length;if(n>=t||0===n||null===n)return e;var a,l,c,d,h=[],u=0,p=(t-2)/(n-2),f=0;h[u++]=e[f];for(var m=0;m<n-2;m++){for(var g=0,y=0,b=o((m+1)*p)+1,x=o((m+2)*p)+1,v=(x=x<t?x:t)-b,j=[];b<x;b++)g+=1*i(e[b]),y+=1*s(e[b]);g/=v,y/=v;var w=o((m+0)*p)+1,k=o((m+1)*p)+1,_=1*i(e[f]),S=1*s(e[f]);for(l=c=-1;w<k;w++)(c=.5*r((_-g)*(s(e[w])-S)-(_-i(e[w]))*(y-S)))>l&&(l=c,a=e[w],d=w),e[w].required&&j.push(e[w]);a.required||(j.push(a),j.sort(function(e,n){return i(e)-i(n)})),h=h.concat(j),u+=j.length,f=d}return h[u++]=e[t-1],h},Array.isArray||(Array.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)});var o=Math.floor,r=Math.abs;function i(e){return Array.isArray(e)?e[0]:e.x}function s(e){return Array.isArray(e)?e[1]:e.y}e.exports=n.default}.apply(n,[n]))||(e.exports=o)},"./src/main/webapp/contrib_shim/highcharts/extensions.es":function(e,n,t){var o;void 0===(o=function(e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getPlotLinePath=function(e){return function(e){var n=e.apply(this,Array.prototype.slice.call(arguments,1));return n&&(n.flat=!1),n}},e.addPlotLine=function(e){return function(n){var t={label:{style:null!=this.chart.options.labels?this.chart.options.labels.style:{}}},o=Array.prototype.slice.call(arguments),r=o[1];n.apply(this,[e.merge(r,t)])}},e.renderItem=function(e){return function(e){for(var n=arguments.length,t=new Array(n>1?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];e.call.apply(e,[this].concat(t));var r=t[0];r.legendGroup.element.onmouseover=function(){null!=r.options.events.legendMouseOver&&r.options.events.legendMouseOver.call(r,{target:r.legendGroup,series:r})},r.legendGroup.element.onmouseout=function(){null!=r.options.events.legendMouseOut&&r.options.events.legendMouseOut.call(r,{target:r.legendGroup,series:r})}}},e.updateColorForPoint=function(e,n){this&&this.graphic&&this.graphic.attr("fill",n)}}.apply(n,[n]))||(e.exports=o)},"./src/main/webapp/contrib_shim/highcharts/highcharts.es":function(e,n,t){var o,r;o=[n,t("./node_modules/highcharts/modules/no-data-to-display.js"),t("./node_modules/@splunk/highcharts/highcharts.js"),t("./src/main/webapp/contrib/highcharts/modules/highcharts-downsample/highcharts-downsample.es"),t("./src/main/webapp/contrib_shim/highcharts/extensions.es"),t("./src/main/webapp/contrib_shim/highcharts/theme.es")],void 0===(r=function(t,o,r,i,s,a){"use strict";function l(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,o=l(o),r=l(r),(0,(i=l(i)).default)(r.default),(0,o.default)(r.default),(0,a.setTheme)(r.default),r.default.seriesType=function(e,n,t,o,i){var s=r.default.getOptions(),a=r.default.seriesTypes;return s.plotOptions[e]=r.default.merge(s.plotOptions[n],t),a[e]=r.default.extendClass(a[n]||function(){},o),a[e].prototype.type=e,i&&(a[e].prototype.pointClass=r.default.extendClass(r.default.Point,i)),a[e]},r.default.wrap(r.default.Axis.prototype,"getPlotLinePath",(0,s.getPlotLinePath)(r.default)),r.default.wrap(r.default.Axis.prototype,"addPlotLine",(0,s.addPlotLine)(r.default)),r.default.wrap(r.default.Point.prototype,"updateColor",s.updateColorForPoint),r.default.wrap(r.default.Legend.prototype,"renderItem",(0,s.renderItem)(r.default));var c=r.default;t.default=c,e.exports=n.default}.apply(n,o))||(e.exports=r)},"./src/main/webapp/contrib_shim/highcharts/theme.es":function(e,n,t){var o,r;o=[n,t("util/theme_utils"),t("./src/main/webapp/util/colorPalette.es")],void 0===(r=function(e,n,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setTheme=function(e){var o={colors:(0,t.getColors)(),chart:{style:{"font-family":"Splunk Platform Sans"}},credits:!1,global:{useUTC:!1},legend:{itemStyle:{"font-weight":"normal"}}},r="dark"===(0,n.getCurrentTheme)();e.setOptions(r?e.merge(o,t.highchartsDarkTheme):o)}}.apply(n,o))||(e.exports=r)},"./src/main/webapp/plots/BoxPlot.es":function(e,n,t){var o,r;o=[n,t("shim/jquery"),t("./node_modules/@splunk/highcharts/highcharts-more.js"),t("vizapi/SplunkVisualizationBase"),t("./src/main/webapp/contrib_shim/highcharts/highcharts.es"),t("shared/controls/Messages"),t("./src/main/webapp/util/colorPalette.es")],void 0===(r=function(t,o,r,i,s,a,l){"use strict";function c(e){return e&&e.__esModule?e:{default:e}}function d(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,o=c(o),r=c(r),i=c(i),s=c(s),a=function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)if(Object.prototype.hasOwnProperty.call(e,t)){var o=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,t):{};o.get||o.set?Object.defineProperty(n,t,o):n[t]=e[t]}return n.default=e,n}(a);t.default=function e(n,t,c){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),d(this,"setSeries",function(e){var n=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=arguments.length>2?arguments[2]:void 0,r=[];for(r.push({type:"boxplot",data:e,colors:t.xAxis.categories.map(function(e,n){return(0,l.getColorByIndex)(n)}),colorByPoint:!0}),this.chart.options.chart.marginBottom=function(e){var n,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];a.removeAlert(e);var r=null;if(0===t.length)throw new i.default.VisualizationError("No columns had visualizable data.");if(null!=t){var s="This visualization expects five rows corresponding to min, max, median, lower quartile, and upper quartile (in any order)";if(t[0].length<5)r="Not enough rows in the data. ".concat(s);else if(t[0].length>5)r="Too many rows in the data. ".concat(s);else if(o.length>1){var l=o.map(function(e){return"".concat(e)}).join(", ");r="The following columns were omitted because they contain non-numeric data: ".concat(l,".")}else 1===o.length&&(r="The following column was omitted because it contains non-numeric data: ".concat(o[0],"."))}return null!=r?(n=100,a.setAlert(e,"".concat(r),"warning","alert-inline")):n=null,n}(this.warningMessage$El,e,o);this.chart.series.length>0;)this.chart.series[0].remove(!1);r.forEach(function(e){n.chart.addSeries(e,!1)}),t.xAxis.categories&&this.chart.xAxis[0].setCategories(t.xAxis.categories),t.xAxisLabel&&this.chart.xAxis[0].setTitle({text:t.xAxisLabel},!1),t.yAxisLabel&&this.chart.yAxis[0].setTitle({text:t.yAxisLabel},!1),this.chart.redraw()}),d(this,"reflow",function(){null!=this.chart&&this.chart.reflow()}),(0,r.default)(s.default);var h={chart:{renderTo:n.get(0)},credits:!1,title:{text:""},legend:{enabled:!1},xAxis:{title:{text:t}},yAxis:{title:{text:c}},tooltip:{formatter:function(){return"Field Label: ".concat((0,o.default)("<div>").text(this.x).html(),"<br>\n                    Maximum: ").concat(this.point.options.high,"<br>\n                    Upper Quartile: ").concat(this.point.options.q3,"<br>\n                    Median: ").concat(this.point.options.median,"<br>\n                    Lower Quartile: ").concat(this.point.options.q1,"<br>\n                    Minimum: ").concat(this.point.options.low)}}};this.chart=new s.default.Chart(h),this.warningMessage$El=(0,o.default)("<div>").addClass("mltk-boxplot-warning"),n.addClass("mltk-boxplot"),n.append(this.warningMessage$El)},e.exports=n.default}.apply(n,o))||(e.exports=r)},"./src/main/webapp/util/colorPalette.es":function(e,n,t){var o,r;o=[n,t("./node_modules/@splunk/themes/enterpriseDark.js"),t("splunk/palettes/ColorCodes")],void 0===(r=function(e,n,t){"use strict";var o;Object.defineProperty(e,"__esModule",{value:!0}),e.getColors=function(){return i.slice()},e.getColorByIndex=function(e,n,t){var o=e%i.length,r=i[o];if(null==r)return"";n&&(s=r,a=parseInt(s.replace(/[^0-9A-F]/gi,""),16),r=[a>>16,a>>8&255,255&a]);var s,a;t&&(r="0x".concat(r.slice(1)));return r},e.getGradientColor=function(e,n,t){var o=this.getColorByIndex(e,!0),r=this.getColorByIndex(n,!0),i=1-t,s=t,a=[Math.round(o[0]*i+r[0]*s),Math.round(o[1]*i+r[1]*s),Math.round(o[2]*i+r[2]*s)];return"#".concat(function(e,n,t){return o=(e<<16|n<<8|t).toString(16).toUpperCase(),new Array(7-o.length).join("0")+o;var o}.apply(this,a))},e.getHexColorbyIndex=function(e){var n=i[e].slice(1);return"0x".concat(n)},e.panelColors=e.highchartsDarkTheme=void 0;var r={chart:{backgroundColor:(n=(o=n)&&o.__esModule?o:{default:o}).default.gray20,plotBorderColor:n.default.gray30},title:{style:{color:n.default.gray98}},subtitle:{style:{color:n.default.gray98}},xAxis:{gridLineColor:n.default.gray45,labels:{style:{color:n.default.gray98}},lineColor:n.default.gray45,minorGridLineColor:n.default.gray30,tickColor:n.default.gray45,title:{style:{color:n.default.gray92}}},yAxis:{gridLineColor:n.default.gray45,labels:{style:{color:n.default.gray98}},lineColor:n.default.gray45,minorGridLineColor:n.default.gray30,tickColor:n.default.gray45,title:{style:{color:n.default.gray92}}},tooltip:{backgroundColor:n.default.black,style:{color:n.default.white}},plotOptions:{series:{dataLabels:{color:n.default.gray92},marker:{lineColor:n.default.gray22}},boxplot:{fillColor:n.default.gray30},candlestick:{lineColor:n.default.white},errorbar:{color:n.default.white}},legend:{itemStyle:{color:n.default.gray98},itemHoverStyle:{color:n.default.white},itemHiddenStyle:{color:n.default.gray30}},credits:{style:{color:n.default.gray22}},labels:{style:{color:n.default.white}},drilldown:{activeAxisLabelStyle:{color:n.default.white},activeDataLabelStyle:{color:n.default.white}},navigation:{buttonOptions:{symbolStroke:n.default.gray96,theme:{fill:n.default.gray30}}},rangeSelector:{buttonTheme:{fill:n.default.gray30,stroke:n.default.black,style:{color:n.default.gray96},states:{hover:{fill:n.default.gray45,stroke:n.default.black,style:{color:n.default.white}},select:{fill:n.default.black,stroke:n.default.black,style:{color:n.default.white}}}},inputBoxBorderColor:n.default.gray30,inputStyle:{backgroundColor:n.default.gray20,color:n.default.gray80},labelStyle:{color:n.default.gray80}},navigator:{handles:{backgroundColor:n.default.gray22,borderColor:n.default.gray96},outlineColor:n.default.gray30,maskFill:"rgba(255,255,255,0.1)",series:{color:n.default.cat30ColorL,lineColor:n.default.accentColorL40},xAxis:{gridLineColor:n.default.gray30}},scrollbar:{barBackgroundColor:n.default.gray80,barBorderColor:n.default.gray80,buttonArrowColor:n.default.gray96,buttonBackgroundColor:n.default.gray30,buttonBorderColor:n.default.gray30,rifleColor:n.default.white,trackBackgroundColor:n.default.gray22,trackBorderColor:n.default.gray22},legendBackgroundColor:"rgba(0, 0, 0, 0.5)",background2:n.default.gray30,dataLabelsColor:n.default.gray96,textColor:n.default.gray96,contrastTextColor:n.default.white,maskColor:"rgba(255,255,255,0.3)"};e.highchartsDarkTheme=r;var i=t.CATEGORICAL;e.panelColors={selected:"#4092c9",hovered:"#a4d7f4"}}.apply(n,o))||(e.exports=r)},"./src/main/webapp/util/formatters/formatBoxData.es":function(e,n,t){var o,r;o=[n,t("./src/main/webapp/util/validators/NumberValidator.es")],void 0===(r=function(t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var n={maxValue:Number.NEGATIVE_INFINITY,minValue:Number.POSITIVE_INFINITY,series:[{data:[]}],xAxis:{categories:[]}};if(e.fields&&e.rows.length>0){var t=e.fields.map(function(e,n){return n}),r=function(e){if(Array.isArray(e)){for(var n=0,t=new Array(e.length);n<e.length;n++)t[n]=e[n];return t}}(i=t)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(i)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}();n.invalidXAxisFields=[],t.forEach(function(t){for(var i=0;i<e.rows.length;i++)if(!(0,o.validate)(e.rows[i][t])){n.invalidXAxisFields.push(t),r.splice(r.indexOf(t),1);break}}),n.invalidXAxisFields=n.invalidXAxisFields.map(function(n){return e.fields[n].name}),n.invalidXAxisFields.shift(),r.forEach(function(t){n.xAxis.categories.push(e.fields[t].name)}),n.series[0].data=r.map(function(n){return e.rows.map(function(e){return parseFloat(e[n])}).sort(function(e,n){return e-n})}),n.series[0].data.forEach(function(e){n.minValue=Math.min(e[0],n.minValue),n.maxValue=Math.max(e[e.length-1],n.maxValue)})}var i;return n},e.exports=n.default}.apply(n,o))||(e.exports=r)},"./src/main/webapp/util/validators/NumberValidator.es":function(e,n,t){var o;void 0===(o=function(e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.validate=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=Number(e),r=(a=e,!Array.isArray(a)&&a-parseFloat(a)+1>=0&&(!1!==t.allowFloats||n(o))),i=null==t.min||(t.minExclusive?o>t.min:o>=t.min),s=null==t.max||(t.maxExclusive?o<t.max:o<=t.max);var a;return r&&i&&s};var n=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e}}.apply(n,[n]))||(e.exports=o)},"contrib/jg_lib/Class":function(e,n,t){var o;
/*!
 * Copyright (c) 2007-2016 Jason Gatt
 * 
 * Released under the MIT license:
 * http://opensource.org/licenses/MIT
 */void 0===(o=function(e,n,t){var o=Object.prototype.hasOwnProperty,r=Object.prototype.toString,i=[],s=[],a={},l=0,c=function(e,n,t){i.push(e),s.push(n),o.call(a,n)||(a[n]=e),t&&l++},d=function(e){return e},h=function(e,n,t){if(null!=t){if(null==e)throw new Error("Parameter name must be non-null.");if(!h.isString(e))throw new Error("Parameter name must be of type String.");if(null==n)throw new Error("Parameter baseClass must be non-null.");if(!h.isFunction(n))throw new Error("Parameter baseClass must be of type Function.");if(!h.isFunction(t))throw new Error("Parameter callback must be of type Function.")}else if(null!=n){if(t=n,n=e,null==e)throw new Error("Parameter 0 must be non-null.");if(h.isString(e))n=null;else{if(!h.isFunction(e))throw new Error("Parameter 0 must be of type String or Function.");e=null}if(!h.isFunction(t))throw new Error("Parameter callback must be of type Function.")}else{if(null==e)throw new Error("Expecting at least 1 parameter.");if(t=e,n=null,e=null,!h.isFunction(t))throw new Error("Parameter callback must be of type Function.")}if(null!=n){var o=n,r=d(function(){if(o!==n)return o.apply(this,arguments);o.apply(this,arguments)}),i=d(function(){}),s=i.prototype=n.prototype,a=r.prototype=new i;return a.constructor=r,t.call(a,r,s,a),a.constructor!==r&&(o=a.constructor,a.constructor=r),e&&c(r,e),r}var l={};return t.call(l,l),e&&c(l,e),l};return h.mixin=function(e,n){if(null==e)throw new Error("Parameter target must be non-null.");if(null==n)throw new Error("Parameter source must be non-null.");for(var t,r=1,i=arguments.length;r<i;r++){if(null==(n=arguments[r]))throw new Error("Parameter source must be non-null.");for(t in n)o.call(n,t)&&(e[t]=n[t])}return e},h.fromName=function(e){if(null==e)throw new Error("Parameter name must be non-null.");return o.call(a,e)?a[e]:null},h.getName=function(e){if(null==e)throw new Error("Parameter cls must be non-null.");for(var n=0,t=i.length;n<t;n++)if(i[n]===e)return s[n];return null},h.getClassList=function(){return i.slice(l)},h.getClassNameList=function(){return s.slice(l)},h.getTypeChecker=function(e){if(null==e)throw new Error("Parameter cls must be non-null.");switch(e){case Array:return h.isArray;case Boolean:return h.isBoolean;case Date:return h.isDate;case Function:return h.isFunction;case Number:return h.isNumber;case Object:return h.isObject;case RegExp:return h.isRegExp;case String:return h.isString;default:return function(n){return n instanceof e}}},h.getBaseClass=function(e){if(null==e)throw new Error("Parameter cls must be non-null.");if(e===Object)return null;var n=e.prototype;if(null==n)return null;var t=n.constructor;if(o.call(n,"constructor")){var r=t;delete n.constructor,t=n.constructor,n.constructor=r}return null==t||t===e?null:t},h.isSubclassOf=function(e,n){if(null==e)throw new Error("Parameter cls must be non-null.");if(null==n)throw new Error("Parameter baseClass must be non-null.");if(e===n)return!1;var t=e.prototype;return null!=t&&t instanceof n},h.isArray=function(e){return e instanceof Array||"[object Array]"===r.call(e)},h.isBoolean=function(e){return"boolean"==typeof e||"[object Boolean]"===r.call(e)},h.isDate=function(e){return e instanceof Date||"[object Date]"===r.call(e)},h.isFunction=function(e){return"function"==typeof e||!1},h.isNumber=function(e){return"number"==typeof e||"[object Number]"===r.call(e)},h.isObject=function(e){return null!=e&&("object"==typeof e||"function"==typeof e)},h.isRegExp=function(e){return e instanceof RegExp||"[object RegExp]"===r.call(e)},h.isString=function(e){return"string"==typeof e||"[object String]"===r.call(e)},c(Array,"Array",!0),c(Boolean,"Boolean",!0),c(Date,"Date",!0),c(Function,"Function",!0),c(Math,"Math",!0),c(Number,"Number",!0),c(Object,"Object",!0),c(RegExp,"RegExp",!0),c(String,"String",!0),c(h,t.i),h}.call(n,t,n,e))||(e.exports=o)},"contrib/jg_lib/graphics/Color":function(e,n,t){var o;
/*!
 * Copyright (c) 2007-2016 Jason Gatt
 * 
 * Released under the MIT license:
 * http://opensource.org/licenses/MIT
 */void 0===(o=function(e,n,o){var r=t("contrib/jg_lib/Class"),i=t("contrib/jg_lib/utils/NumberUtil");return r(o.i,Object,function(e,n){var t=/^\s*(?:(?:(?:#|0x)([0-9A-F]*))|([^\(\)]+)|(?:(?:(?:rgba|(rgb))\s*)?\(([^\(\)]*)\)))\s*$/i,o=/([^%]*)%\s*$/;e.interpolate=function(n,t,o){var r=i.interpolate(n.r,t.r,o),s=i.interpolate(n.g,t.g,o),a=i.interpolate(n.b,t.b,o),l=i.interpolate(n.a,t.a,o);return new e(r,s,a,l).normalize()},e.fromNumber=function(n){return n=(n=+n)>0?Math.min(Math.floor(n),16777215):0,new e(n>>16&255,n>>8&255,255&n)},e.fromArray=function(n){var t=n.length,o=t>0?n[0]:0,r=t>1?n[1]:0,i=t>2?n[2]:0,s=t>3?n[3]:1;return new e(o,r,i,s)},e.fromString=function(n){var o=(""+n).match(t);return o?null!=o[1]?e.fromNumber(r(o[1])):null!=o[2]?e.fromArray(s(o[2])):null!=o[4]?e.fromArray(s(o[4],null!=o[3])):new e:new e};var r=function(e){if(!e)return 0;if(3===e.length){var n=e.split("");n[0]=n[0]+n[0],n[1]=n[1]+n[1],n[2]=n[2]+n[2],e=n.join("")}return parseInt(e,16)},s=function(e,n){var t,r=e.split(","),i=r.length,s=!0===n?3:4;i>s&&(r.splice(s,i-s),i=s);for(var a=0;a<i;a++)t=(e=r[a]).match(o),r[a]=t?a<3?Math.round(t[1]/100*255):t[1]/100:+e;return r};this.r=0,this.g=0,this.b=0,this.a=1,this.constructor=function(e,n,t,o){this.r=null!=e?+e:0,this.g=null!=n?+n:0,this.b=null!=t?+t:0,this.a=null!=o?+o:1},this.lighten=function(e){e=Math.max(e,0);var n=i.interpolate(this.r,255,e),t=i.interpolate(this.g,255,e),o=i.interpolate(this.b,255,e);return this.r=n>0?Math.min(Math.round(n),255):0,this.g=t>0?Math.min(Math.round(t),255):0,this.b=o>0?Math.min(Math.round(o),255):0,this},this.darken=function(e){e=Math.max(e,0);var n=i.interpolate(this.r,0,e),t=i.interpolate(this.g,0,e),o=i.interpolate(this.b,0,e);return this.r=n>0?Math.min(Math.round(n),255):0,this.g=t>0?Math.min(Math.round(t),255):0,this.b=o>0?Math.min(Math.round(o),255):0,this},this.invert=function(){var e=255-this.r,n=255-this.g,t=255-this.b;return this.r=e>0?Math.min(Math.round(e),255):0,this.g=n>0?Math.min(Math.round(n),255):0,this.b=t>0?Math.min(Math.round(t),255):0,this},this.normalize=function(){var e=+this.r,n=+this.g,t=+this.b,o=+this.a;return this.r=e>0?Math.min(Math.round(e),255):0,this.g=n>0?Math.min(Math.round(n),255):0,this.b=t>0?Math.min(Math.round(t),255):0,this.a=o>0?Math.min(o,1):0,this},this.hasNaN=function(){return isNaN(this.r)||isNaN(this.g)||isNaN(this.b)||isNaN(this.a)},this.hasInfinity=function(){return this.r==1/0||this.r==-1/0||this.g==1/0||this.g==-1/0||this.b==1/0||this.b==-1/0||this.a==1/0||this.a==-1/0},this.isFinite=function(){return this.r-this.r==0&&this.g-this.g==0&&this.b-this.b==0&&this.a-this.a==0},this.approxEquals=function(e,n){return i.approxEqual(this.r,e.r,n)&&i.approxEqual(this.g,e.g,n)&&i.approxEqual(this.b,e.b,n)&&i.approxEqual(this.a,e.a,n)},this.equals=function(e){return this.r==e.r&&this.g==e.g&&this.b==e.b&&this.a==e.a},this.clone=function(){return new e(this.r,this.g,this.b,this.a)},this.toNumber=function(){var e=+this.r,n=+this.g,t=+this.b;return(e=e>0?Math.min(Math.round(e),255):0)<<16|(n=n>0?Math.min(Math.round(n),255):0)<<8|(t=t>0?Math.min(Math.round(t),255):0)},this.toArray=function(e){var n=+this.r,t=+this.g,o=+this.b,r=+this.a;return!0===e&&(n=n>0?Math.min(Math.round(n),255):0,t=t>0?Math.min(Math.round(t),255):0,o=o>0?Math.min(Math.round(o),255):0,r=r>0?Math.min(r,1):0),[n,t,o,r]},this.toString=function(e,n){if("hex"===e){for(var t=this.toNumber().toString(16).toUpperCase(),o=t.length;o<6;o++)t="0"+t;return"#"+t}var r=+this.r,i=+this.g,s=+this.b,a=+this.a;return!0!==e&&!0!==n||(r=r>0?Math.min(Math.round(r),255):0,i=i>0?Math.min(Math.round(i),255):0,s=s>0?Math.min(Math.round(s),255):0,a=a>0?Math.min(a,1):0),"rgba"===e?"rgba("+r+","+i+","+s+","+a+")":"rgb"===e?"rgb("+r+","+i+","+s+")":"("+r+","+i+","+s+","+a+")"}})}.call(n,t,n,e))||(e.exports=o)},"contrib/jg_lib/utils/NumberUtil":function(e,n,t){var o;
/*!
 * Copyright (c) 2007-2016 Jason Gatt
 * 
 * Released under the MIT license:
 * http://opensource.org/licenses/MIT
 */void 0===(o=function(e,n,o){return t("contrib/jg_lib/Class")(o.i,function(e){e.PRECISION=function(){for(var e=0,n=9,t=0;n%10==9&&(e++,n=10*n+9,!(++t>100)););return e}(),e.EPSILON=function(){for(var e=1,n=1,t=0;1+n>1&&(e=n,n/=2,!(++t>100)););return e}(),e.interpolate=function(e,n,t){return e*(1-t)+n*t},e.minMax=function(e,n,t){return(e=+e)<(n=+n)&&(e=n),e>(t=+t)&&(e=t),e},e.maxMin=function(e,n,t){return(e=+e)>(n=+n)&&(e=n),e<(t=+t)&&(e=t),e},e.roundTo=function(n,t){return n=+n,(t=null!=t?+t:1)>0&&(n=Math.round(n/t)*t),e.toPrecision(n)},e.floorTo=function(n,t){return n=+n,(t=null!=t?+t:1)>0&&(n=Math.floor(n/t)*t),e.toPrecision(n)},e.ceilTo=function(n,t){return n=+n,(t=null!=t?+t:1)>0&&(n=Math.ceil(n/t)*t),e.toPrecision(n)},e.toPrecision=function(n,t){return n=+n,(t=(t=null!=t?+t:0)>0?Math.floor(t):t<0?e.PRECISION+Math.ceil(t):e.PRECISION)<1?t=1:t>21&&(t=21),+n.toPrecision(t)},e.approxZero=function(n,t){return 0===(n=+n)||(t=null!=t?+t:e.EPSILON,n<0?-n<t:n<t)},e.approxOne=function(n,t){return 1===(n=+n)||(t=null!=t?+t:e.EPSILON,(n-=1)<0?-n<t:n<t)},e.approxEqual=function(n,t,o){return(n=+n)===(t=+t)||(o=null!=o?+o:e.EPSILON,(n-=t)<0?-n<o:n<o)},e.approxLessThan=function(n,t,o){return(n=+n)<(t=+t)&&!e.approxEqual(n,t,o)},e.approxLessThanOrEqual=function(n,t,o){return(n=+n)<(t=+t)||e.approxEqual(n,t,o)},e.approxGreaterThan=function(n,t,o){return(n=+n)>(t=+t)&&!e.approxEqual(n,t,o)},e.approxGreaterThanOrEqual=function(n,t,o){return(n=+n)>(t=+t)||e.approxEqual(n,t,o)}})}.call(n,t,n,e))||(e.exports=o)},"contrib/jquery-2.1.0":function(e,n,t){var o,r,i;
/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */
/*!
 * jQuery JavaScript Library v2.1.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:10Z
 */
r="undefined"!=typeof window?window:this,i=function(t,r){var i=[],s=i.slice,a=i.concat,l=i.push,c=i.indexOf,d={},h=d.toString,u=d.hasOwnProperty,p="".trim,f={},m=t.document,g=function(e,n){return new g.fn.init(e,n)},y=/^-ms-/,b=/-([\da-z])/gi,x=function(e,n){return n.toUpperCase()};function v(e){var n=e.length,t=g.type(e);return"function"!==t&&!g.isWindow(e)&&(!(1!==e.nodeType||!n)||("array"===t||0===n||"number"==typeof n&&n>0&&n-1 in e))}g.fn=g.prototype={jquery:"2.1.0",constructor:g,selector:"",length:0,toArray:function(){return s.call(this)},get:function(e){return null!=e?e<0?this[e+this.length]:this[e]:s.call(this)},pushStack:function(e){var n=g.merge(this.constructor(),e);return n.prevObject=this,n.context=this.context,n},each:function(e,n){return g.each(this,e,n)},map:function(e){return this.pushStack(g.map(this,function(n,t){return e.call(n,t,n)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var n=this.length,t=+e+(e<0?n:0);return this.pushStack(t>=0&&t<n?[this[t]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:l,sort:i.sort,splice:i.splice},g.extend=g.fn.extend=function(){var e,n,t,o,r,i,s=arguments[0]||{},a=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[a]||{},a++),"object"==typeof s||g.isFunction(s)||(s={}),a===l&&(s=this,a--);a<l;a++)if(null!=(e=arguments[a]))for(n in e)t=s[n],s!==(o=e[n])&&(c&&o&&(g.isPlainObject(o)||(r=g.isArray(o)))?(r?(r=!1,i=t&&g.isArray(t)?t:[]):i=t&&g.isPlainObject(t)?t:{},s[n]=g.extend(c,i,o)):void 0!==o&&(s[n]=o));return s},g.extend({expando:"jQuery"+("2.1.0"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===g.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return e-parseFloat(e)>=0},isPlainObject:function(e){if("object"!==g.type(e)||e.nodeType||g.isWindow(e))return!1;try{if(e.constructor&&!u.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(e){return!1}return!0},isEmptyObject:function(e){var n;for(n in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?d[h.call(e)]||"object":typeof e},globalEval:function(e){var n,t=eval;(e=g.trim(e))&&(1===e.indexOf("use strict")?((n=m.createElement("script")).text=e,m.head.appendChild(n).parentNode.removeChild(n)):t(e))},camelCase:function(e){return e.replace(y,"ms-").replace(b,x)},nodeName:function(e,n){return e.nodeName&&e.nodeName.toLowerCase()===n.toLowerCase()},each:function(e,n,t){var o=0,r=e.length,i=v(e);if(t){if(i)for(;o<r&&!1!==n.apply(e[o],t);o++);else for(o in e)if(!1===n.apply(e[o],t))break}else if(i)for(;o<r&&!1!==n.call(e[o],o,e[o]);o++);else for(o in e)if(!1===n.call(e[o],o,e[o]))break;return e},trim:function(e){return null==e?"":p.call(e)},makeArray:function(e,n){var t=n||[];return null!=e&&(v(Object(e))?g.merge(t,"string"==typeof e?[e]:e):l.call(t,e)),t},inArray:function(e,n,t){return null==n?-1:c.call(n,e,t)},merge:function(e,n){for(var t=+n.length,o=0,r=e.length;o<t;o++)e[r++]=n[o];return e.length=r,e},grep:function(e,n,t){for(var o=[],r=0,i=e.length,s=!t;r<i;r++)!n(e[r],r)!==s&&o.push(e[r]);return o},map:function(e,n,t){var o,r=0,i=e.length,s=[];if(v(e))for(;r<i;r++)null!=(o=n(e[r],r,t))&&s.push(o);else for(r in e)null!=(o=n(e[r],r,t))&&s.push(o);return a.apply([],s)},guid:1,proxy:function(e,n){var t,o,r;if("string"==typeof n&&(t=e[n],n=e,e=t),g.isFunction(e))return o=s.call(arguments,2),(r=function(){return e.apply(n||this,o.concat(s.call(arguments)))}).guid=e.guid=e.guid||g.guid++,r},now:Date.now,support:f}),g.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,n){d["[object "+n+"]"]=n.toLowerCase()});var j=
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
function(e){var n,t,o,r,i,s,a,l,c,d,h,u,p,f,m,g,y,b="sizzle"+-new Date,x=e.document,v=0,j=0,w=oe(),k=oe(),_=oe(),S=function(e,n){return e===n&&(c=!0),0},C="undefined",A=1<<31,T={}.hasOwnProperty,O=[],P=O.pop,M=O.push,L=O.push,H=O.slice,I=O.indexOf||function(e){for(var n=0,t=this.length;n<t;n++)if(this[n]===e)return n;return-1},D="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",E="[\\x20\\t\\r\\n\\f]",B="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",R=B.replace("w","w#"),N="\\["+E+"*("+B+")"+E+"*(?:([*^$|!~]?=)"+E+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+R+")|)|)"+E+"*\\]",z=":("+B+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+N.replace(3,8)+")*)|.*)\\)|)",G=new RegExp("^"+E+"+|((?:^|[^\\\\])(?:\\\\.)*)"+E+"+$","g"),W=new RegExp("^"+E+"*,"+E+"*"),F=new RegExp("^"+E+"*([>+~]|"+E+")"+E+"*"),X=new RegExp("="+E+"*([^\\]'\"]*?)"+E+"*\\]","g"),V=new RegExp(z),Y=new RegExp("^"+R+"$"),U={ID:new RegExp("^#("+B+")"),CLASS:new RegExp("^\\.("+B+")"),TAG:new RegExp("^("+B.replace("w","w*")+")"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+z),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+E+"*(even|odd|(([+-]|)(\\d*)n|)"+E+"*(?:([+-]|)"+E+"*(\\d+)|))"+E+"*\\)|)","i"),bool:new RegExp("^(?:"+D+")$","i"),needsContext:new RegExp("^"+E+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+E+"*((?:-\\d)?\\d*)"+E+"*\\)|)(?=[^-]|$)","i")},q=/^(?:input|select|textarea|button)$/i,K=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,J=/[+~]/,Q=/'|\\/g,ee=new RegExp("\\\\([\\da-f]{1,6}"+E+"?|("+E+")|.)","ig"),ne=function(e,n,t){var o="0x"+n-65536;return o!=o||t?n:o<0?String.fromCharCode(o+65536):String.fromCharCode(o>>10|55296,1023&o|56320)};try{L.apply(O=H.call(x.childNodes),x.childNodes),O[x.childNodes.length].nodeType}catch(e){L={apply:O.length?function(e,n){M.apply(e,H.call(n))}:function(e,n){for(var t=e.length,o=0;e[t++]=n[o++];);e.length=t-1}}}function te(e,n,r,i){var a,l,c,u,m,g,v,j,w,k;if((n?n.ownerDocument||n:x)!==h&&d(n),r=r||[],!e||"string"!=typeof e)return r;if(1!==(u=(n=n||h).nodeType)&&9!==u)return[];if(p&&!i){if(a=Z.exec(e))if(c=a[1]){if(9===u){if(!(l=n.getElementById(c))||!l.parentNode)return r;if(l.id===c)return r.push(l),r}else if(n.ownerDocument&&(l=n.ownerDocument.getElementById(c))&&y(n,l)&&l.id===c)return r.push(l),r}else{if(a[2])return L.apply(r,n.getElementsByTagName(e)),r;if((c=a[3])&&t.getElementsByClassName&&n.getElementsByClassName)return L.apply(r,n.getElementsByClassName(c)),r}if(t.qsa&&(!f||!f.test(e))){if(j=v=b,w=n,k=9===u&&e,1===u&&"object"!==n.nodeName.toLowerCase()){for(g=pe(e),(v=n.getAttribute("id"))?j=v.replace(Q,"\\$&"):n.setAttribute("id",j),j="[id='"+j+"'] ",m=g.length;m--;)g[m]=j+fe(g[m]);w=J.test(e)&&he(n.parentNode)||n,k=g.join(",")}if(k)try{return L.apply(r,w.querySelectorAll(k)),r}catch(e){}finally{v||n.removeAttribute("id")}}}return function(e,n,r,i){var a,l,c,d,h,u=pe(e);if(!i&&1===u.length){if((l=u[0]=u[0].slice(0)).length>2&&"ID"===(c=l[0]).type&&t.getById&&9===n.nodeType&&p&&o.relative[l[1].type]){if(!(n=(o.find.ID(c.matches[0].replace(ee,ne),n)||[])[0]))return r;e=e.slice(l.shift().value.length)}for(a=U.needsContext.test(e)?0:l.length;a--&&(c=l[a],!o.relative[d=c.type]);)if((h=o.find[d])&&(i=h(c.matches[0].replace(ee,ne),J.test(l[0].type)&&he(n.parentNode)||n))){if(l.splice(a,1),!(e=i.length&&fe(l)))return L.apply(r,i),r;break}}return s(e,u)(i,n,!p,r,J.test(e)&&he(n.parentNode)||n),r}(e.replace(G,"$1"),n,r,i)}function oe(){var e=[];return function n(t,r){return e.push(t+" ")>o.cacheLength&&delete n[e.shift()],n[t+" "]=r}}function re(e){return e[b]=!0,e}function ie(e){var n=h.createElement("div");try{return!!e(n)}catch(e){return!1}finally{n.parentNode&&n.parentNode.removeChild(n),n=null}}function se(e,n){for(var t=e.split("|"),r=e.length;r--;)o.attrHandle[t[r]]=n}function ae(e,n){var t=n&&e,o=t&&1===e.nodeType&&1===n.nodeType&&(~n.sourceIndex||A)-(~e.sourceIndex||A);if(o)return o;if(t)for(;t=t.nextSibling;)if(t===n)return-1;return e?1:-1}function le(e){return function(n){return"input"===n.nodeName.toLowerCase()&&n.type===e}}function ce(e){return function(n){var t=n.nodeName.toLowerCase();return("input"===t||"button"===t)&&n.type===e}}function de(e){return re(function(n){return n=+n,re(function(t,o){for(var r,i=e([],t.length,n),s=i.length;s--;)t[r=i[s]]&&(t[r]=!(o[r]=t[r]))})})}function he(e){return e&&typeof e.getElementsByTagName!==C&&e}for(n in t=te.support={},i=te.isXML=function(e){var n=e&&(e.ownerDocument||e).documentElement;return!!n&&"HTML"!==n.nodeName},d=te.setDocument=function(e){var n,r=e?e.ownerDocument||e:x,s=r.defaultView;return r!==h&&9===r.nodeType&&r.documentElement?(h=r,u=r.documentElement,p=!i(r),s&&s!==s.top&&(s.addEventListener?s.addEventListener("unload",function(){d()},!1):s.attachEvent&&s.attachEvent("onunload",function(){d()})),t.attributes=ie(function(e){return e.className="i",!e.getAttribute("className")}),t.getElementsByTagName=ie(function(e){return e.appendChild(r.createComment("")),!e.getElementsByTagName("*").length}),t.getElementsByClassName=$.test(r.getElementsByClassName)&&ie(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),t.getById=ie(function(e){return u.appendChild(e).id=b,!r.getElementsByName||!r.getElementsByName(b).length}),t.getById?(o.find.ID=function(e,n){if(typeof n.getElementById!==C&&p){var t=n.getElementById(e);return t&&t.parentNode?[t]:[]}},o.filter.ID=function(e){var n=e.replace(ee,ne);return function(e){return e.getAttribute("id")===n}}):(delete o.find.ID,o.filter.ID=function(e){var n=e.replace(ee,ne);return function(e){var t=typeof e.getAttributeNode!==C&&e.getAttributeNode("id");return t&&t.value===n}}),o.find.TAG=t.getElementsByTagName?function(e,n){if(typeof n.getElementsByTagName!==C)return n.getElementsByTagName(e)}:function(e,n){var t,o=[],r=0,i=n.getElementsByTagName(e);if("*"===e){for(;t=i[r++];)1===t.nodeType&&o.push(t);return o}return i},o.find.CLASS=t.getElementsByClassName&&function(e,n){if(typeof n.getElementsByClassName!==C&&p)return n.getElementsByClassName(e)},m=[],f=[],(t.qsa=$.test(r.querySelectorAll))&&(ie(function(e){e.innerHTML="<select t=''><option selected=''></option></select>",e.querySelectorAll("[t^='']").length&&f.push("[*^$]="+E+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||f.push("\\["+E+"*(?:value|"+D+")"),e.querySelectorAll(":checked").length||f.push(":checked")}),ie(function(e){var n=r.createElement("input");n.setAttribute("type","hidden"),e.appendChild(n).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&f.push("name"+E+"*[*^$|!~]?="),e.querySelectorAll(":enabled").length||f.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),f.push(",.*:")})),(t.matchesSelector=$.test(g=u.webkitMatchesSelector||u.mozMatchesSelector||u.oMatchesSelector||u.msMatchesSelector))&&ie(function(e){t.disconnectedMatch=g.call(e,"div"),g.call(e,"[s!='']:x"),m.push("!=",z)}),f=f.length&&new RegExp(f.join("|")),m=m.length&&new RegExp(m.join("|")),n=$.test(u.compareDocumentPosition),y=n||$.test(u.contains)?function(e,n){var t=9===e.nodeType?e.documentElement:e,o=n&&n.parentNode;return e===o||!(!o||1!==o.nodeType||!(t.contains?t.contains(o):e.compareDocumentPosition&&16&e.compareDocumentPosition(o)))}:function(e,n){if(n)for(;n=n.parentNode;)if(n===e)return!0;return!1},S=n?function(e,n){if(e===n)return c=!0,0;var o=!e.compareDocumentPosition-!n.compareDocumentPosition;return o||(1&(o=(e.ownerDocument||e)===(n.ownerDocument||n)?e.compareDocumentPosition(n):1)||!t.sortDetached&&n.compareDocumentPosition(e)===o?e===r||e.ownerDocument===x&&y(x,e)?-1:n===r||n.ownerDocument===x&&y(x,n)?1:l?I.call(l,e)-I.call(l,n):0:4&o?-1:1)}:function(e,n){if(e===n)return c=!0,0;var t,o=0,i=e.parentNode,s=n.parentNode,a=[e],d=[n];if(!i||!s)return e===r?-1:n===r?1:i?-1:s?1:l?I.call(l,e)-I.call(l,n):0;if(i===s)return ae(e,n);for(t=e;t=t.parentNode;)a.unshift(t);for(t=n;t=t.parentNode;)d.unshift(t);for(;a[o]===d[o];)o++;return o?ae(a[o],d[o]):a[o]===x?-1:d[o]===x?1:0},r):h},te.matches=function(e,n){return te(e,null,null,n)},te.matchesSelector=function(e,n){if((e.ownerDocument||e)!==h&&d(e),n=n.replace(X,"='$1']"),t.matchesSelector&&p&&(!m||!m.test(n))&&(!f||!f.test(n)))try{var o=g.call(e,n);if(o||t.disconnectedMatch||e.document&&11!==e.document.nodeType)return o}catch(e){}return te(n,h,null,[e]).length>0},te.contains=function(e,n){return(e.ownerDocument||e)!==h&&d(e),y(e,n)},te.attr=function(e,n){(e.ownerDocument||e)!==h&&d(e);var r=o.attrHandle[n.toLowerCase()],i=r&&T.call(o.attrHandle,n.toLowerCase())?r(e,n,!p):void 0;return void 0!==i?i:t.attributes||!p?e.getAttribute(n):(i=e.getAttributeNode(n))&&i.specified?i.value:null},te.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},te.uniqueSort=function(e){var n,o=[],r=0,i=0;if(c=!t.detectDuplicates,l=!t.sortStable&&e.slice(0),e.sort(S),c){for(;n=e[i++];)n===e[i]&&(r=o.push(i));for(;r--;)e.splice(o[r],1)}return l=null,e},r=te.getText=function(e){var n,t="",o=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)t+=r(e)}else if(3===i||4===i)return e.nodeValue}else for(;n=e[o++];)t+=r(n);return t},(o=te.selectors={cacheLength:50,createPseudo:re,match:U,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(ee,ne),e[3]=(e[4]||e[5]||"").replace(ee,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||te.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&te.error(e[0]),e},PSEUDO:function(e){var n,t=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[3]&&void 0!==e[4]?e[2]=e[4]:t&&V.test(t)&&(n=pe(t,!0))&&(n=t.indexOf(")",t.length-n)-t.length)&&(e[0]=e[0].slice(0,n),e[2]=t.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var n=e.replace(ee,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===n}},CLASS:function(e){var n=w[e+" "];return n||(n=new RegExp("(^|"+E+")"+e+"("+E+"|$)"))&&w(e,function(e){return n.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==C&&e.getAttribute("class")||"")})},ATTR:function(e,n,t){return function(o){var r=te.attr(o,e);return null==r?"!="===n:!n||(r+="","="===n?r===t:"!="===n?r!==t:"^="===n?t&&0===r.indexOf(t):"*="===n?t&&r.indexOf(t)>-1:"$="===n?t&&r.slice(-t.length)===t:"~="===n?(" "+r+" ").indexOf(t)>-1:"|="===n&&(r===t||r.slice(0,t.length+1)===t+"-"))}},CHILD:function(e,n,t,o,r){var i="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===n;return 1===o&&0===r?function(e){return!!e.parentNode}:function(n,t,l){var c,d,h,u,p,f,m=i!==s?"nextSibling":"previousSibling",g=n.parentNode,y=a&&n.nodeName.toLowerCase(),x=!l&&!a;if(g){if(i){for(;m;){for(h=n;h=h[m];)if(a?h.nodeName.toLowerCase()===y:1===h.nodeType)return!1;f=m="only"===e&&!f&&"nextSibling"}return!0}if(f=[s?g.firstChild:g.lastChild],s&&x){for(p=(c=(d=g[b]||(g[b]={}))[e]||[])[0]===v&&c[1],u=c[0]===v&&c[2],h=p&&g.childNodes[p];h=++p&&h&&h[m]||(u=p=0)||f.pop();)if(1===h.nodeType&&++u&&h===n){d[e]=[v,p,u];break}}else if(x&&(c=(n[b]||(n[b]={}))[e])&&c[0]===v)u=c[1];else for(;(h=++p&&h&&h[m]||(u=p=0)||f.pop())&&((a?h.nodeName.toLowerCase()!==y:1!==h.nodeType)||!++u||(x&&((h[b]||(h[b]={}))[e]=[v,u]),h!==n)););return(u-=r)===o||u%o==0&&u/o>=0}}},PSEUDO:function(e,n){var t,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||te.error("unsupported pseudo: "+e);return r[b]?r(n):r.length>1?(t=[e,e,"",n],o.setFilters.hasOwnProperty(e.toLowerCase())?re(function(e,t){for(var o,i=r(e,n),s=i.length;s--;)e[o=I.call(e,i[s])]=!(t[o]=i[s])}):function(e){return r(e,0,t)}):r}},pseudos:{not:re(function(e){var n=[],t=[],o=s(e.replace(G,"$1"));return o[b]?re(function(e,n,t,r){for(var i,s=o(e,null,r,[]),a=e.length;a--;)(i=s[a])&&(e[a]=!(n[a]=i))}):function(e,r,i){return n[0]=e,o(n,null,i,t),!t.pop()}}),has:re(function(e){return function(n){return te(e,n).length>0}}),contains:re(function(e){return function(n){return(n.textContent||n.innerText||r(n)).indexOf(e)>-1}}),lang:re(function(e){return Y.test(e||"")||te.error("unsupported lang: "+e),e=e.replace(ee,ne).toLowerCase(),function(n){var t;do{if(t=p?n.lang:n.getAttribute("xml:lang")||n.getAttribute("lang"))return(t=t.toLowerCase())===e||0===t.indexOf(e+"-")}while((n=n.parentNode)&&1===n.nodeType);return!1}}),target:function(n){var t=e.location&&e.location.hash;return t&&t.slice(1)===n.id},root:function(e){return e===u},focus:function(e){return e===h.activeElement&&(!h.hasFocus||h.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return!1===e.disabled},disabled:function(e){return!0===e.disabled},checked:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&!!e.checked||"option"===n&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return K.test(e.nodeName)},input:function(e){return q.test(e.nodeName)},button:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&"button"===e.type||"button"===n},text:function(e){var n;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(n=e.getAttribute("type"))||"text"===n.toLowerCase())},first:de(function(){return[0]}),last:de(function(e,n){return[n-1]}),eq:de(function(e,n,t){return[t<0?t+n:t]}),even:de(function(e,n){for(var t=0;t<n;t+=2)e.push(t);return e}),odd:de(function(e,n){for(var t=1;t<n;t+=2)e.push(t);return e}),lt:de(function(e,n,t){for(var o=t<0?t+n:t;--o>=0;)e.push(o);return e}),gt:de(function(e,n,t){for(var o=t<0?t+n:t;++o<n;)e.push(o);return e})}}).pseudos.nth=o.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=le(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=ce(n);function ue(){}function pe(e,n){var t,r,i,s,a,l,c,d=k[e+" "];if(d)return n?0:d.slice(0);for(a=e,l=[],c=o.preFilter;a;){for(s in t&&!(r=W.exec(a))||(r&&(a=a.slice(r[0].length)||a),l.push(i=[])),t=!1,(r=F.exec(a))&&(t=r.shift(),i.push({value:t,type:r[0].replace(G," ")}),a=a.slice(t.length)),o.filter)!(r=U[s].exec(a))||c[s]&&!(r=c[s](r))||(t=r.shift(),i.push({value:t,type:s,matches:r}),a=a.slice(t.length));if(!t)break}return n?a.length:a?te.error(e):k(e,l).slice(0)}function fe(e){for(var n=0,t=e.length,o="";n<t;n++)o+=e[n].value;return o}function me(e,n,t){var o=n.dir,r=t&&"parentNode"===o,i=j++;return n.first?function(n,t,i){for(;n=n[o];)if(1===n.nodeType||r)return e(n,t,i)}:function(n,t,s){var a,l,c=[v,i];if(s){for(;n=n[o];)if((1===n.nodeType||r)&&e(n,t,s))return!0}else for(;n=n[o];)if(1===n.nodeType||r){if((a=(l=n[b]||(n[b]={}))[o])&&a[0]===v&&a[1]===i)return c[2]=a[2];if(l[o]=c,c[2]=e(n,t,s))return!0}}}function ge(e){return e.length>1?function(n,t,o){for(var r=e.length;r--;)if(!e[r](n,t,o))return!1;return!0}:e[0]}function ye(e,n,t,o,r){for(var i,s=[],a=0,l=e.length,c=null!=n;a<l;a++)(i=e[a])&&(t&&!t(i,o,r)||(s.push(i),c&&n.push(a)));return s}function be(e,n,t,o,r,i){return o&&!o[b]&&(o=be(o)),r&&!r[b]&&(r=be(r,i)),re(function(i,s,a,l){var c,d,h,u=[],p=[],f=s.length,m=i||function(e,n,t){for(var o=0,r=n.length;o<r;o++)te(e,n[o],t);return t}(n||"*",a.nodeType?[a]:a,[]),g=!e||!i&&n?m:ye(m,u,e,a,l),y=t?r||(i?e:f||o)?[]:s:g;if(t&&t(g,y,a,l),o)for(c=ye(y,p),o(c,[],a,l),d=c.length;d--;)(h=c[d])&&(y[p[d]]=!(g[p[d]]=h));if(i){if(r||e){if(r){for(c=[],d=y.length;d--;)(h=y[d])&&c.push(g[d]=h);r(null,y=[],c,l)}for(d=y.length;d--;)(h=y[d])&&(c=r?I.call(i,h):u[d])>-1&&(i[c]=!(s[c]=h))}}else y=ye(y===s?y.splice(f,y.length):y),r?r(null,s,y,l):L.apply(s,y)})}function xe(e){for(var n,t,r,i=e.length,s=o.relative[e[0].type],l=s||o.relative[" "],c=s?1:0,d=me(function(e){return e===n},l,!0),h=me(function(e){return I.call(n,e)>-1},l,!0),u=[function(e,t,o){return!s&&(o||t!==a)||((n=t).nodeType?d(e,t,o):h(e,t,o))}];c<i;c++)if(t=o.relative[e[c].type])u=[me(ge(u),t)];else{if((t=o.filter[e[c].type].apply(null,e[c].matches))[b]){for(r=++c;r<i&&!o.relative[e[r].type];r++);return be(c>1&&ge(u),c>1&&fe(e.slice(0,c-1).concat({value:" "===e[c-2].type?"*":""})).replace(G,"$1"),t,c<r&&xe(e.slice(c,r)),r<i&&xe(e=e.slice(r)),r<i&&fe(e))}u.push(t)}return ge(u)}return ue.prototype=o.filters=o.pseudos,o.setFilters=new ue,s=te.compile=function(e,n){var t,r=[],i=[],s=_[e+" "];if(!s){for(n||(n=pe(e)),t=n.length;t--;)(s=xe(n[t]))[b]?r.push(s):i.push(s);s=_(e,function(e,n){var t=n.length>0,r=e.length>0,i=function(i,s,l,c,d){var u,p,f,m=0,g="0",y=i&&[],b=[],x=a,j=i||r&&o.find.TAG("*",d),w=v+=null==x?1:Math.random()||.1,k=j.length;for(d&&(a=s!==h&&s);g!==k&&null!=(u=j[g]);g++){if(r&&u){for(p=0;f=e[p++];)if(f(u,s,l)){c.push(u);break}d&&(v=w)}t&&((u=!f&&u)&&m--,i&&y.push(u))}if(m+=g,t&&g!==m){for(p=0;f=n[p++];)f(y,b,s,l);if(i){if(m>0)for(;g--;)y[g]||b[g]||(b[g]=P.call(c));b=ye(b)}L.apply(c,b),d&&!i&&b.length>0&&m+n.length>1&&te.uniqueSort(c)}return d&&(v=w,a=x),y};return t?re(i):i}(i,r))}return s},t.sortStable=b.split("").sort(S).join("")===b,t.detectDuplicates=!!c,d(),t.sortDetached=ie(function(e){return 1&e.compareDocumentPosition(h.createElement("div"))}),ie(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||se("type|href|height|width",function(e,n,t){if(!t)return e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),t.attributes&&ie(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||se("value",function(e,n,t){if(!t&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ie(function(e){return null==e.getAttribute("disabled")})||se(D,function(e,n,t){var o;if(!t)return!0===e[n]?n.toLowerCase():(o=e.getAttributeNode(n))&&o.specified?o.value:null}),te}(t);g.find=j,g.expr=j.selectors,g.expr[":"]=g.expr.pseudos,g.unique=j.uniqueSort,g.text=j.getText,g.isXMLDoc=j.isXML,g.contains=j.contains;var w=g.expr.match.needsContext,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,_=/^.[^:#\[\.,]*$/;function S(e,n,t){if(g.isFunction(n))return g.grep(e,function(e,o){return!!n.call(e,o,e)!==t});if(n.nodeType)return g.grep(e,function(e){return e===n!==t});if("string"==typeof n){if(_.test(n))return g.filter(n,e,t);n=g.filter(n,e)}return g.grep(e,function(e){return c.call(n,e)>=0!==t})}g.filter=function(e,n,t){var o=n[0];return t&&(e=":not("+e+")"),1===n.length&&1===o.nodeType?g.find.matchesSelector(o,e)?[o]:[]:g.find.matches(e,g.grep(n,function(e){return 1===e.nodeType}))},g.fn.extend({find:function(e){var n,t=this.length,o=[],r=this;if("string"!=typeof e)return this.pushStack(g(e).filter(function(){for(n=0;n<t;n++)if(g.contains(r[n],this))return!0}));for(n=0;n<t;n++)g.find(e,r[n],o);return(o=this.pushStack(t>1?g.unique(o):o)).selector=this.selector?this.selector+" "+e:e,o},filter:function(e){return this.pushStack(S(this,e||[],!1))},not:function(e){return this.pushStack(S(this,e||[],!0))},is:function(e){return!!S(this,"string"==typeof e&&w.test(e)?g(e):e||[],!1).length}});var C,A=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;(g.fn.init=function(e,n){var t,o;if(!e)return this;if("string"==typeof e){if(!(t="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:A.exec(e))||!t[1]&&n)return!n||n.jquery?(n||C).find(e):this.constructor(n).find(e);if(t[1]){if(n=n instanceof g?n[0]:n,g.merge(this,g.parseHTML(t[1],n&&n.nodeType?n.ownerDocument||n:m,!0)),k.test(t[1])&&g.isPlainObject(n))for(t in n)g.isFunction(this[t])?this[t](n[t]):this.attr(t,n[t]);return this}return(o=m.getElementById(t[2]))&&o.parentNode&&(this.length=1,this[0]=o),this.context=m,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):g.isFunction(e)?void 0!==C.ready?C.ready(e):e(g):(void 0!==e.selector&&(this.selector=e.selector,this.context=e.context),g.makeArray(e,this))}).prototype=g.fn,C=g(m);var T=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,n){for(;(e=e[n])&&1!==e.nodeType;);return e}g.extend({dir:function(e,n,t){for(var o=[],r=void 0!==t;(e=e[n])&&9!==e.nodeType;)if(1===e.nodeType){if(r&&g(e).is(t))break;o.push(e)}return o},sibling:function(e,n){for(var t=[];e;e=e.nextSibling)1===e.nodeType&&e!==n&&t.push(e);return t}}),g.fn.extend({has:function(e){var n=g(e,this),t=n.length;return this.filter(function(){for(var e=0;e<t;e++)if(g.contains(this,n[e]))return!0})},closest:function(e,n){for(var t,o=0,r=this.length,i=[],s=w.test(e)||"string"!=typeof e?g(e,n||this.context):0;o<r;o++)for(t=this[o];t&&t!==n;t=t.parentNode)if(t.nodeType<11&&(s?s.index(t)>-1:1===t.nodeType&&g.find.matchesSelector(t,e))){i.push(t);break}return this.pushStack(i.length>1?g.unique(i):i)},index:function(e){return e?"string"==typeof e?c.call(g(e),this[0]):c.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,n){return this.pushStack(g.unique(g.merge(this.get(),g(e,n))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),g.each({parent:function(e){var n=e.parentNode;return n&&11!==n.nodeType?n:null},parents:function(e){return g.dir(e,"parentNode")},parentsUntil:function(e,n,t){return g.dir(e,"parentNode",t)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return g.dir(e,"nextSibling")},prevAll:function(e){return g.dir(e,"previousSibling")},nextUntil:function(e,n,t){return g.dir(e,"nextSibling",t)},prevUntil:function(e,n,t){return g.dir(e,"previousSibling",t)},siblings:function(e){return g.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return g.sibling(e.firstChild)},contents:function(e){return e.contentDocument||g.merge([],e.childNodes)}},function(e,n){g.fn[e]=function(t,o){var r=g.map(this,n,t);return"Until"!==e.slice(-5)&&(o=t),o&&"string"==typeof o&&(r=g.filter(o,r)),this.length>1&&(O[e]||g.unique(r),T.test(e)&&r.reverse()),this.pushStack(r)}});var M,L=/\S+/g,H={};function I(){m.removeEventListener("DOMContentLoaded",I,!1),t.removeEventListener("load",I,!1),g.ready()}g.Callbacks=function(e){e="string"==typeof e?H[e]||function(e){var n=H[e]={};return g.each(e.match(L)||[],function(e,t){n[t]=!0}),n}(e):g.extend({},e);var n,t,o,r,i,s,a=[],l=!e.once&&[],c=function(h){for(n=e.memory&&h,t=!0,s=r||0,r=0,i=a.length,o=!0;a&&s<i;s++)if(!1===a[s].apply(h[0],h[1])&&e.stopOnFalse){n=!1;break}o=!1,a&&(l?l.length&&c(l.shift()):n?a=[]:d.disable())},d={add:function(){if(a){var t=a.length;!function n(t){g.each(t,function(t,o){var r=g.type(o);"function"===r?e.unique&&d.has(o)||a.push(o):o&&o.length&&"string"!==r&&n(o)})}(arguments),o?i=a.length:n&&(r=t,c(n))}return this},remove:function(){return a&&g.each(arguments,function(e,n){for(var t;(t=g.inArray(n,a,t))>-1;)a.splice(t,1),o&&(t<=i&&i--,t<=s&&s--)}),this},has:function(e){return e?g.inArray(e,a)>-1:!(!a||!a.length)},empty:function(){return a=[],i=0,this},disable:function(){return a=l=n=void 0,this},disabled:function(){return!a},lock:function(){return l=void 0,n||d.disable(),this},locked:function(){return!l},fireWith:function(e,n){return!a||t&&!l||(n=[e,(n=n||[]).slice?n.slice():n],o?l.push(n):c(n)),this},fire:function(){return d.fireWith(this,arguments),this},fired:function(){return!!t}};return d},g.extend({Deferred:function(e){var n=[["resolve","done",g.Callbacks("once memory"),"resolved"],["reject","fail",g.Callbacks("once memory"),"rejected"],["notify","progress",g.Callbacks("memory")]],t="pending",o={state:function(){return t},always:function(){return r.done(arguments).fail(arguments),this},then:function(){var e=arguments;return g.Deferred(function(t){g.each(n,function(n,i){var s=g.isFunction(e[n])&&e[n];r[i[1]](function(){var e=s&&s.apply(this,arguments);e&&g.isFunction(e.promise)?e.promise().done(t.resolve).fail(t.reject).progress(t.notify):t[i[0]+"With"](this===o?t.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?g.extend(e,o):o}},r={};return o.pipe=o.then,g.each(n,function(e,i){var s=i[2],a=i[3];o[i[1]]=s.add,a&&s.add(function(){t=a},n[1^e][2].disable,n[2][2].lock),r[i[0]]=function(){return r[i[0]+"With"](this===r?o:this,arguments),this},r[i[0]+"With"]=s.fireWith}),o.promise(r),e&&e.call(r,r),r},when:function(e){var n,t,o,r=0,i=s.call(arguments),a=i.length,l=1!==a||e&&g.isFunction(e.promise)?a:0,c=1===l?e:g.Deferred(),d=function(e,t,o){return function(r){t[e]=this,o[e]=arguments.length>1?s.call(arguments):r,o===n?c.notifyWith(t,o):--l||c.resolveWith(t,o)}};if(a>1)for(n=new Array(a),t=new Array(a),o=new Array(a);r<a;r++)i[r]&&g.isFunction(i[r].promise)?i[r].promise().done(d(r,o,i)).fail(c.reject).progress(d(r,t,n)):--l;return l||c.resolveWith(o,i),c.promise()}}),g.fn.ready=function(e){return g.ready.promise().done(e),this},g.extend({isReady:!1,readyWait:1,holdReady:function(e){e?g.readyWait++:g.ready(!0)},ready:function(e){(!0===e?--g.readyWait:g.isReady)||(g.isReady=!0,!0!==e&&--g.readyWait>0||(M.resolveWith(m,[g]),g.fn.trigger&&g(m).trigger("ready").off("ready")))}}),g.ready.promise=function(e){return M||(M=g.Deferred(),"complete"===m.readyState?setTimeout(g.ready):(m.addEventListener("DOMContentLoaded",I,!1),t.addEventListener("load",I,!1))),M.promise(e)},g.ready.promise();var D=g.access=function(e,n,t,o,r,i,s){var a=0,l=e.length,c=null==t;if("object"===g.type(t))for(a in r=!0,t)g.access(e,n,a,t[a],!0,i,s);else if(void 0!==o&&(r=!0,g.isFunction(o)||(s=!0),c&&(s?(n.call(e,o),n=null):(c=n,n=function(e,n,t){return c.call(g(e),t)})),n))for(;a<l;a++)n(e[a],t,s?o:o.call(e[a],a,n(e[a],t)));return r?e:c?n.call(e):l?n(e[0],t):i};function E(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=g.expando+Math.random()}g.acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType},E.uid=1,E.accepts=g.acceptData,E.prototype={key:function(e){if(!E.accepts(e))return 0;var n={},t=e[this.expando];if(!t){t=E.uid++;try{n[this.expando]={value:t},Object.defineProperties(e,n)}catch(o){n[this.expando]=t,g.extend(e,n)}}return this.cache[t]||(this.cache[t]={}),t},set:function(e,n,t){var o,r=this.key(e),i=this.cache[r];if("string"==typeof n)i[n]=t;else if(g.isEmptyObject(i))g.extend(this.cache[r],n);else for(o in n)i[o]=n[o];return i},get:function(e,n){var t=this.cache[this.key(e)];return void 0===n?t:t[n]},access:function(e,n,t){var o;return void 0===n||n&&"string"==typeof n&&void 0===t?void 0!==(o=this.get(e,n))?o:this.get(e,g.camelCase(n)):(this.set(e,n,t),void 0!==t?t:n)},remove:function(e,n){var t,o,r,i=this.key(e),s=this.cache[i];if(void 0===n)this.cache[i]={};else{g.isArray(n)?o=n.concat(n.map(g.camelCase)):(r=g.camelCase(n),o=n in s?[n,r]:(o=r)in s?[o]:o.match(L)||[]),t=o.length;for(;t--;)delete s[o[t]]}},hasData:function(e){return!g.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}};var B=new E,R=new E,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,z=/([A-Z])/g;function G(e,n,t){var o;if(void 0===t&&1===e.nodeType)if(o="data-"+n.replace(z,"-$1").toLowerCase(),"string"==typeof(t=e.getAttribute(o))){try{t="true"===t||"false"!==t&&("null"===t?null:+t+""===t?+t:N.test(t)?g.parseJSON(t):t)}catch(e){}R.set(e,n,t)}else t=void 0;return t}g.extend({hasData:function(e){return R.hasData(e)||B.hasData(e)},data:function(e,n,t){return R.access(e,n,t)},removeData:function(e,n){R.remove(e,n)},_data:function(e,n,t){return B.access(e,n,t)},_removeData:function(e,n){B.remove(e,n)}}),g.fn.extend({data:function(e,n){var t,o,r,i=this[0],s=i&&i.attributes;if(void 0===e){if(this.length&&(r=R.get(i),1===i.nodeType&&!B.get(i,"hasDataAttrs"))){for(t=s.length;t--;)0===(o=s[t].name).indexOf("data-")&&(o=g.camelCase(o.slice(5)),G(i,o,r[o]));B.set(i,"hasDataAttrs",!0)}return r}return"object"==typeof e?this.each(function(){R.set(this,e)}):D(this,function(n){var t,o=g.camelCase(e);if(i&&void 0===n)return void 0!==(t=R.get(i,e))?t:void 0!==(t=R.get(i,o))?t:void 0!==(t=G(i,o,void 0))?t:void 0;this.each(function(){var t=R.get(this,o);R.set(this,o,n),-1!==e.indexOf("-")&&void 0!==t&&R.set(this,e,n)})},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){R.remove(this,e)})}}),g.extend({queue:function(e,n,t){var o;if(e)return n=(n||"fx")+"queue",o=B.get(e,n),t&&(!o||g.isArray(t)?o=B.access(e,n,g.makeArray(t)):o.push(t)),o||[]},dequeue:function(e,n){n=n||"fx";var t=g.queue(e,n),o=t.length,r=t.shift(),i=g._queueHooks(e,n);"inprogress"===r&&(r=t.shift(),o--),r&&("fx"===n&&t.unshift("inprogress"),delete i.stop,r.call(e,function(){g.dequeue(e,n)},i)),!o&&i&&i.empty.fire()},_queueHooks:function(e,n){var t=n+"queueHooks";return B.get(e,t)||B.access(e,t,{empty:g.Callbacks("once memory").add(function(){B.remove(e,[n+"queue",t])})})}}),g.fn.extend({queue:function(e,n){var t=2;return"string"!=typeof e&&(n=e,e="fx",t--),arguments.length<t?g.queue(this[0],e):void 0===n?this:this.each(function(){var t=g.queue(this,e,n);g._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&g.dequeue(this,e)})},dequeue:function(e){return this.each(function(){g.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var t,o=1,r=g.Deferred(),i=this,s=this.length,a=function(){--o||r.resolveWith(i,[i])};for("string"!=typeof e&&(n=e,e=void 0),e=e||"fx";s--;)(t=B.get(i[s],e+"queueHooks"))&&t.empty&&(o++,t.empty.add(a));return a(),r.promise(n)}});var W,F=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,X=["Top","Right","Bottom","Left"],V=function(e,n){return e=n||e,"none"===g.css(e,"display")||!g.contains(e.ownerDocument,e)},Y=/^(?:checkbox|radio)$/i;(W=m.createDocumentFragment().appendChild(m.createElement("div"))).innerHTML="<input type='radio' checked='checked' name='t'/>",f.checkClone=W.cloneNode(!0).cloneNode(!0).lastChild.checked,W.innerHTML="<textarea>x</textarea>",f.noCloneChecked=!!W.cloneNode(!0).lastChild.defaultValue,f.focusinBubbles="onfocusin"in t;var U=/^key/,q=/^(?:mouse|contextmenu)|click/,K=/^(?:focusinfocus|focusoutblur)$/,$=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function J(){return!1}function Q(){try{return m.activeElement}catch(e){}}g.event={global:{},add:function(e,n,t,o,r){var i,s,a,l,c,d,h,u,p,f,m,y=B.get(e);if(y)for(t.handler&&(t=(i=t).handler,r=i.selector),t.guid||(t.guid=g.guid++),(l=y.events)||(l=y.events={}),(s=y.handle)||(s=y.handle=function(n){return void 0!==g&&g.event.triggered!==n.type?g.event.dispatch.apply(e,arguments):void 0}),c=(n=(n||"").match(L)||[""]).length;c--;)p=m=(a=$.exec(n[c])||[])[1],f=(a[2]||"").split(".").sort(),p&&(h=g.event.special[p]||{},p=(r?h.delegateType:h.bindType)||p,h=g.event.special[p]||{},d=g.extend({type:p,origType:m,data:o,handler:t,guid:t.guid,selector:r,needsContext:r&&g.expr.match.needsContext.test(r),namespace:f.join(".")},i),(u=l[p])||((u=l[p]=[]).delegateCount=0,h.setup&&!1!==h.setup.call(e,o,f,s)||e.addEventListener&&e.addEventListener(p,s,!1)),h.add&&(h.add.call(e,d),d.handler.guid||(d.handler.guid=t.guid)),r?u.splice(u.delegateCount++,0,d):u.push(d),g.event.global[p]=!0)},remove:function(e,n,t,o,r){var i,s,a,l,c,d,h,u,p,f,m,y=B.hasData(e)&&B.get(e);if(y&&(l=y.events)){for(c=(n=(n||"").match(L)||[""]).length;c--;)if(p=m=(a=$.exec(n[c])||[])[1],f=(a[2]||"").split(".").sort(),p){for(h=g.event.special[p]||{},u=l[p=(o?h.delegateType:h.bindType)||p]||[],a=a[2]&&new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=i=u.length;i--;)d=u[i],!r&&m!==d.origType||t&&t.guid!==d.guid||a&&!a.test(d.namespace)||o&&o!==d.selector&&("**"!==o||!d.selector)||(u.splice(i,1),d.selector&&u.delegateCount--,h.remove&&h.remove.call(e,d));s&&!u.length&&(h.teardown&&!1!==h.teardown.call(e,f,y.handle)||g.removeEvent(e,p,y.handle),delete l[p])}else for(p in l)g.event.remove(e,p+n[c],t,o,!0);g.isEmptyObject(l)&&(delete y.handle,B.remove(e,"events"))}},trigger:function(e,n,o,r){var i,s,a,l,c,d,h,p=[o||m],f=u.call(e,"type")?e.type:e,y=u.call(e,"namespace")?e.namespace.split("."):[];if(s=a=o=o||m,3!==o.nodeType&&8!==o.nodeType&&!K.test(f+g.event.triggered)&&(f.indexOf(".")>=0&&(y=f.split("."),f=y.shift(),y.sort()),c=f.indexOf(":")<0&&"on"+f,(e=e[g.expando]?e:new g.Event(f,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=y.join("."),e.namespace_re=e.namespace?new RegExp("(^|\\.)"+y.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=o),n=null==n?[e]:g.makeArray(n,[e]),h=g.event.special[f]||{},r||!h.trigger||!1!==h.trigger.apply(o,n))){if(!r&&!h.noBubble&&!g.isWindow(o)){for(l=h.delegateType||f,K.test(l+f)||(s=s.parentNode);s;s=s.parentNode)p.push(s),a=s;a===(o.ownerDocument||m)&&p.push(a.defaultView||a.parentWindow||t)}for(i=0;(s=p[i++])&&!e.isPropagationStopped();)e.type=i>1?l:h.bindType||f,(d=(B.get(s,"events")||{})[e.type]&&B.get(s,"handle"))&&d.apply(s,n),(d=c&&s[c])&&d.apply&&g.acceptData(s)&&(e.result=d.apply(s,n),!1===e.result&&e.preventDefault());return e.type=f,r||e.isDefaultPrevented()||h._default&&!1!==h._default.apply(p.pop(),n)||!g.acceptData(o)||c&&g.isFunction(o[f])&&!g.isWindow(o)&&((a=o[c])&&(o[c]=null),g.event.triggered=f,o[f](),g.event.triggered=void 0,a&&(o[c]=a)),e.result}},dispatch:function(e){e=g.event.fix(e);var n,t,o,r,i,a,l=s.call(arguments),c=(B.get(this,"events")||{})[e.type]||[],d=g.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!d.preDispatch||!1!==d.preDispatch.call(this,e)){for(a=g.event.handlers.call(this,e,c),n=0;(r=a[n++])&&!e.isPropagationStopped();)for(e.currentTarget=r.elem,t=0;(i=r.handlers[t++])&&!e.isImmediatePropagationStopped();)e.namespace_re&&!e.namespace_re.test(i.namespace)||(e.handleObj=i,e.data=i.data,void 0!==(o=((g.event.special[i.origType]||{}).handle||i.handler).apply(r.elem,l))&&!1===(e.result=o)&&(e.preventDefault(),e.stopPropagation()));return d.postDispatch&&d.postDispatch.call(this,e),e.result}},handlers:function(e,n){var t,o,r,i,s=[],a=n.delegateCount,l=e.target;if(a&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!==this;l=l.parentNode||this)if(!0!==l.disabled||"click"!==e.type){for(o=[],t=0;t<a;t++)void 0===o[r=(i=n[t]).selector+" "]&&(o[r]=i.needsContext?g(r,this).index(l)>=0:g.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return a<n.length&&s.push({elem:this,handlers:n.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,n){return null==e.which&&(e.which=null!=n.charCode?n.charCode:n.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var t,o,r,i=n.button;return null==e.pageX&&null!=n.clientX&&(o=(t=e.target.ownerDocument||m).documentElement,r=t.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),e.which||void 0===i||(e.which=1&i?1:2&i?3:4&i?2:0),e}},fix:function(e){if(e[g.expando])return e;var n,t,o,r=e.type,i=e,s=this.fixHooks[r];for(s||(this.fixHooks[r]=s=q.test(r)?this.mouseHooks:U.test(r)?this.keyHooks:{}),o=s.props?this.props.concat(s.props):this.props,e=new g.Event(i),n=o.length;n--;)e[t=o[n]]=i[t];return e.target||(e.target=m),3===e.target.nodeType&&(e.target=e.target.parentNode),s.filter?s.filter(e,i):e},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==Q()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===Q()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&g.nodeName(this,"input"))return this.click(),!1},_default:function(e){return g.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,n,t,o){var r=g.extend(new g.Event,t,{type:e,isSimulated:!0,originalEvent:{}});o?g.event.trigger(r,null,n):g.event.dispatch.call(n,r),r.isDefaultPrevented()&&t.preventDefault()}},g.removeEvent=function(e,n,t){e.removeEventListener&&e.removeEventListener(n,t,!1)},g.Event=function(e,n){if(!(this instanceof g.Event))return new g.Event(e,n);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.getPreventDefault&&e.getPreventDefault()?Z:J):this.type=e,n&&g.extend(this,n),this.timeStamp=e&&e.timeStamp||g.now(),this[g.expando]=!0},g.Event.prototype={isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Z,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Z,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z,this.stopPropagation()}},g.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,n){g.event.special[e]={delegateType:n,bindType:n,handle:function(e){var t,o=e.relatedTarget,r=e.handleObj;return o&&(o===this||g.contains(this,o))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=n),t}}}),f.focusinBubbles||g.each({focus:"focusin",blur:"focusout"},function(e,n){var t=function(e){g.event.simulate(n,e.target,g.event.fix(e),!0)};g.event.special[n]={setup:function(){var o=this.ownerDocument||this,r=B.access(o,n);r||o.addEventListener(e,t,!0),B.access(o,n,(r||0)+1)},teardown:function(){var o=this.ownerDocument||this,r=B.access(o,n)-1;r?B.access(o,n,r):(o.removeEventListener(e,t,!0),B.remove(o,n))}}}),g.fn.extend({on:function(e,n,t,o,r){var i,s;if("object"==typeof e){for(s in"string"!=typeof n&&(t=t||n,n=void 0),e)this.on(s,n,t,e[s],r);return this}if(null==t&&null==o?(o=n,t=n=void 0):null==o&&("string"==typeof n?(o=t,t=void 0):(o=t,t=n,n=void 0)),!1===o)o=J;else if(!o)return this;return 1===r&&(i=o,(o=function(e){return g().off(e),i.apply(this,arguments)}).guid=i.guid||(i.guid=g.guid++)),this.each(function(){g.event.add(this,e,o,t,n)})},one:function(e,n,t,o){return this.on(e,n,t,o,1)},off:function(e,n,t){var o,r;if(e&&e.preventDefault&&e.handleObj)return o=e.handleObj,g(e.delegateTarget).off(o.namespace?o.origType+"."+o.namespace:o.origType,o.selector,o.handler),this;if("object"==typeof e){for(r in e)this.off(r,n,e[r]);return this}return!1!==n&&"function"!=typeof n||(t=n,n=void 0),!1===t&&(t=J),this.each(function(){g.event.remove(this,e,t,n)})},trigger:function(e,n){return this.each(function(){g.event.trigger(e,n,this)})},triggerHandler:function(e,n){var t=this[0];if(t)return g.event.trigger(e,n,t,!0)}});var ee=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ne=/<([\w:]+)/,te=/<|&#?\w+;/,oe=/<(?:script|style|link)/i,re=/checked\s*(?:[^=]|=\s*.checked.)/i,ie=/^$|\/(?:java|ecma)script/i,se=/^true\/(.*)/,ae=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,le={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ce(e,n){return g.nodeName(e,"table")&&g.nodeName(11!==n.nodeType?n:n.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function de(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function he(e){var n=se.exec(e.type);return n?e.type=n[1]:e.removeAttribute("type"),e}function ue(e,n){for(var t=0,o=e.length;t<o;t++)B.set(e[t],"globalEval",!n||B.get(n[t],"globalEval"))}function pe(e,n){var t,o,r,i,s,a,l,c;if(1===n.nodeType){if(B.hasData(e)&&(i=B.access(e),s=B.set(n,i),c=i.events))for(r in delete s.handle,s.events={},c)for(t=0,o=c[r].length;t<o;t++)g.event.add(n,r,c[r][t]);R.hasData(e)&&(a=R.access(e),l=g.extend({},a),R.set(n,l))}}function fe(e,n){var t=e.getElementsByTagName?e.getElementsByTagName(n||"*"):e.querySelectorAll?e.querySelectorAll(n||"*"):[];return void 0===n||n&&g.nodeName(e,n)?g.merge([e],t):t}le.optgroup=le.option,le.tbody=le.tfoot=le.colgroup=le.caption=le.thead,le.th=le.td,g.extend({clone:function(e,n,t){var o,r,i,s,a,l,c,d=e.cloneNode(!0),h=g.contains(e.ownerDocument,e);if(!(f.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||g.isXMLDoc(e)))for(s=fe(d),o=0,r=(i=fe(e)).length;o<r;o++)a=i[o],l=s[o],c=void 0,"input"===(c=l.nodeName.toLowerCase())&&Y.test(a.type)?l.checked=a.checked:"input"!==c&&"textarea"!==c||(l.defaultValue=a.defaultValue);if(n)if(t)for(i=i||fe(e),s=s||fe(d),o=0,r=i.length;o<r;o++)pe(i[o],s[o]);else pe(e,d);return(s=fe(d,"script")).length>0&&ue(s,!h&&fe(e,"script")),d},buildFragment:function(e,n,t,o){for(var r,i,s,a,l,c,d=n.createDocumentFragment(),h=[],u=0,p=e.length;u<p;u++)if((r=e[u])||0===r)if("object"===g.type(r))g.merge(h,r.nodeType?[r]:r);else if(te.test(r)){for(i=i||d.appendChild(n.createElement("div")),s=(ne.exec(r)||["",""])[1].toLowerCase(),a=le[s]||le._default,i.innerHTML=a[1]+r.replace(ee,"<$1></$2>")+a[2],c=a[0];c--;)i=i.lastChild;g.merge(h,i.childNodes),(i=d.firstChild).textContent=""}else h.push(n.createTextNode(r));for(d.textContent="",u=0;r=h[u++];)if((!o||-1===g.inArray(r,o))&&(l=g.contains(r.ownerDocument,r),i=fe(d.appendChild(r),"script"),l&&ue(i),t))for(c=0;r=i[c++];)ie.test(r.type||"")&&t.push(r);return d},cleanData:function(e){for(var n,t,o,r,i,s,a=g.event.special,l=0;void 0!==(t=e[l]);l++){if(g.acceptData(t)&&(i=t[B.expando])&&(n=B.cache[i])){if((o=Object.keys(n.events||{})).length)for(s=0;void 0!==(r=o[s]);s++)a[r]?g.event.remove(t,r):g.removeEvent(t,r,n.handle);B.cache[i]&&delete B.cache[i]}delete R.cache[t[R.expando]]}}}),g.fn.extend({text:function(e){return D(this,function(e){return void 0===e?g.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||ce(this,e).appendChild(e)})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var n=ce(this,e);n.insertBefore(e,n.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,n){for(var t,o=e?g.filter(e,this):this,r=0;null!=(t=o[r]);r++)n||1!==t.nodeType||g.cleanData(fe(t)),t.parentNode&&(n&&g.contains(t.ownerDocument,t)&&ue(fe(t,"script")),t.parentNode.removeChild(t));return this},empty:function(){for(var e,n=0;null!=(e=this[n]);n++)1===e.nodeType&&(g.cleanData(fe(e,!1)),e.textContent="");return this},clone:function(e,n){return e=null!=e&&e,n=null==n?e:n,this.map(function(){return g.clone(this,e,n)})},html:function(e){return D(this,function(e){var n=this[0]||{},t=0,o=this.length;if(void 0===e&&1===n.nodeType)return n.innerHTML;if("string"==typeof e&&!oe.test(e)&&!le[(ne.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(ee,"<$1></$2>");try{for(;t<o;t++)1===(n=this[t]||{}).nodeType&&(g.cleanData(fe(n,!1)),n.innerHTML=e);n=0}catch(e){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=arguments[0];return this.domManip(arguments,function(n){e=this.parentNode,g.cleanData(fe(this)),e&&e.replaceChild(n,this)}),e&&(e.length||e.nodeType)?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,n){e=a.apply([],e);var t,o,r,i,s,l,c=0,d=this.length,h=this,u=d-1,p=e[0],m=g.isFunction(p);if(m||d>1&&"string"==typeof p&&!f.checkClone&&re.test(p))return this.each(function(t){var o=h.eq(t);m&&(e[0]=p.call(this,t,o.html())),o.domManip(e,n)});if(d&&(o=(t=g.buildFragment(e,this[0].ownerDocument,!1,this)).firstChild,1===t.childNodes.length&&(t=o),o)){for(i=(r=g.map(fe(t,"script"),de)).length;c<d;c++)s=t,c!==u&&(s=g.clone(s,!0,!0),i&&g.merge(r,fe(s,"script"))),n.call(this[c],s,c);if(i)for(l=r[r.length-1].ownerDocument,g.map(r,he),c=0;c<i;c++)s=r[c],ie.test(s.type||"")&&!B.access(s,"globalEval")&&g.contains(l,s)&&(s.src?g._evalUrl&&g._evalUrl(s.src):g.globalEval(s.textContent.replace(ae,"")))}return this}}),g.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,n){g.fn[e]=function(e){for(var t,o=[],r=g(e),i=r.length-1,s=0;s<=i;s++)t=s===i?this:this.clone(!0),g(r[s])[n](t),l.apply(o,t.get());return this.pushStack(o)}});var me,ge={};function ye(e,n){var o=g(n.createElement(e)).appendTo(n.body),r=t.getDefaultComputedStyle?t.getDefaultComputedStyle(o[0]).display:g.css(o[0],"display");return o.detach(),r}function be(e){var n=m,t=ge[e];return t||("none"!==(t=ye(e,n))&&t||((n=(me=(me||g("<iframe frameborder='0' width='0' height='0'/>")).appendTo(n.documentElement))[0].contentDocument).write(),n.close(),t=ye(e,n),me.detach()),ge[e]=t),t}var xe=/^margin/,ve=new RegExp("^("+F+")(?!px)[a-z%]+$","i"),je=function(e){return e.ownerDocument.defaultView.getComputedStyle(e,null)};function we(e,n,t){var o,r,i,s,a=e.style;return(t=t||je(e))&&(s=t.getPropertyValue(n)||t[n]),t&&(""!==s||g.contains(e.ownerDocument,e)||(s=g.style(e,n)),ve.test(s)&&xe.test(n)&&(o=a.width,r=a.minWidth,i=a.maxWidth,a.minWidth=a.maxWidth=a.width=s,s=t.width,a.width=o,a.minWidth=r,a.maxWidth=i)),void 0!==s?s+"":s}function ke(e,n){return{get:function(){if(!e())return(this.get=n).apply(this,arguments);delete this.get}}}!function(){var e,n,o=m.documentElement,r=m.createElement("div"),i=m.createElement("div");function s(){i.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",o.appendChild(r);var s=t.getComputedStyle(i,null);e="1%"!==s.top,n="4px"===s.width,o.removeChild(r)}i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",f.clearCloneStyle="content-box"===i.style.backgroundClip,r.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",r.appendChild(i),t.getComputedStyle&&g.extend(f,{pixelPosition:function(){return s(),e},boxSizingReliable:function(){return null==n&&s(),n},reliableMarginRight:function(){var e,n=i.appendChild(m.createElement("div"));return n.style.cssText=i.style.cssText="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",n.style.marginRight=n.style.width="0",i.style.width="1px",o.appendChild(r),e=!parseFloat(t.getComputedStyle(n,null).marginRight),o.removeChild(r),i.innerHTML="",e}})}(),g.swap=function(e,n,t,o){var r,i,s={};for(i in n)s[i]=e.style[i],e.style[i]=n[i];for(i in r=t.apply(e,o||[]),n)e.style[i]=s[i];return r};var _e=/^(none|table(?!-c[ea]).+)/,Se=new RegExp("^("+F+")(.*)$","i"),Ce=new RegExp("^([+-])=("+F+")","i"),Ae={position:"absolute",visibility:"hidden",display:"block"},Te={letterSpacing:0,fontWeight:400},Oe=["Webkit","O","Moz","ms"];function Pe(e,n){if(n in e)return n;for(var t=n[0].toUpperCase()+n.slice(1),o=n,r=Oe.length;r--;)if((n=Oe[r]+t)in e)return n;return o}function Me(e,n,t){var o=Se.exec(n);return o?Math.max(0,o[1]-(t||0))+(o[2]||"px"):n}function Le(e,n,t,o,r){for(var i=t===(o?"border":"content")?4:"width"===n?1:0,s=0;i<4;i+=2)"margin"===t&&(s+=g.css(e,t+X[i],!0,r)),o?("content"===t&&(s-=g.css(e,"padding"+X[i],!0,r)),"margin"!==t&&(s-=g.css(e,"border"+X[i]+"Width",!0,r))):(s+=g.css(e,"padding"+X[i],!0,r),"padding"!==t&&(s+=g.css(e,"border"+X[i]+"Width",!0,r)));return s}function He(e,n,t){var o=!0,r="width"===n?e.offsetWidth:e.offsetHeight,i=je(e),s="border-box"===g.css(e,"boxSizing",!1,i);if(r<=0||null==r){if(((r=we(e,n,i))<0||null==r)&&(r=e.style[n]),ve.test(r))return r;o=s&&(f.boxSizingReliable()||r===e.style[n]),r=parseFloat(r)||0}return r+Le(e,n,t||(s?"border":"content"),o,i)+"px"}function Ie(e,n){for(var t,o,r,i=[],s=0,a=e.length;s<a;s++)(o=e[s]).style&&(i[s]=B.get(o,"olddisplay"),t=o.style.display,n?(i[s]||"none"!==t||(o.style.display=""),""===o.style.display&&V(o)&&(i[s]=B.access(o,"olddisplay",be(o.nodeName)))):i[s]||(r=V(o),(t&&"none"!==t||!r)&&B.set(o,"olddisplay",r?t:g.css(o,"display"))));for(s=0;s<a;s++)(o=e[s]).style&&(n&&"none"!==o.style.display&&""!==o.style.display||(o.style.display=n?i[s]||"":"none"));return e}function De(e,n,t,o,r){return new De.prototype.init(e,n,t,o,r)}g.extend({cssHooks:{opacity:{get:function(e,n){if(n){var t=we(e,"opacity");return""===t?"1":t}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{float:"cssFloat"},style:function(e,n,t,o){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var r,i,s,a=g.camelCase(n),l=e.style;if(n=g.cssProps[a]||(g.cssProps[a]=Pe(l,a)),s=g.cssHooks[n]||g.cssHooks[a],void 0===t)return s&&"get"in s&&void 0!==(r=s.get(e,!1,o))?r:l[n];"string"===(i=typeof t)&&(r=Ce.exec(t))&&(t=(r[1]+1)*r[2]+parseFloat(g.css(e,n)),i="number"),null!=t&&t==t&&("number"!==i||g.cssNumber[a]||(t+="px"),f.clearCloneStyle||""!==t||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&void 0===(t=s.set(e,t,o))||(l[n]="",l[n]=t))}},css:function(e,n,t,o){var r,i,s,a=g.camelCase(n);return n=g.cssProps[a]||(g.cssProps[a]=Pe(e.style,a)),(s=g.cssHooks[n]||g.cssHooks[a])&&"get"in s&&(r=s.get(e,!0,t)),void 0===r&&(r=we(e,n,o)),"normal"===r&&n in Te&&(r=Te[n]),""===t||t?(i=parseFloat(r),!0===t||g.isNumeric(i)?i||0:r):r}}),g.each(["height","width"],function(e,n){g.cssHooks[n]={get:function(e,t,o){if(t)return 0===e.offsetWidth&&_e.test(g.css(e,"display"))?g.swap(e,Ae,function(){return He(e,n,o)}):He(e,n,o)},set:function(e,t,o){var r=o&&je(e);return Me(0,t,o?Le(e,n,o,"border-box"===g.css(e,"boxSizing",!1,r),r):0)}}}),g.cssHooks.marginRight=ke(f.reliableMarginRight,function(e,n){if(n)return g.swap(e,{display:"inline-block"},we,[e,"marginRight"])}),g.each({margin:"",padding:"",border:"Width"},function(e,n){g.cssHooks[e+n]={expand:function(t){for(var o=0,r={},i="string"==typeof t?t.split(" "):[t];o<4;o++)r[e+X[o]+n]=i[o]||i[o-2]||i[0];return r}},xe.test(e)||(g.cssHooks[e+n].set=Me)}),g.fn.extend({css:function(e,n){return D(this,function(e,n,t){var o,r,i={},s=0;if(g.isArray(n)){for(o=je(e),r=n.length;s<r;s++)i[n[s]]=g.css(e,n[s],!1,o);return i}return void 0!==t?g.style(e,n,t):g.css(e,n)},e,n,arguments.length>1)},show:function(){return Ie(this,!0)},hide:function(){return Ie(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){V(this)?g(this).show():g(this).hide()})}}),g.Tween=De,De.prototype={constructor:De,init:function(e,n,t,o,r,i){this.elem=e,this.prop=t,this.easing=r||"swing",this.options=n,this.start=this.now=this.cur(),this.end=o,this.unit=i||(g.cssNumber[t]?"":"px")},cur:function(){var e=De.propHooks[this.prop];return e&&e.get?e.get(this):De.propHooks._default.get(this)},run:function(e){var n,t=De.propHooks[this.prop];return this.options.duration?this.pos=n=g.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=n=e,this.now=(this.end-this.start)*n+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),t&&t.set?t.set(this):De.propHooks._default.set(this),this}},De.prototype.init.prototype=De.prototype,De.propHooks={_default:{get:function(e){var n;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(n=g.css(e.elem,e.prop,""))&&"auto"!==n?n:0:e.elem[e.prop]},set:function(e){g.fx.step[e.prop]?g.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[g.cssProps[e.prop]]||g.cssHooks[e.prop])?g.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},De.propHooks.scrollTop=De.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},g.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},g.fx=De.prototype.init,g.fx.step={};var Ee,Be,Re,Ne,ze,Ge=/^(?:toggle|show|hide)$/,We=new RegExp("^(?:([+-])=|)("+F+")([a-z%]*)$","i"),Fe=/queueHooks$/,Xe=[function(e,n,t){var o,r,i,s,a,l,c,d=this,h={},u=e.style,p=e.nodeType&&V(e),f=B.get(e,"fxshow");t.queue||(null==(a=g._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,l=a.empty.fire,a.empty.fire=function(){a.unqueued||l()}),a.unqueued++,d.always(function(){d.always(function(){a.unqueued--,g.queue(e,"fx").length||a.empty.fire()})}));1===e.nodeType&&("height"in n||"width"in n)&&(t.overflow=[u.overflow,u.overflowX,u.overflowY],"none"===(c=g.css(e,"display"))&&(c=be(e.nodeName)),"inline"===c&&"none"===g.css(e,"float")&&(u.display="inline-block"));t.overflow&&(u.overflow="hidden",d.always(function(){u.overflow=t.overflow[0],u.overflowX=t.overflow[1],u.overflowY=t.overflow[2]}));for(o in n)if(r=n[o],Ge.exec(r)){if(delete n[o],i=i||"toggle"===r,r===(p?"hide":"show")){if("show"!==r||!f||void 0===f[o])continue;p=!0}h[o]=f&&f[o]||g.style(e,o)}if(!g.isEmptyObject(h))for(o in f?"hidden"in f&&(p=f.hidden):f=B.access(e,"fxshow",{}),i&&(f.hidden=!p),p?g(e).show():d.done(function(){g(e).hide()}),d.done(function(){var n;for(n in B.remove(e,"fxshow"),h)g.style(e,n,h[n])}),h)s=qe(p?f[o]:0,o,d),o in f||(f[o]=s.start,p&&(s.end=s.start,s.start="width"===o||"height"===o?1:0))}],Ve={"*":[function(e,n){var t=this.createTween(e,n),o=t.cur(),r=We.exec(n),i=r&&r[3]||(g.cssNumber[e]?"":"px"),s=(g.cssNumber[e]||"px"!==i&&+o)&&We.exec(g.css(t.elem,e)),a=1,l=20;if(s&&s[3]!==i){i=i||s[3],r=r||[],s=+o||1;do{s/=a=a||".5",g.style(t.elem,e,s+i)}while(a!==(a=t.cur()/o)&&1!==a&&--l)}return r&&(s=t.start=+s||+o||0,t.unit=i,t.end=r[1]?s+(r[1]+1)*r[2]:+r[2]),t}]};function Ye(){return setTimeout(function(){Ee=void 0}),Ee=g.now()}function Ue(e,n){var t,o=0,r={height:e};for(n=n?1:0;o<4;o+=2-n)r["margin"+(t=X[o])]=r["padding"+t]=e;return n&&(r.opacity=r.width=e),r}function qe(e,n,t){for(var o,r=(Ve[n]||[]).concat(Ve["*"]),i=0,s=r.length;i<s;i++)if(o=r[i].call(t,n,e))return o}function Ke(e,n,t){var o,r,i=0,s=Xe.length,a=g.Deferred().always(function(){delete l.elem}),l=function(){if(r)return!1;for(var n=Ee||Ye(),t=Math.max(0,c.startTime+c.duration-n),o=1-(t/c.duration||0),i=0,s=c.tweens.length;i<s;i++)c.tweens[i].run(o);return a.notifyWith(e,[c,o,t]),o<1&&s?t:(a.resolveWith(e,[c]),!1)},c=a.promise({elem:e,props:g.extend({},n),opts:g.extend(!0,{specialEasing:{}},t),originalProperties:n,originalOptions:t,startTime:Ee||Ye(),duration:t.duration,tweens:[],createTween:function(n,t){var o=g.Tween(e,c.opts,n,t,c.opts.specialEasing[n]||c.opts.easing);return c.tweens.push(o),o},stop:function(n){var t=0,o=n?c.tweens.length:0;if(r)return this;for(r=!0;t<o;t++)c.tweens[t].run(1);return n?a.resolveWith(e,[c,n]):a.rejectWith(e,[c,n]),this}}),d=c.props;for(!function(e,n){var t,o,r,i,s;for(t in e)if(r=n[o=g.camelCase(t)],i=e[t],g.isArray(i)&&(r=i[1],i=e[t]=i[0]),t!==o&&(e[o]=i,delete e[t]),(s=g.cssHooks[o])&&"expand"in s)for(t in i=s.expand(i),delete e[o],i)t in e||(e[t]=i[t],n[t]=r);else n[o]=r}(d,c.opts.specialEasing);i<s;i++)if(o=Xe[i].call(c,e,d,c.opts))return o;return g.map(d,qe,c),g.isFunction(c.opts.start)&&c.opts.start.call(e,c),g.fx.timer(g.extend(l,{elem:e,anim:c,queue:c.opts.queue})),c.progress(c.opts.progress).done(c.opts.done,c.opts.complete).fail(c.opts.fail).always(c.opts.always)}g.Animation=g.extend(Ke,{tweener:function(e,n){g.isFunction(e)?(n=e,e=["*"]):e=e.split(" ");for(var t,o=0,r=e.length;o<r;o++)t=e[o],Ve[t]=Ve[t]||[],Ve[t].unshift(n)},prefilter:function(e,n){n?Xe.unshift(e):Xe.push(e)}}),g.speed=function(e,n,t){var o=e&&"object"==typeof e?g.extend({},e):{complete:t||!t&&n||g.isFunction(e)&&e,duration:e,easing:t&&n||n&&!g.isFunction(n)&&n};return o.duration=g.fx.off?0:"number"==typeof o.duration?o.duration:o.duration in g.fx.speeds?g.fx.speeds[o.duration]:g.fx.speeds._default,null!=o.queue&&!0!==o.queue||(o.queue="fx"),o.old=o.complete,o.complete=function(){g.isFunction(o.old)&&o.old.call(this),o.queue&&g.dequeue(this,o.queue)},o},g.fn.extend({fadeTo:function(e,n,t,o){return this.filter(V).css("opacity",0).show().end().animate({opacity:n},e,t,o)},animate:function(e,n,t,o){var r=g.isEmptyObject(e),i=g.speed(n,t,o),s=function(){var n=Ke(this,g.extend({},e),i);(r||B.get(this,"finish"))&&n.stop(!0)};return s.finish=s,r||!1===i.queue?this.each(s):this.queue(i.queue,s)},stop:function(e,n,t){var o=function(e){var n=e.stop;delete e.stop,n(t)};return"string"!=typeof e&&(t=n,n=e,e=void 0),n&&!1!==e&&this.queue(e||"fx",[]),this.each(function(){var n=!0,r=null!=e&&e+"queueHooks",i=g.timers,s=B.get(this);if(r)s[r]&&s[r].stop&&o(s[r]);else for(r in s)s[r]&&s[r].stop&&Fe.test(r)&&o(s[r]);for(r=i.length;r--;)i[r].elem!==this||null!=e&&i[r].queue!==e||(i[r].anim.stop(t),n=!1,i.splice(r,1));!n&&t||g.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||"fx"),this.each(function(){var n,t=B.get(this),o=t[e+"queue"],r=t[e+"queueHooks"],i=g.timers,s=o?o.length:0;for(t.finish=!0,g.queue(this,e,[]),r&&r.stop&&r.stop.call(this,!0),n=i.length;n--;)i[n].elem===this&&i[n].queue===e&&(i[n].anim.stop(!0),i.splice(n,1));for(n=0;n<s;n++)o[n]&&o[n].finish&&o[n].finish.call(this);delete t.finish})}}),g.each(["toggle","show","hide"],function(e,n){var t=g.fn[n];g.fn[n]=function(e,o,r){return null==e||"boolean"==typeof e?t.apply(this,arguments):this.animate(Ue(n,!0),e,o,r)}}),g.each({slideDown:Ue("show"),slideUp:Ue("hide"),slideToggle:Ue("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,n){g.fn[e]=function(e,t,o){return this.animate(n,e,t,o)}}),g.timers=[],g.fx.tick=function(){var e,n=0,t=g.timers;for(Ee=g.now();n<t.length;n++)(e=t[n])()||t[n]!==e||t.splice(n--,1);t.length||g.fx.stop(),Ee=void 0},g.fx.timer=function(e){g.timers.push(e),e()?g.fx.start():g.timers.pop()},g.fx.interval=13,g.fx.start=function(){Be||(Be=setInterval(g.fx.tick,g.fx.interval))},g.fx.stop=function(){clearInterval(Be),Be=null},g.fx.speeds={slow:600,fast:200,_default:400},g.fn.delay=function(e,n){return e=g.fx&&g.fx.speeds[e]||e,n=n||"fx",this.queue(n,function(n,t){var o=setTimeout(n,e);t.stop=function(){clearTimeout(o)}})},Re=m.createElement("input"),Ne=m.createElement("select"),ze=Ne.appendChild(m.createElement("option")),Re.type="checkbox",f.checkOn=""!==Re.value,f.optSelected=ze.selected,Ne.disabled=!0,f.optDisabled=!ze.disabled,(Re=m.createElement("input")).value="t",Re.type="radio",f.radioValue="t"===Re.value;var $e,Ze=g.expr.attrHandle;g.fn.extend({attr:function(e,n){return D(this,g.attr,e,n,arguments.length>1)},removeAttr:function(e){return this.each(function(){g.removeAttr(this,e)})}}),g.extend({attr:function(e,n,t){var o,r,i=e.nodeType;if(e&&3!==i&&8!==i&&2!==i)return void 0===e.getAttribute?g.prop(e,n,t):(1===i&&g.isXMLDoc(e)||(n=n.toLowerCase(),o=g.attrHooks[n]||(g.expr.match.bool.test(n)?$e:void 0)),void 0===t?o&&"get"in o&&null!==(r=o.get(e,n))?r:null==(r=g.find.attr(e,n))?void 0:r:null!==t?o&&"set"in o&&void 0!==(r=o.set(e,t,n))?r:(e.setAttribute(n,t+""),t):void g.removeAttr(e,n))},removeAttr:function(e,n){var t,o,r=0,i=n&&n.match(L);if(i&&1===e.nodeType)for(;t=i[r++];)o=g.propFix[t]||t,g.expr.match.bool.test(t)&&(e[o]=!1),e.removeAttribute(t)},attrHooks:{type:{set:function(e,n){if(!f.radioValue&&"radio"===n&&g.nodeName(e,"input")){var t=e.value;return e.setAttribute("type",n),t&&(e.value=t),n}}}}}),$e={set:function(e,n,t){return!1===n?g.removeAttr(e,t):e.setAttribute(t,t),t}},g.each(g.expr.match.bool.source.match(/\w+/g),function(e,n){var t=Ze[n]||g.find.attr;Ze[n]=function(e,n,o){var r,i;return o||(i=Ze[n],Ze[n]=r,r=null!=t(e,n,o)?n.toLowerCase():null,Ze[n]=i),r}});var Je=/^(?:input|select|textarea|button)$/i;g.fn.extend({prop:function(e,n){return D(this,g.prop,e,n,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[g.propFix[e]||e]})}}),g.extend({propFix:{for:"htmlFor",class:"className"},prop:function(e,n,t){var o,r,i=e.nodeType;if(e&&3!==i&&8!==i&&2!==i)return(1!==i||!g.isXMLDoc(e))&&(n=g.propFix[n]||n,r=g.propHooks[n]),void 0!==t?r&&"set"in r&&void 0!==(o=r.set(e,t,n))?o:e[n]=t:r&&"get"in r&&null!==(o=r.get(e,n))?o:e[n]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||Je.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),f.optSelected||(g.propHooks.selected={get:function(e){var n=e.parentNode;return n&&n.parentNode&&n.parentNode.selectedIndex,null}}),g.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){g.propFix[this.toLowerCase()]=this});var Qe=/[\t\r\n\f]/g;g.fn.extend({addClass:function(e){var n,t,o,r,i,s,a="string"==typeof e&&e,l=0,c=this.length;if(g.isFunction(e))return this.each(function(n){g(this).addClass(e.call(this,n,this.className))});if(a)for(n=(e||"").match(L)||[];l<c;l++)if(o=1===(t=this[l]).nodeType&&(t.className?(" "+t.className+" ").replace(Qe," "):" ")){for(i=0;r=n[i++];)o.indexOf(" "+r+" ")<0&&(o+=r+" ");s=g.trim(o),t.className!==s&&(t.className=s)}return this},removeClass:function(e){var n,t,o,r,i,s,a=0===arguments.length||"string"==typeof e&&e,l=0,c=this.length;if(g.isFunction(e))return this.each(function(n){g(this).removeClass(e.call(this,n,this.className))});if(a)for(n=(e||"").match(L)||[];l<c;l++)if(o=1===(t=this[l]).nodeType&&(t.className?(" "+t.className+" ").replace(Qe," "):"")){for(i=0;r=n[i++];)for(;o.indexOf(" "+r+" ")>=0;)o=o.replace(" "+r+" "," ");s=e?g.trim(o):"",t.className!==s&&(t.className=s)}return this},toggleClass:function(e,n){var t=typeof e;return"boolean"==typeof n&&"string"===t?n?this.addClass(e):this.removeClass(e):g.isFunction(e)?this.each(function(t){g(this).toggleClass(e.call(this,t,this.className,n),n)}):this.each(function(){if("string"===t)for(var n,o=0,r=g(this),i=e.match(L)||[];n=i[o++];)r.hasClass(n)?r.removeClass(n):r.addClass(n);else"undefined"!==t&&"boolean"!==t||(this.className&&B.set(this,"__className__",this.className),this.className=this.className||!1===e?"":B.get(this,"__className__")||"")})},hasClass:function(e){for(var n=" "+e+" ",t=0,o=this.length;t<o;t++)if(1===this[t].nodeType&&(" "+this[t].className+" ").replace(Qe," ").indexOf(n)>=0)return!0;return!1}});var en=/\r/g;g.fn.extend({val:function(e){var n,t,o,r=this[0];return arguments.length?(o=g.isFunction(e),this.each(function(t){var r;1===this.nodeType&&(null==(r=o?e.call(this,t,g(this).val()):e)?r="":"number"==typeof r?r+="":g.isArray(r)&&(r=g.map(r,function(e){return null==e?"":e+""})),(n=g.valHooks[this.type]||g.valHooks[this.nodeName.toLowerCase()])&&"set"in n&&void 0!==n.set(this,r,"value")||(this.value=r))})):r?(n=g.valHooks[r.type]||g.valHooks[r.nodeName.toLowerCase()])&&"get"in n&&void 0!==(t=n.get(r,"value"))?t:"string"==typeof(t=r.value)?t.replace(en,""):null==t?"":t:void 0}}),g.extend({valHooks:{select:{get:function(e){for(var n,t,o=e.options,r=e.selectedIndex,i="select-one"===e.type||r<0,s=i?null:[],a=i?r+1:o.length,l=r<0?a:i?r:0;l<a;l++)if(((t=o[l]).selected||l===r)&&(f.optDisabled?!t.disabled:null===t.getAttribute("disabled"))&&(!t.parentNode.disabled||!g.nodeName(t.parentNode,"optgroup"))){if(n=g(t).val(),i)return n;s.push(n)}return s},set:function(e,n){for(var t,o,r=e.options,i=g.makeArray(n),s=r.length;s--;)((o=r[s]).selected=g.inArray(g(o).val(),i)>=0)&&(t=!0);return t||(e.selectedIndex=-1),i}}}}),g.each(["radio","checkbox"],function(){g.valHooks[this]={set:function(e,n){if(g.isArray(n))return e.checked=g.inArray(g(e).val(),n)>=0}},f.checkOn||(g.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),g.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,n){g.fn[n]=function(e,t){return arguments.length>0?this.on(n,null,e,t):this.trigger(n)}}),g.fn.extend({hover:function(e,n){return this.mouseenter(e).mouseleave(n||e)},bind:function(e,n,t){return this.on(e,null,n,t)},unbind:function(e,n){return this.off(e,null,n)},delegate:function(e,n,t,o){return this.on(n,e,t,o)},undelegate:function(e,n,t){return 1===arguments.length?this.off(e,"**"):this.off(n,e||"**",t)}});var nn=g.now(),tn=/\?/;g.parseJSON=function(e){return JSON.parse(e+"")},g.parseXML=function(e){var n;if(!e||"string"!=typeof e)return null;try{n=(new DOMParser).parseFromString(e,"text/xml")}catch(e){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||g.error("Invalid XML: "+e),n};var on,rn,sn=/#.*$/,an=/([?&])_=[^&]*/,ln=/^(.*?):[ \t]*([^\r\n]*)$/gm,cn=/^(?:GET|HEAD)$/,dn=/^\/\//,hn=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,un={},pn={},fn="*/".concat("*");try{rn=location.href}catch(e){(rn=m.createElement("a")).href="",rn=rn.href}function mn(e){return function(n,t){"string"!=typeof n&&(t=n,n="*");var o,r=0,i=n.toLowerCase().match(L)||[];if(g.isFunction(t))for(;o=i[r++];)"+"===o[0]?(o=o.slice(1)||"*",(e[o]=e[o]||[]).unshift(t)):(e[o]=e[o]||[]).push(t)}}function gn(e,n,t,o){var r={},i=e===pn;function s(a){var l;return r[a]=!0,g.each(e[a]||[],function(e,a){var c=a(n,t,o);return"string"!=typeof c||i||r[c]?i?!(l=c):void 0:(n.dataTypes.unshift(c),s(c),!1)}),l}return s(n.dataTypes[0])||!r["*"]&&s("*")}function yn(e,n){var t,o,r=g.ajaxSettings.flatOptions||{};for(t in n)void 0!==n[t]&&((r[t]?e:o||(o={}))[t]=n[t]);return o&&g.extend(!0,e,o),e}on=hn.exec(rn.toLowerCase())||[],g.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:rn,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(on[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":fn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":g.parseJSON,"text xml":g.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,n){return n?yn(yn(e,g.ajaxSettings),n):yn(g.ajaxSettings,e)},ajaxPrefilter:mn(un),ajaxTransport:mn(pn),ajax:function(e,n){"object"==typeof e&&(n=e,e=void 0),n=n||{};var t,o,r,i,s,a,l,c,d=g.ajaxSetup({},n),h=d.context||d,u=d.context&&(h.nodeType||h.jquery)?g(h):g.event,p=g.Deferred(),f=g.Callbacks("once memory"),m=d.statusCode||{},y={},b={},x=0,v="canceled",j={readyState:0,getResponseHeader:function(e){var n;if(2===x){if(!i)for(i={};n=ln.exec(r);)i[n[1].toLowerCase()]=n[2];n=i[e.toLowerCase()]}return null==n?null:n},getAllResponseHeaders:function(){return 2===x?r:null},setRequestHeader:function(e,n){var t=e.toLowerCase();return x||(e=b[t]=b[t]||e,y[e]=n),this},overrideMimeType:function(e){return x||(d.mimeType=e),this},statusCode:function(e){var n;if(e)if(x<2)for(n in e)m[n]=[m[n],e[n]];else j.always(e[j.status]);return this},abort:function(e){var n=e||v;return t&&t.abort(n),w(0,n),this}};if(p.promise(j).complete=f.add,j.success=j.done,j.error=j.fail,d.url=((e||d.url||rn)+"").replace(sn,"").replace(dn,on[1]+"//"),d.type=n.method||n.type||d.method||d.type,d.dataTypes=g.trim(d.dataType||"*").toLowerCase().match(L)||[""],null==d.crossDomain&&(a=hn.exec(d.url.toLowerCase()),d.crossDomain=!(!a||a[1]===on[1]&&a[2]===on[2]&&(a[3]||("http:"===a[1]?"80":"443"))===(on[3]||("http:"===on[1]?"80":"443")))),d.data&&d.processData&&"string"!=typeof d.data&&(d.data=g.param(d.data,d.traditional)),gn(un,d,n,j),2===x)return j;for(c in(l=d.global)&&0==g.active++&&g.event.trigger("ajaxStart"),d.type=d.type.toUpperCase(),d.hasContent=!cn.test(d.type),o=d.url,d.hasContent||(d.data&&(o=d.url+=(tn.test(o)?"&":"?")+d.data,delete d.data),!1===d.cache&&(d.url=an.test(o)?o.replace(an,"$1_="+nn++):o+(tn.test(o)?"&":"?")+"_="+nn++)),d.ifModified&&(g.lastModified[o]&&j.setRequestHeader("If-Modified-Since",g.lastModified[o]),g.etag[o]&&j.setRequestHeader("If-None-Match",g.etag[o])),(d.data&&d.hasContent&&!1!==d.contentType||n.contentType)&&j.setRequestHeader("Content-Type",d.contentType),j.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+("*"!==d.dataTypes[0]?", "+fn+"; q=0.01":""):d.accepts["*"]),d.headers)j.setRequestHeader(c,d.headers[c]);if(d.beforeSend&&(!1===d.beforeSend.call(h,j,d)||2===x))return j.abort();for(c in v="abort",{success:1,error:1,complete:1})j[c](d[c]);if(t=gn(pn,d,n,j)){j.readyState=1,l&&u.trigger("ajaxSend",[j,d]),d.async&&d.timeout>0&&(s=setTimeout(function(){j.abort("timeout")},d.timeout));try{x=1,t.send(y,w)}catch(e){if(!(x<2))throw e;w(-1,e)}}else w(-1,"No Transport");function w(e,n,i,a){var c,y,b,v,w,k=n;2!==x&&(x=2,s&&clearTimeout(s),t=void 0,r=a||"",j.readyState=e>0?4:0,c=e>=200&&e<300||304===e,i&&(v=function(e,n,t){for(var o,r,i,s,a=e.contents,l=e.dataTypes;"*"===l[0];)l.shift(),void 0===o&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(r in a)if(a[r]&&a[r].test(o)){l.unshift(r);break}if(l[0]in t)i=l[0];else{for(r in t){if(!l[0]||e.converters[r+" "+l[0]]){i=r;break}s||(s=r)}i=i||s}if(i)return i!==l[0]&&l.unshift(i),t[i]}(d,j,i)),v=function(e,n,t,o){var r,i,s,a,l,c={},d=e.dataTypes.slice();if(d[1])for(s in e.converters)c[s.toLowerCase()]=e.converters[s];for(i=d.shift();i;)if(e.responseFields[i]&&(t[e.responseFields[i]]=n),!l&&o&&e.dataFilter&&(n=e.dataFilter(n,e.dataType)),l=i,i=d.shift())if("*"===i)i=l;else if("*"!==l&&l!==i){if(!(s=c[l+" "+i]||c["* "+i]))for(r in c)if((a=r.split(" "))[1]===i&&(s=c[l+" "+a[0]]||c["* "+a[0]])){!0===s?s=c[r]:!0!==c[r]&&(i=a[0],d.unshift(a[1]));break}if(!0!==s)if(s&&e.throws)n=s(n);else try{n=s(n)}catch(e){return{state:"parsererror",error:s?e:"No conversion from "+l+" to "+i}}}return{state:"success",data:n}}(d,v,j,c),c?(d.ifModified&&((w=j.getResponseHeader("Last-Modified"))&&(g.lastModified[o]=w),(w=j.getResponseHeader("etag"))&&(g.etag[o]=w)),204===e||"HEAD"===d.type?k="nocontent":304===e?k="notmodified":(k=v.state,y=v.data,c=!(b=v.error))):(b=k,!e&&k||(k="error",e<0&&(e=0))),j.status=e,j.statusText=(n||k)+"",c?p.resolveWith(h,[y,k,j]):p.rejectWith(h,[j,k,b]),j.statusCode(m),m=void 0,l&&u.trigger(c?"ajaxSuccess":"ajaxError",[j,d,c?y:b]),f.fireWith(h,[j,k]),l&&(u.trigger("ajaxComplete",[j,d]),--g.active||g.event.trigger("ajaxStop")))}return j},getJSON:function(e,n,t){return g.get(e,n,t,"json")},getScript:function(e,n){return g.get(e,void 0,n,"script")}}),g.each(["get","post"],function(e,n){g[n]=function(e,t,o,r){return g.isFunction(t)&&(r=r||o,o=t,t=void 0),g.ajax({url:e,type:n,dataType:r,data:t,success:o})}}),g.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,n){g.fn[n]=function(e){return this.on(n,e)}}),g._evalUrl=function(e){return g.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,throws:!0})},g.fn.extend({wrapAll:function(e){var n;return g.isFunction(e)?this.each(function(n){g(this).wrapAll(e.call(this,n))}):(this[0]&&(n=g(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&n.insertBefore(this[0]),n.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return g.isFunction(e)?this.each(function(n){g(this).wrapInner(e.call(this,n))}):this.each(function(){var n=g(this),t=n.contents();t.length?t.wrapAll(e):n.append(e)})},wrap:function(e){var n=g.isFunction(e);return this.each(function(t){g(this).wrapAll(n?e.call(this,t):e)})},unwrap:function(){return this.parent().each(function(){g.nodeName(this,"body")||g(this).replaceWith(this.childNodes)}).end()}}),g.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},g.expr.filters.visible=function(e){return!g.expr.filters.hidden(e)};var bn=/%20/g,xn=/\[\]$/,vn=/\r?\n/g,jn=/^(?:submit|button|image|reset|file)$/i,wn=/^(?:input|select|textarea|keygen)/i;function kn(e,n,t,o){var r;if(g.isArray(n))g.each(n,function(n,r){t||xn.test(e)?o(e,r):kn(e+"["+("object"==typeof r?n:"")+"]",r,t,o)});else if(t||"object"!==g.type(n))o(e,n);else for(r in n)kn(e+"["+r+"]",n[r],t,o)}g.param=function(e,n){var t,o=[],r=function(e,n){n=g.isFunction(n)?n():null==n?"":n,o[o.length]=encodeURIComponent(e)+"="+encodeURIComponent(n)};if(void 0===n&&(n=g.ajaxSettings&&g.ajaxSettings.traditional),g.isArray(e)||e.jquery&&!g.isPlainObject(e))g.each(e,function(){r(this.name,this.value)});else for(t in e)kn(t,e[t],n,r);return o.join("&").replace(bn,"+")},g.fn.extend({serialize:function(){return g.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=g.prop(this,"elements");return e?g.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!g(this).is(":disabled")&&wn.test(this.nodeName)&&!jn.test(e)&&(this.checked||!Y.test(e))}).map(function(e,n){var t=g(this).val();return null==t?null:g.isArray(t)?g.map(t,function(e){return{name:n.name,value:e.replace(vn,"\r\n")}}):{name:n.name,value:t.replace(vn,"\r\n")}}).get()}}),g.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var _n=0,Sn={},Cn={0:200,1223:204},An=g.ajaxSettings.xhr();t.ActiveXObject&&g(t).on("unload",function(){for(var e in Sn)Sn[e]()}),f.cors=!!An&&"withCredentials"in An,f.ajax=An=!!An,g.ajaxTransport(function(e){var n;if(f.cors||An&&!e.crossDomain)return{send:function(t,o){var r,i=e.xhr(),s=++_n;if(i.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(r in e.xhrFields)i[r]=e.xhrFields[r];for(r in e.mimeType&&i.overrideMimeType&&i.overrideMimeType(e.mimeType),e.crossDomain||t["X-Requested-With"]||(t["X-Requested-With"]="XMLHttpRequest"),t)i.setRequestHeader(r,t[r]);n=function(e){return function(){n&&(delete Sn[s],n=i.onload=i.onerror=null,"abort"===e?i.abort():"error"===e?o(i.status,i.statusText):o(Cn[i.status]||i.status,i.statusText,"string"==typeof i.responseText?{text:i.responseText}:void 0,i.getAllResponseHeaders()))}},i.onload=n(),i.onerror=n("error"),n=Sn[s]=n("abort"),i.send(e.hasContent&&e.data||null)},abort:function(){n&&n()}}}),g.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return g.globalEval(e),e}}}),g.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),g.ajaxTransport("script",function(e){var n,t;if(e.crossDomain)return{send:function(o,r){n=g("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",t=function(e){n.remove(),t=null,e&&r("error"===e.type?404:200,e.type)}),m.head.appendChild(n[0])},abort:function(){t&&t()}}});var Tn=[],On=/(=)\?(?=&|$)|\?\?/;g.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Tn.pop()||g.expando+"_"+nn++;return this[e]=!0,e}}),g.ajaxPrefilter("json jsonp",function(e,n,o){var r,i,s,a=!1!==e.jsonp&&(On.test(e.url)?"url":"string"==typeof e.data&&!(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&On.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=g.isFunction(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(On,"$1"+r):!1!==e.jsonp&&(e.url+=(tn.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return s||g.error(r+" was not called"),s[0]},e.dataTypes[0]="json",i=t[r],t[r]=function(){s=arguments},o.always(function(){t[r]=i,e[r]&&(e.jsonpCallback=n.jsonpCallback,Tn.push(r)),s&&g.isFunction(i)&&i(s[0]),s=i=void 0}),"script"}),g.parseHTML=function(e,n,t){if(!e||"string"!=typeof e)return null;"boolean"==typeof n&&(t=n,n=!1),n=n||m;var o=k.exec(e),r=!t&&[];return o?[n.createElement(o[1])]:(o=g.buildFragment([e],n,r),r&&r.length&&g(r).remove(),g.merge([],o.childNodes))};var Pn=g.fn.load;g.fn.load=function(e,n,t){if("string"!=typeof e&&Pn)return Pn.apply(this,arguments);var o,r,i,s=this,a=e.indexOf(" ");return a>=0&&(o=e.slice(a),e=e.slice(0,a)),g.isFunction(n)?(t=n,n=void 0):n&&"object"==typeof n&&(r="POST"),s.length>0&&g.ajax({url:e,type:r,dataType:"html",data:n}).done(function(e){i=arguments,s.html(o?g("<div>").append(g.parseHTML(e)).find(o):e)}).complete(t&&function(e,n){s.each(t,i||[e.responseText,n,e])}),this},g.expr.filters.animated=function(e){return g.grep(g.timers,function(n){return e===n.elem}).length};var Mn=t.document.documentElement;function Ln(e){return g.isWindow(e)?e:9===e.nodeType&&e.defaultView}g.offset={setOffset:function(e,n,t){var o,r,i,s,a,l,c=g.css(e,"position"),d=g(e),h={};"static"===c&&(e.style.position="relative"),a=d.offset(),i=g.css(e,"top"),l=g.css(e,"left"),("absolute"===c||"fixed"===c)&&(i+l).indexOf("auto")>-1?(s=(o=d.position()).top,r=o.left):(s=parseFloat(i)||0,r=parseFloat(l)||0),g.isFunction(n)&&(n=n.call(e,t,a)),null!=n.top&&(h.top=n.top-a.top+s),null!=n.left&&(h.left=n.left-a.left+r),"using"in n?n.using.call(e,h):d.css(h)}},g.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(n){g.offset.setOffset(this,e,n)});var n,t,o=this[0],r={top:0,left:0},i=o&&o.ownerDocument;return i?(n=i.documentElement,g.contains(n,o)?(void 0!==o.getBoundingClientRect&&(r=o.getBoundingClientRect()),t=Ln(i),{top:r.top+t.pageYOffset-n.clientTop,left:r.left+t.pageXOffset-n.clientLeft}):r):void 0},position:function(){if(this[0]){var e,n,t=this[0],o={top:0,left:0};return"fixed"===g.css(t,"position")?n=t.getBoundingClientRect():(e=this.offsetParent(),n=this.offset(),g.nodeName(e[0],"html")||(o=e.offset()),o.top+=g.css(e[0],"borderTopWidth",!0),o.left+=g.css(e[0],"borderLeftWidth",!0)),{top:n.top-o.top-g.css(t,"marginTop",!0),left:n.left-o.left-g.css(t,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||Mn;e&&!g.nodeName(e,"html")&&"static"===g.css(e,"position");)e=e.offsetParent;return e||Mn})}}),g.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var o="pageYOffset"===n;g.fn[e]=function(r){return D(this,function(e,r,i){var s=Ln(e);if(void 0===i)return s?s[n]:e[r];s?s.scrollTo(o?t.pageXOffset:i,o?i:t.pageYOffset):e[r]=i},e,r,arguments.length,null)}}),g.each(["top","left"],function(e,n){g.cssHooks[n]=ke(f.pixelPosition,function(e,t){if(t)return t=we(e,n),ve.test(t)?g(e).position()[n]+"px":t})}),g.each({Height:"height",Width:"width"},function(e,n){g.each({padding:"inner"+e,content:n,"":"outer"+e},function(t,o){g.fn[o]=function(o,r){var i=arguments.length&&(t||"boolean"!=typeof o),s=t||(!0===o||!0===r?"margin":"border");return D(this,function(n,t,o){var r;return g.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(r=n.documentElement,Math.max(n.body["scroll"+e],r["scroll"+e],n.body["offset"+e],r["offset"+e],r["client"+e])):void 0===o?g.css(n,t,s):g.style(n,t,o,s)},n,i?o:void 0,i,null)}})}),g.fn.size=function(){return this.length},g.fn.andSelf=g.fn.addBack,void 0===(o=function(){return g}.apply(n,[]))||(e.exports=o);var Hn=t.jQuery,In=t.$;return g.noConflict=function(e){return t.$===g&&(t.$=In),e&&t.jQuery===g&&(t.jQuery=Hn),g},void 0===r&&(t.jQuery=t.$=g),g},"object"==typeof e.exports?e.exports=r.document?i(r,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return i(e)}:i(r)},"shared/controls/Messages":function(e,n,t){var o,r;o=[n,t("shim/jquery")],void 0===(r=function(e,n){"use strict";var t;function o(e,n){if(null!=e&&null!=e._$messageEl){e._$messageEl.text(n),e._$messageEl.attr("title",n);try{e._$messageEl.tooltip("destroy"),e._$messageEl.tooltip({animation:!1})}catch(e){console.error(e)}}}Object.defineProperty(e,"__esModule",{value:!0}),e.setDropdownMessage=o,e.removeDropdownMessage=function(e){o(e,"")},e.setAlert=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"error",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",i=arguments.length>4?arguments[4]:void 0;if(null!=e){i&&e.show();var s=(0,n.default)("<div></div>").addClass("alert alert-".concat(o," ").concat(r)),a=(0,n.default)("<i></i>").addClass("icon-alert"),l=(0,n.default)("<p></p>").text(t);e.append(s.append(a,l))}},e.removeAlert=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null!=e&&(e.children(".alert").remove(),n&&e.hide())},n=(t=n)&&t.__esModule?t:{default:t}}.apply(n,o))||(e.exports=r)},"shim/jquery":function(e,n,t){var o,r;o=[t("contrib/jquery-2.1.0")],void 0===(r=function(e){return window.$||(window.$=e,window.jQuery=e),e}.apply(n,o))||(e.exports=r)},"splunk/palettes/ColorCodes":function(e,n,t){var o;void 0===(o=function(e,n,o){var r=t("contrib/jg_lib/Class"),i=t("contrib/jg_lib/graphics/Color");return r(o.i,function(e){e.CATEGORICAL=["#006d9c","#4fa484","#ec9960","#af575a","#b6c75a","#62b3b2","#294e70","#738795","#edd051","#bd9872","#5a4575","#7ea77b","#708794","#d7c6b7","#339bb2","#55672d","#e6e1ae","#96907f","#87bc65","#cf7e60","#7b5547","#77d6d8","#4a7f2c","#f589ad","#6a2c5d","#aaabae","#9a7438","#a4d563","#7672a4","#184b81","#7fb6ce","#a7d2c2","#f6ccb0","#d7abad","#dbe3ad","#b1d9d9","#94a7b8","#b9c3ca","#f6e8a8","#deccb9","#b7acca","#b2cab0","#a5b2bf","#e9ddd4","#66c3d0","#aab396","#f3f0d7","#c1bcb3","#b6d7a3","#e1b2a1","#dec4ba","#abe6e8","#91b282","#f8b7ce","#cba3c2","#cccdce","#c3ab89","#c7e6a3","#ada9c8","#a4bbe0"],e.CATEGORICAL_DARK=e.CATEGORICAL,e.SEMANTIC_BY_NAME={success:"#53a051",info:"#006d9c",warning:"#f8be34",alert:"#f1813f",error:"#dc4e41"},e.SEMANTIC=[e.SEMANTIC_BY_NAME.success,e.SEMANTIC_BY_NAME.info,e.SEMANTIC_BY_NAME.warning,e.SEMANTIC_BY_NAME.alert,e.SEMANTIC_BY_NAME.error],e.SEMANTIC_DARK=e.SEMANTIC,e.SEQUENTIAL=[e.SEMANTIC_BY_NAME.success,e.SEMANTIC_BY_NAME.error,e.SEMANTIC_BY_NAME.info],e.DIVERGENT_PAIRS=[["#006D9C","#EC9960"],["#62B3B2","#AF575A"],["#AF575A","#F8BE34"],["#F8BE34","#4FA484"],["#708794","#5A4575"],["#294E70","#B6C75A"]],e.DARK_GREY="#3c444d",e.toColors=function(e){for(var n=[],t=0,o=e.length;t<o;t++)n.push(i.fromString(e[t]));return n},e.toNumbers=function(e){for(var n=[],t=0,o=e.length;t<o;t++)n.push(i.fromString(e[t]).toNumber());return n},e.toArrays=function(e){for(var n=[],t=0,o=e.length;t<o;t++)n.push(i.fromString(e[t]).toArray());return n},e.toPrefixed=function(e,n){for(var t=[],o=0,r=e.length;o<r;o++)t.push(n+e[o].replace(/^(0x|#)/,""));return t}})}.call(n,t,n,e))||(e.exports=o)},"util/theme_utils":function(e,n,t){var o,r;o=[n,t("./node_modules/@splunk/react-ui/themes.js"),t("./node_modules/@splunk/react-time-range/themes.js"),t("./node_modules/@splunk/splunk-utils/themes.js"),t("./node_modules/styled-components/dist/styled-components.browser.esm.js")],void 0===(r=function(e,n,t,o,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getCurrentTheme=s,e.getXmlEditorTheme=function(){return"dark"===s()?"ace/theme/xml-dark":"ace/theme/chrome"},e.getSearchEditorTheme=function(){return"dark"===s()?"dark":"light"},e.getReactUITheme=function(){var e=(0,o.defaultTheme)();return n.themes[e]},e.getReactTimeRangeTheme=function(){var e=(0,o.defaultTheme)();return t.themes[e]},e.normalizeToDefaultTheme=function(e){if(null==e||""===e)return i;return e},Object.defineProperty(e,"defaultReactThemeId",{enumerable:!0,get:function(){return o.defaultTheme}}),Object.defineProperty(e,"ThemeProvider",{enumerable:!0,get:function(){return r.ThemeProvider}});var i="light";function s(){return window.__splunk_page_theme__||i}}.apply(n,o))||(e.exports=r)},"vizapi/SplunkVisualizationBase":function(n,t){n.exports=e}})});